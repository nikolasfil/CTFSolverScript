<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.4">
<title>ctfsolver.src.manager_connections API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctfsolver.src.manager_connections</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctfsolver.src.manager_connections.ManagerConnections"><code class="flex name class">
<span>class <span class="ident">ManagerConnections</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ManagerConnections:
    def __init__(self, *args, **kwargs) -&gt; None:
        self.pwn = pwn

        self.url = kwargs.get(&#34;url&#34;)
        self.port = kwargs.get(&#34;port&#34;)
        self.conn_type = kwargs.get(&#34;conn&#34;)
        self.conn = None
        self.menu_num = None
        self.menu_text = None
        self.debug = kwargs.get(&#34;debug&#34;, False)

    def initiate_connection(self):
        &#34;&#34;&#34;
        Description
            Shortcut to initialte the connection based on the self.conn_type (local or remote)
        &#34;&#34;&#34;
        self.connect(self.conn_type)

    def connect(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Description:
            Connects to the challenge based on the connection type.
            If the connection type is remote, it connects to the url and port provided.
            If the connection type is local, it starts a process with the file provided.
        &#34;&#34;&#34;
        if self.conn_type == &#34;remote&#34; and self.url and self.port:
            self.conn = pwn.remote(self.url, self.port)
        elif self.conn_type == &#34;local&#34; and self.file:
            self.conn = pwn.process(str(self.challenge_file))

    def recv_menu(self, number=1, display=False, save=False):
        &#34;&#34;&#34;
        Depracated function. Use recv_lines instead.
        &#34;&#34;&#34;
        raise DeprecationWarning(&#34;recv_menu is deprecated. Use recv_lines instead.&#34;)

    def recv_lines(self, number=1, display=False, save=False):
        &#34;&#34;&#34;
        Description:
            Receives the output of the menu based on the number of lines provided.
            If display is True, it prints the output of everything received.
            If save is True, it saves the output in a list and returns it.

        Args:
            number (int, optional): Number of lines to receive . Defaults to 1.
            display (bool, optional): Displayes the lines received. Defaults to False.
            save (bool, optional): Saves the lines received to a list. Defaults to False.

        Returns:
            list: list of the lines received if save is True
        &#34;&#34;&#34;
        if save:
            result = []
        for _ in range(number):
            out = self.conn.recvline()
            if display:
                print(out)
            if save:
                result.append(out)
        if save:
            return result

    def send_menu(
        self, choice, menu_num=None, menu_text=None, display=False, save=False
    ):
        &#34;&#34;&#34;
        Description:
            Gets the menu num either from the class or from the function call and saves it to the class.
            Gets the menu text that the menu is providing, receives until the menu asks for choice and then send out the choice.
            If save is True, it saves the output of the menu in a list and returns it.
            If display is True, it prints the output of everything received.

        Args:
            choice (int or str): Choice to send to the menu
            menu_num (int, optional): Number of options printed in the menu. Defaults to None.
            menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
            display (bool, optional): Variable to print every received line. Defaults to False.
            save (bool, optional): . Defaults to False.
        Returns:
            list: List of output of the menu if save is True
        &#34;&#34;&#34;

        # Sets up the menu options of the class instance
        if menu_num is None and self.menu_num is None:
            raise ValueError(&#34;Menu number not provided&#34;)

        if menu_num:
            self.menu_num = menu_num

        if menu_text is None and self.menu_text is None:
            raise ValueError(&#34;Menu text not provided&#34;)

        if menu_text:
            self.menu_text = menu_text

        return self.recv_send(
            choice,
            lines=self.menu_num,
            text_until=self.menu_text,
            display=display,
            save=save,
        )

    def recv_send(self, text, lines=None, text_until=None, display=False, save=False):
        &#34;&#34;&#34;
        Description:
            Receives lines and sends a response.
            It can receive a number or lines, and/or specific text.
            If save is True, it saves the output of the menu in a list and returns it.
            If display is True, it prints the output of everything received.

        Args:
            choice (int or str): Choice to send to the menu
            menu_num (int, optional): Number of options printed in the menu. Defaults to None.
            menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
            display (bool, optional): Variable to print every received line. Defaults to False.
            save (bool, optional): . Defaults to False.
        Returns:
            list: List of output of the menu if save is True
        &#34;&#34;&#34;
        if save:
            result = []

        if lines is None:
            lines = 0

        out_lines = self.recv_lines(number=self.menu_num, display=display, save=save)

        if save:
            result.extend(out_lines)

        if text_until:
            out_text_until = self.recv_until(text_until)

        if save:
            result.append(out_text_until)

        if display:
            print(out_text_until)

        self.send(text)

        if save:
            return result

    def send(self, text) -&gt; None:
        &#34;&#34;&#34;
        Description:
            Sends the text to the connection after it encodes it.
            Wrapper for self.conn.sendline(str(text).encode())

        Args:
            text (str): Text to send
        &#34;&#34;&#34;
        # Check if the text is str or bytes and encode it
        self.conn.sendline(str(text).encode())

    def recv_until(self, text, *args, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;
        Description:
            Receive data until one of `delims`(text) provided is encountered. It encodes the text before sending it.
            Wrapper for self.conn.recvuntil(text.encode())
            Can also drop the ending if drop is True. If the request is not satisfied before ``timeout`` seconds pass, all data is buffered and an empty string (``&#39;&#39;``) is returned.
        Args:
            text (str): Text to receive until
            *args: Additional arguments to pass to the recv (drop, timeout)
            **kwargs: Additional keyword arguments to pass to the recv
                - drop (bool, optional): Drop the ending.  If :const:`True` it is removed from the end of the return value. Defaults to False.
                - timeout (int, optional): Timeout in seconds. Defaults to default.

        Raises:
            exceptions.EOFError: The connection closed before the request could be satisfied

        Returns:
            A string containing bytes received from the socket,
            or ``&#39;&#39;`` if a timeout occurred while waiting.

        &#34;&#34;&#34;
        return self.conn.recvuntil(text.encode(), *args, **kwargs)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ctfsolver.src.ctfsolver.CTFSolver" href="ctfsolver.html#ctfsolver.src.ctfsolver.CTFSolver">CTFSolver</a></li>
<li><a title="ctfsolver.src.ctfsolver_split.CTFSolver" href="ctfsolver_split.html#ctfsolver.src.ctfsolver_split.CTFSolver">CTFSolver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctfsolver.src.manager_connections.ManagerConnections.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, *args, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Connects to the challenge based on the connection type.
If the connection type is remote, it connects to the url and port provided.
If the connection type is local, it starts a process with the file provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, *args, **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Description:
        Connects to the challenge based on the connection type.
        If the connection type is remote, it connects to the url and port provided.
        If the connection type is local, it starts a process with the file provided.
    &#34;&#34;&#34;
    if self.conn_type == &#34;remote&#34; and self.url and self.port:
        self.conn = pwn.remote(self.url, self.port)
    elif self.conn_type == &#34;local&#34; and self.file:
        self.conn = pwn.process(str(self.challenge_file))</code></pre>
</details>
</dd>
<dt id="ctfsolver.src.manager_connections.ManagerConnections.initiate_connection"><code class="name flex">
<span>def <span class="ident">initiate_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Description
Shortcut to initialte the connection based on the self.conn_type (local or remote)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initiate_connection(self):
    &#34;&#34;&#34;
    Description
        Shortcut to initialte the connection based on the self.conn_type (local or remote)
    &#34;&#34;&#34;
    self.connect(self.conn_type)</code></pre>
</details>
</dd>
<dt id="ctfsolver.src.manager_connections.ManagerConnections.recv_lines"><code class="name flex">
<span>def <span class="ident">recv_lines</span></span>(<span>self, number=1, display=False, save=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Receives the output of the menu based on the number of lines provided.
If display is True, it prints the output of everything received.
If save is True, it saves the output in a list and returns it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of lines to receive . Defaults to 1.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Displayes the lines received. Defaults to False.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Saves the lines received to a list. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of the lines received if save is True</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_lines(self, number=1, display=False, save=False):
    &#34;&#34;&#34;
    Description:
        Receives the output of the menu based on the number of lines provided.
        If display is True, it prints the output of everything received.
        If save is True, it saves the output in a list and returns it.

    Args:
        number (int, optional): Number of lines to receive . Defaults to 1.
        display (bool, optional): Displayes the lines received. Defaults to False.
        save (bool, optional): Saves the lines received to a list. Defaults to False.

    Returns:
        list: list of the lines received if save is True
    &#34;&#34;&#34;
    if save:
        result = []
    for _ in range(number):
        out = self.conn.recvline()
        if display:
            print(out)
        if save:
            result.append(out)
    if save:
        return result</code></pre>
</details>
</dd>
<dt id="ctfsolver.src.manager_connections.ManagerConnections.recv_menu"><code class="name flex">
<span>def <span class="ident">recv_menu</span></span>(<span>self, number=1, display=False, save=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Depracated function. Use recv_lines instead.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_menu(self, number=1, display=False, save=False):
    &#34;&#34;&#34;
    Depracated function. Use recv_lines instead.
    &#34;&#34;&#34;
    raise DeprecationWarning(&#34;recv_menu is deprecated. Use recv_lines instead.&#34;)</code></pre>
</details>
</dd>
<dt id="ctfsolver.src.manager_connections.ManagerConnections.recv_send"><code class="name flex">
<span>def <span class="ident">recv_send</span></span>(<span>self, text, lines=None, text_until=None, display=False, save=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Receives lines and sends a response.
It can receive a number or lines, and/or specific text.
If save is True, it saves the output of the menu in a list and returns it.
If display is True, it prints the output of everything received.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>choice</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>Choice to send to the menu</dd>
<dt><strong><code>menu_num</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of options printed in the menu. Defaults to None.</dd>
<dt><strong><code>menu_text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text that the menu asks before sending your choice. Defaults to None.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Variable to print every received line. Defaults to False.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of output of the menu if save is True</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_send(self, text, lines=None, text_until=None, display=False, save=False):
    &#34;&#34;&#34;
    Description:
        Receives lines and sends a response.
        It can receive a number or lines, and/or specific text.
        If save is True, it saves the output of the menu in a list and returns it.
        If display is True, it prints the output of everything received.

    Args:
        choice (int or str): Choice to send to the menu
        menu_num (int, optional): Number of options printed in the menu. Defaults to None.
        menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
        display (bool, optional): Variable to print every received line. Defaults to False.
        save (bool, optional): . Defaults to False.
    Returns:
        list: List of output of the menu if save is True
    &#34;&#34;&#34;
    if save:
        result = []

    if lines is None:
        lines = 0

    out_lines = self.recv_lines(number=self.menu_num, display=display, save=save)

    if save:
        result.extend(out_lines)

    if text_until:
        out_text_until = self.recv_until(text_until)

    if save:
        result.append(out_text_until)

    if display:
        print(out_text_until)

    self.send(text)

    if save:
        return result</code></pre>
</details>
</dd>
<dt id="ctfsolver.src.manager_connections.ManagerConnections.recv_until"><code class="name flex">
<span>def <span class="ident">recv_until</span></span>(<span>self, text, *args, **kwargs) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Receive data until one of <code>delims</code>(text) provided is encountered. It encodes the text before sending it.
Wrapper for self.conn.recvuntil(text.encode())
Can also drop the ending if drop is True. If the request is not satisfied before <code>timeout</code> seconds pass, all data is buffered and an empty string (<code>''</code>) is returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Text to receive until</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>Additional arguments to pass to the recv (drop, timeout)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments to pass to the recv
- drop (bool, optional): Drop the ending.
If :const:<code>True</code> it is removed from the end of the return value. Defaults to False.
- timeout (int, optional): Timeout in seconds. Defaults to default.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>exceptions.EOFError</code></dt>
<dd>The connection closed before the request could be satisfied</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string containing bytes received from the socket,
or <code>''</code> if a timeout occurred while waiting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_until(self, text, *args, **kwargs) -&gt; bytes:
    &#34;&#34;&#34;
    Description:
        Receive data until one of `delims`(text) provided is encountered. It encodes the text before sending it.
        Wrapper for self.conn.recvuntil(text.encode())
        Can also drop the ending if drop is True. If the request is not satisfied before ``timeout`` seconds pass, all data is buffered and an empty string (``&#39;&#39;``) is returned.
    Args:
        text (str): Text to receive until
        *args: Additional arguments to pass to the recv (drop, timeout)
        **kwargs: Additional keyword arguments to pass to the recv
            - drop (bool, optional): Drop the ending.  If :const:`True` it is removed from the end of the return value. Defaults to False.
            - timeout (int, optional): Timeout in seconds. Defaults to default.

    Raises:
        exceptions.EOFError: The connection closed before the request could be satisfied

    Returns:
        A string containing bytes received from the socket,
        or ``&#39;&#39;`` if a timeout occurred while waiting.

    &#34;&#34;&#34;
    return self.conn.recvuntil(text.encode(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="ctfsolver.src.manager_connections.ManagerConnections.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, text) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Sends the text to the connection after it encodes it.
Wrapper for self.conn.sendline(str(text).encode())</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Text to send</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, text) -&gt; None:
    &#34;&#34;&#34;
    Description:
        Sends the text to the connection after it encodes it.
        Wrapper for self.conn.sendline(str(text).encode())

    Args:
        text (str): Text to send
    &#34;&#34;&#34;
    # Check if the text is str or bytes and encode it
    self.conn.sendline(str(text).encode())</code></pre>
</details>
</dd>
<dt id="ctfsolver.src.manager_connections.ManagerConnections.send_menu"><code class="name flex">
<span>def <span class="ident">send_menu</span></span>(<span>self, choice, menu_num=None, menu_text=None, display=False, save=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="description">Description</h2>
<p>Gets the menu num either from the class or from the function call and saves it to the class.
Gets the menu text that the menu is providing, receives until the menu asks for choice and then send out the choice.
If save is True, it saves the output of the menu in a list and returns it.
If display is True, it prints the output of everything received.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>choice</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>Choice to send to the menu</dd>
<dt><strong><code>menu_num</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of options printed in the menu. Defaults to None.</dd>
<dt><strong><code>menu_text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text that the menu asks before sending your choice. Defaults to None.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Variable to print every received line. Defaults to False.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of output of the menu if save is True</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_menu(
    self, choice, menu_num=None, menu_text=None, display=False, save=False
):
    &#34;&#34;&#34;
    Description:
        Gets the menu num either from the class or from the function call and saves it to the class.
        Gets the menu text that the menu is providing, receives until the menu asks for choice and then send out the choice.
        If save is True, it saves the output of the menu in a list and returns it.
        If display is True, it prints the output of everything received.

    Args:
        choice (int or str): Choice to send to the menu
        menu_num (int, optional): Number of options printed in the menu. Defaults to None.
        menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
        display (bool, optional): Variable to print every received line. Defaults to False.
        save (bool, optional): . Defaults to False.
    Returns:
        list: List of output of the menu if save is True
    &#34;&#34;&#34;

    # Sets up the menu options of the class instance
    if menu_num is None and self.menu_num is None:
        raise ValueError(&#34;Menu number not provided&#34;)

    if menu_num:
        self.menu_num = menu_num

    if menu_text is None and self.menu_text is None:
        raise ValueError(&#34;Menu text not provided&#34;)

    if menu_text:
        self.menu_text = menu_text

    return self.recv_send(
        choice,
        lines=self.menu_num,
        text_until=self.menu_text,
        display=display,
        save=save,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctfsolver.src" href="index.html">ctfsolver.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctfsolver.src.manager_connections.ManagerConnections" href="#ctfsolver.src.manager_connections.ManagerConnections">ManagerConnections</a></code></h4>
<ul class="two-column">
<li><code><a title="ctfsolver.src.manager_connections.ManagerConnections.connect" href="#ctfsolver.src.manager_connections.ManagerConnections.connect">connect</a></code></li>
<li><code><a title="ctfsolver.src.manager_connections.ManagerConnections.initiate_connection" href="#ctfsolver.src.manager_connections.ManagerConnections.initiate_connection">initiate_connection</a></code></li>
<li><code><a title="ctfsolver.src.manager_connections.ManagerConnections.recv_lines" href="#ctfsolver.src.manager_connections.ManagerConnections.recv_lines">recv_lines</a></code></li>
<li><code><a title="ctfsolver.src.manager_connections.ManagerConnections.recv_menu" href="#ctfsolver.src.manager_connections.ManagerConnections.recv_menu">recv_menu</a></code></li>
<li><code><a title="ctfsolver.src.manager_connections.ManagerConnections.recv_send" href="#ctfsolver.src.manager_connections.ManagerConnections.recv_send">recv_send</a></code></li>
<li><code><a title="ctfsolver.src.manager_connections.ManagerConnections.recv_until" href="#ctfsolver.src.manager_connections.ManagerConnections.recv_until">recv_until</a></code></li>
<li><code><a title="ctfsolver.src.manager_connections.ManagerConnections.send" href="#ctfsolver.src.manager_connections.ManagerConnections.send">send</a></code></li>
<li><code><a title="ctfsolver.src.manager_connections.ManagerConnections.send_menu" href="#ctfsolver.src.manager_connections.ManagerConnections.send_menu">send_menu</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.4</a>.</p>
</footer>
</body>
</html>
