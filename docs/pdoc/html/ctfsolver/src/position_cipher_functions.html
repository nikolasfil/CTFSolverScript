<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>ctfsolver.src.position_cipher_functions API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctfsolver.src.position_cipher_functions</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher"><code class="flex name class">
<span>class <span class="ident">PositionCipher</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PositionCipher:

    def load_lyrics(self):

        files = [
            &#34;lyrics_partial.txt&#34;,
            &#34;lyrics.txt&#34;,
            &#34;greek_lyrics.txt&#34;,
            &#34;genius_lyrics.txt&#34;,
        ]

        with open(self.folfil(&#34;data&#34;, files[1]), &#34;r&#34;) as f:
            lyrics = f.read().strip()
        return lyrics

    def dictionary_analysis(self, lyrics):
        d = defaultdict(list)
        for i, c in enumerate(lyrics):
            d[c].append(i)
        return d

    def print_dictionary(self, d):
        sorted_items = sorted(d.items(), key=lambda x: x[0])
        for key, value in sorted_items:
            print(f&#34;{key}: {value}&#34;)

    def lyric_transpose(self, lyrics, offset, wrap=True):
        if offset &gt; len(lyrics):
            offset = offset % len(lyrics)

        result = lyrics[offset:]
        if wrap:
            result += lyrics[:offset]

        return result

    def lyric_transformation(self, lyrics):

        punctuation_used = set()
        for c in lyrics:
            if c not in ascii_letters + digits + &#34; &#34;:
                punctuation_used.add(c)

        lyrics_only_letters = &#34;&#34;.join([c for c in lyrics if c.isalnum()])
        lyrics_with_spaces = lyrics.replace(&#34;\n&#34;, &#34; &#34;)
        lyrics_without_punctuation = lyrics_with_spaces.replace(&#34;&#39;&#34;, &#34;&#34;).replace(
            &#34;,&#34;, &#34;&#34;
        )
        return lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation

    def lyrics_all(self):
        &#34;&#34;&#34;
        Description:
            This function generates all possible combinations of lyrics transformations
            based on the provided replace_combos and control_combos.
            It uses itertools.product to create combinations of the specified number
            of transformations, allowing for flexible lyric manipulation.
        Returns:
            list: A list of transformed lyrics combinations.
        &#34;&#34;&#34;
        lyrics = self.load_lyrics()
        control_combos = self.creating_control_combos(
            start=0, end=1, number=len(self.replace_combos)
        )
        return [
            self.lyrics_transformation(lyrics, self.replace_combos, control)
            for control in control_combos
        ]

    def creating_control_combos(self, start=0, end=1, number=8):
        if start &gt;= end:
            raise ValueError(&#34;Start must be less than end.&#34;)
        if number &lt; 1:
            raise ValueError(&#34;Number of combinations must be at least 1.&#34;)
        return list(itertools.product(range(start, end + 1), repeat=number))

    def lyrics_transformation(self, lyrics, replace_combos, control_combos=None):
        if control_combos is None:
            return lyrics

        for control, combo in zip(control_combos, replace_combos):
            if control:
                if len(combo[0]) &gt; 1:
                    lyrics = lyrics.replace(*combo[0]).replace(*combo[1])
                else:
                    lyrics = lyrics.replace(*combo)
        return lyrics

    def brute_transpose_find_flag(
        self,
        lyrics: str,
        partial_flag: str,
        keys: list,
        verbose: bool = False,
        wrap: bool = True,
    ):
        &#34;&#34;&#34;
        Description:
            For the lyrics given

        Args:
            lyrics (str): Lyrics given
            partial_flag (str): partial flag to look
            verbose (bool, optional): _description_. Defaults to False.

        Returns:
            str: possible flag
        &#34;&#34;&#34;

        for i in range(len(lyrics)):
            transposed = self.lyric_transpose(lyrics, i, wrap=wrap)
            if verbose and i % 100 == 0:
                print(f&#34;Trying offset: {i}&#34;)
            temp_flag = self.position_cipher(transposed, keys)
            if &#34;ecsc&#34; in temp_flag.lower() or self.check_for_rot(
                temp_flag, partial_flag
            ):
                print(f&#34;Found flag: {temp_flag} - Offset: {i}&#34;)
                return temp_flag

    def check_for_rot(self, text, partial=&#34;ecsc&#34;):
        &#34;&#34;&#34;
        Description:
            Checks if the text is a rotation of &#34;ecsc&#34;.
            This function checks if the first four characters of the text
            can be rearranged to form the string &#34;ecsc&#34;. It does this by
            comparing the ASCII values of the characters in the text with
            the ASCII values of the characters in &#34;ecsc&#34;. If the conditions
            are met, it returns True, indicating that the text is a rotation
            of &#34;ecsc&#34;. Otherwise, it returns False.
            This function is useful for identifying specific patterns in the text
            that match the structure of &#34;ecsc&#34;, which could be relevant in certain

            Challenge_specific
        Args:
            text (_type_): _description_

            
            
        Returns:
            _type_: _description_
        &#34;&#34;&#34;

        if len(partial) != 4:
            raise ValueError(
                &#34;Partial must be exactly 4 characters long. Challenge_specific&#34;
            )
        text = text.lower()

        check1 = (ord(partial[0]) - ord(partial[1])) == (ord(text[0]) - ord(text[1]))
        check2 = (ord(partial[2]) - ord(partial[1])) == (ord(text[2]) - ord(text[1]))
        check3 = ord(text[3]) == ord(text[1])

        return check1 and check2 and check3

    def position_cipher(self, text: str, keys: list):
        &#34;&#34;&#34;
        Description:
            This function takes a text and a list of keys, and returns a new string
            where each character in the text is replaced by the character at the
            corresponding index in the keys list. If the index exceeds the length of
            the text, it wraps around using modulo operation.
        Args:
            text (str): The input text to be transformed.
            keys (list): A list of integers representing the positions in the text.
        Returns:
            str: A new string formed by replacing characters in the text based on the keys.
        &#34;&#34;&#34;

        return &#34;&#34;.join(text[i % len(text)] for i in keys)

    def bruteforce_all_lyrics(
        self,
        all_lyrics: list,
        partial_flag: str,
        keys: list,
        verbose: bool = False,
        wrap: bool = True,
    ):
        results = []
        for lyric_i, lyrics in enumerate(all_lyrics):
            if verbose:
                print(f&#34;Processing lyrics {lyric_i + 1}/{len(all_lyrics)}&#34;)
            result = self.brute_transpose_find_flag(
                lyrics=lyrics,
                partial_flag=partial_flag,
                keys=keys,
                verbose=verbose,
                wrap=wrap,
            )
            if result:
                results.append([lyric_i, result])

        return results

    def init_some_values(self):
        self.key = [
            7,
            58,
            391,
            58,
            129,
            80,
            537,
            80,
            389,
            33,
            80,
            107,
            522,
            391,
            389,
            148,
            386,
            522,
            389,
            58,
            240,
            240,
            107,
            1,
        ]

        self.replace_combos = [
            (&#34; &#34;, &#34;&#34;),
            (&#34;,&#34;, &#34; &#34;),
            ((&#34;,&#34;, &#34; &#34;), (&#34;&#39;&#34;, &#34; &#34;)),
            ((&#34;,&#34;, &#34;&#34;), (&#34;&#39;&#34;, &#34;&#34;)),
            (&#34;,&#34;, &#34;&#34;),
            (&#34;&#39;&#34;, &#34; &#34;),
            (&#34;&#39;&#34;, &#34;&#34;),
            (&#34;\n&#34;, &#34; &#34;),
            (&#34;\n&#34;, &#34;&#34;),
        ]

    def another_attempt(self):

        lyrics = self.load_lyrics()

        lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation = (
            self.lyric_transformation(lyrics)
        )

        print(lyrics_only_letters)
        print(lyrics_with_spaces)
        print(lyrics_without_punctuation)

        # flag = self.bruteforce(lyrics, self.key)
        # print(flag)
        # flag = self.bruteforce(lyrics_only_letters, self.key)
        # print(flag)
        flag = self.brute_transpose_find_flag(lyrics_with_spaces, self.key)
        print(flag)
        flag = self.brute_transpose_find_flag(lyrics_without_punctuation, self.key)
        print(flag)

    def main(self):

        self.init_some_values()

        all_lyrics = self.lyrics_all()

        partial_flag = &#34;ecsc&#34;

        results = self.bruteforce_all_lyrics(
            all_lyrics, partial_flag, keys=self.key, verbose=True, wrap=True
        )
        if results:
            for lyric_i, result in results:
                print(f&#34;Lyric {lyric_i + 1}: {result}&#34;)
        else:
            print(&#34;No results found.&#34;)</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.another_attempt"><code class="name flex">
<span>def <span class="ident">another_attempt</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def another_attempt(self):

    lyrics = self.load_lyrics()

    lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation = (
        self.lyric_transformation(lyrics)
    )

    print(lyrics_only_letters)
    print(lyrics_with_spaces)
    print(lyrics_without_punctuation)

    # flag = self.bruteforce(lyrics, self.key)
    # print(flag)
    # flag = self.bruteforce(lyrics_only_letters, self.key)
    # print(flag)
    flag = self.brute_transpose_find_flag(lyrics_with_spaces, self.key)
    print(flag)
    flag = self.brute_transpose_find_flag(lyrics_without_punctuation, self.key)
    print(flag)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.brute_transpose_find_flag"><code class="name flex">
<span>def <span class="ident">brute_transpose_find_flag</span></span>(<span>self,<br>lyrics: str,<br>partial_flag: str,<br>keys: list,<br>verbose: bool = False,<br>wrap: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def brute_transpose_find_flag(
    self,
    lyrics: str,
    partial_flag: str,
    keys: list,
    verbose: bool = False,
    wrap: bool = True,
):
    &#34;&#34;&#34;
    Description:
        For the lyrics given

    Args:
        lyrics (str): Lyrics given
        partial_flag (str): partial flag to look
        verbose (bool, optional): _description_. Defaults to False.

    Returns:
        str: possible flag
    &#34;&#34;&#34;

    for i in range(len(lyrics)):
        transposed = self.lyric_transpose(lyrics, i, wrap=wrap)
        if verbose and i % 100 == 0:
            print(f&#34;Trying offset: {i}&#34;)
        temp_flag = self.position_cipher(transposed, keys)
        if &#34;ecsc&#34; in temp_flag.lower() or self.check_for_rot(
            temp_flag, partial_flag
        ):
            print(f&#34;Found flag: {temp_flag} - Offset: {i}&#34;)
            return temp_flag</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>For the lyrics given</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lyrics</code></strong> :&ensp;<code>str</code></dt>
<dd>Lyrics given</dd>
<dt><strong><code>partial_flag</code></strong> :&ensp;<code>str</code></dt>
<dd>partial flag to look</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd><em>description</em>. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>possible flag</dd>
</dl></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.bruteforce_all_lyrics"><code class="name flex">
<span>def <span class="ident">bruteforce_all_lyrics</span></span>(<span>self,<br>all_lyrics: list,<br>partial_flag: str,<br>keys: list,<br>verbose: bool = False,<br>wrap: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bruteforce_all_lyrics(
    self,
    all_lyrics: list,
    partial_flag: str,
    keys: list,
    verbose: bool = False,
    wrap: bool = True,
):
    results = []
    for lyric_i, lyrics in enumerate(all_lyrics):
        if verbose:
            print(f&#34;Processing lyrics {lyric_i + 1}/{len(all_lyrics)}&#34;)
        result = self.brute_transpose_find_flag(
            lyrics=lyrics,
            partial_flag=partial_flag,
            keys=keys,
            verbose=verbose,
            wrap=wrap,
        )
        if result:
            results.append([lyric_i, result])

    return results</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.check_for_rot"><code class="name flex">
<span>def <span class="ident">check_for_rot</span></span>(<span>self, text, partial='ecsc')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_rot(self, text, partial=&#34;ecsc&#34;):
    &#34;&#34;&#34;
    Description:
        Checks if the text is a rotation of &#34;ecsc&#34;.
        This function checks if the first four characters of the text
        can be rearranged to form the string &#34;ecsc&#34;. It does this by
        comparing the ASCII values of the characters in the text with
        the ASCII values of the characters in &#34;ecsc&#34;. If the conditions
        are met, it returns True, indicating that the text is a rotation
        of &#34;ecsc&#34;. Otherwise, it returns False.
        This function is useful for identifying specific patterns in the text
        that match the structure of &#34;ecsc&#34;, which could be relevant in certain

        Challenge_specific
    Args:
        text (_type_): _description_

        
        
    Returns:
        _type_: _description_
    &#34;&#34;&#34;

    if len(partial) != 4:
        raise ValueError(
            &#34;Partial must be exactly 4 characters long. Challenge_specific&#34;
        )
    text = text.lower()

    check1 = (ord(partial[0]) - ord(partial[1])) == (ord(text[0]) - ord(text[1]))
    check2 = (ord(partial[2]) - ord(partial[1])) == (ord(text[2]) - ord(text[1]))
    check3 = ord(text[3]) == ord(text[1])

    return check1 and check2 and check3</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Checks if the text is a rotation of "ecsc".
This function checks if the first four characters of the text
can be rearranged to form the string "ecsc". It does this by
comparing the ASCII values of the characters in the text with
the ASCII values of the characters in "ecsc". If the conditions
are met, it returns True, indicating that the text is a rotation
of "ecsc". Otherwise, it returns False.
This function is useful for identifying specific patterns in the text
that match the structure of "ecsc", which could be relevant in certain</p>
<p>Challenge_specific</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.creating_control_combos"><code class="name flex">
<span>def <span class="ident">creating_control_combos</span></span>(<span>self, start=0, end=1, number=8)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def creating_control_combos(self, start=0, end=1, number=8):
    if start &gt;= end:
        raise ValueError(&#34;Start must be less than end.&#34;)
    if number &lt; 1:
        raise ValueError(&#34;Number of combinations must be at least 1.&#34;)
    return list(itertools.product(range(start, end + 1), repeat=number))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.dictionary_analysis"><code class="name flex">
<span>def <span class="ident">dictionary_analysis</span></span>(<span>self, lyrics)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dictionary_analysis(self, lyrics):
    d = defaultdict(list)
    for i, c in enumerate(lyrics):
        d[c].append(i)
    return d</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.init_some_values"><code class="name flex">
<span>def <span class="ident">init_some_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_some_values(self):
    self.key = [
        7,
        58,
        391,
        58,
        129,
        80,
        537,
        80,
        389,
        33,
        80,
        107,
        522,
        391,
        389,
        148,
        386,
        522,
        389,
        58,
        240,
        240,
        107,
        1,
    ]

    self.replace_combos = [
        (&#34; &#34;, &#34;&#34;),
        (&#34;,&#34;, &#34; &#34;),
        ((&#34;,&#34;, &#34; &#34;), (&#34;&#39;&#34;, &#34; &#34;)),
        ((&#34;,&#34;, &#34;&#34;), (&#34;&#39;&#34;, &#34;&#34;)),
        (&#34;,&#34;, &#34;&#34;),
        (&#34;&#39;&#34;, &#34; &#34;),
        (&#34;&#39;&#34;, &#34;&#34;),
        (&#34;\n&#34;, &#34; &#34;),
        (&#34;\n&#34;, &#34;&#34;),
    ]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.load_lyrics"><code class="name flex">
<span>def <span class="ident">load_lyrics</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_lyrics(self):

    files = [
        &#34;lyrics_partial.txt&#34;,
        &#34;lyrics.txt&#34;,
        &#34;greek_lyrics.txt&#34;,
        &#34;genius_lyrics.txt&#34;,
    ]

    with open(self.folfil(&#34;data&#34;, files[1]), &#34;r&#34;) as f:
        lyrics = f.read().strip()
    return lyrics</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.lyric_transformation"><code class="name flex">
<span>def <span class="ident">lyric_transformation</span></span>(<span>self, lyrics)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lyric_transformation(self, lyrics):

    punctuation_used = set()
    for c in lyrics:
        if c not in ascii_letters + digits + &#34; &#34;:
            punctuation_used.add(c)

    lyrics_only_letters = &#34;&#34;.join([c for c in lyrics if c.isalnum()])
    lyrics_with_spaces = lyrics.replace(&#34;\n&#34;, &#34; &#34;)
    lyrics_without_punctuation = lyrics_with_spaces.replace(&#34;&#39;&#34;, &#34;&#34;).replace(
        &#34;,&#34;, &#34;&#34;
    )
    return lyrics_only_letters, lyrics_with_spaces, lyrics_without_punctuation</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.lyric_transpose"><code class="name flex">
<span>def <span class="ident">lyric_transpose</span></span>(<span>self, lyrics, offset, wrap=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lyric_transpose(self, lyrics, offset, wrap=True):
    if offset &gt; len(lyrics):
        offset = offset % len(lyrics)

    result = lyrics[offset:]
    if wrap:
        result += lyrics[:offset]

    return result</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.lyrics_all"><code class="name flex">
<span>def <span class="ident">lyrics_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lyrics_all(self):
    &#34;&#34;&#34;
    Description:
        This function generates all possible combinations of lyrics transformations
        based on the provided replace_combos and control_combos.
        It uses itertools.product to create combinations of the specified number
        of transformations, allowing for flexible lyric manipulation.
    Returns:
        list: A list of transformed lyrics combinations.
    &#34;&#34;&#34;
    lyrics = self.load_lyrics()
    control_combos = self.creating_control_combos(
        start=0, end=1, number=len(self.replace_combos)
    )
    return [
        self.lyrics_transformation(lyrics, self.replace_combos, control)
        for control in control_combos
    ]</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>This function generates all possible combinations of lyrics transformations
based on the provided replace_combos and control_combos.
It uses itertools.product to create combinations of the specified number
of transformations, allowing for flexible lyric manipulation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of transformed lyrics combinations.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.lyrics_transformation"><code class="name flex">
<span>def <span class="ident">lyrics_transformation</span></span>(<span>self, lyrics, replace_combos, control_combos=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lyrics_transformation(self, lyrics, replace_combos, control_combos=None):
    if control_combos is None:
        return lyrics

    for control, combo in zip(control_combos, replace_combos):
        if control:
            if len(combo[0]) &gt; 1:
                lyrics = lyrics.replace(*combo[0]).replace(*combo[1])
            else:
                lyrics = lyrics.replace(*combo)
    return lyrics</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self):

    self.init_some_values()

    all_lyrics = self.lyrics_all()

    partial_flag = &#34;ecsc&#34;

    results = self.bruteforce_all_lyrics(
        all_lyrics, partial_flag, keys=self.key, verbose=True, wrap=True
    )
    if results:
        for lyric_i, result in results:
            print(f&#34;Lyric {lyric_i + 1}: {result}&#34;)
    else:
        print(&#34;No results found.&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.position_cipher"><code class="name flex">
<span>def <span class="ident">position_cipher</span></span>(<span>self, text: str, keys: list)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def position_cipher(self, text: str, keys: list):
    &#34;&#34;&#34;
    Description:
        This function takes a text and a list of keys, and returns a new string
        where each character in the text is replaced by the character at the
        corresponding index in the keys list. If the index exceeds the length of
        the text, it wraps around using modulo operation.
    Args:
        text (str): The input text to be transformed.
        keys (list): A list of integers representing the positions in the text.
    Returns:
        str: A new string formed by replacing characters in the text based on the keys.
    &#34;&#34;&#34;

    return &#34;&#34;.join(text[i % len(text)] for i in keys)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>This function takes a text and a list of keys, and returns a new string
where each character in the text is replaced by the character at the
corresponding index in the keys list. If the index exceeds the length of
the text, it wraps around using modulo operation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The input text to be transformed.</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>list</code></dt>
<dd>A list of integers representing the positions in the text.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A new string formed by replacing characters in the text based on the keys.</dd>
</dl></div>
</dd>
<dt id="ctfsolver.src.position_cipher_functions.PositionCipher.print_dictionary"><code class="name flex">
<span>def <span class="ident">print_dictionary</span></span>(<span>self, d)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_dictionary(self, d):
    sorted_items = sorted(d.items(), key=lambda x: x[0])
    for key, value in sorted_items:
        print(f&#34;{key}: {value}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctfsolver.src" href="index.html">ctfsolver.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher" href="#ctfsolver.src.position_cipher_functions.PositionCipher">PositionCipher</a></code></h4>
<ul class="">
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.another_attempt" href="#ctfsolver.src.position_cipher_functions.PositionCipher.another_attempt">another_attempt</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.brute_transpose_find_flag" href="#ctfsolver.src.position_cipher_functions.PositionCipher.brute_transpose_find_flag">brute_transpose_find_flag</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.bruteforce_all_lyrics" href="#ctfsolver.src.position_cipher_functions.PositionCipher.bruteforce_all_lyrics">bruteforce_all_lyrics</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.check_for_rot" href="#ctfsolver.src.position_cipher_functions.PositionCipher.check_for_rot">check_for_rot</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.creating_control_combos" href="#ctfsolver.src.position_cipher_functions.PositionCipher.creating_control_combos">creating_control_combos</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.dictionary_analysis" href="#ctfsolver.src.position_cipher_functions.PositionCipher.dictionary_analysis">dictionary_analysis</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.init_some_values" href="#ctfsolver.src.position_cipher_functions.PositionCipher.init_some_values">init_some_values</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.load_lyrics" href="#ctfsolver.src.position_cipher_functions.PositionCipher.load_lyrics">load_lyrics</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.lyric_transformation" href="#ctfsolver.src.position_cipher_functions.PositionCipher.lyric_transformation">lyric_transformation</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.lyric_transpose" href="#ctfsolver.src.position_cipher_functions.PositionCipher.lyric_transpose">lyric_transpose</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.lyrics_all" href="#ctfsolver.src.position_cipher_functions.PositionCipher.lyrics_all">lyrics_all</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.lyrics_transformation" href="#ctfsolver.src.position_cipher_functions.PositionCipher.lyrics_transformation">lyrics_transformation</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.main" href="#ctfsolver.src.position_cipher_functions.PositionCipher.main">main</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.position_cipher" href="#ctfsolver.src.position_cipher_functions.PositionCipher.position_cipher">position_cipher</a></code></li>
<li><code><a title="ctfsolver.src.position_cipher_functions.PositionCipher.print_dictionary" href="#ctfsolver.src.position_cipher_functions.PositionCipher.print_dictionary">print_dictionary</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
