<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>ctfsolver.managers.manager_connections API documentation</title>
<meta name="description" content="manager_connections.py â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctfsolver.managers.manager_connections</code></h1>
</header>
<section id="section-intro">
<p>manager_connections.py</p>
<p>This module provides the ManagerConnections class for managing connections to CTF challenges,
supporting both local and remote connection types using the pwntools library.</p>
<h2 id="classes">Classes</h2>
<p>ManagerConnections: Handles connection setup, interaction, and communication with CTF challenges.</p>
<p>Typical usage example:
manager = ManagerConnections(url="example.com", port=1337, conn="remote")
manager.initiate_connection()
output = manager.recv_lines(number=3, display=True, save=True)
manager.send_menu(choice=1, menu_num=3, menu_text="Your choice:")</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>pwn</code></strong> :&ensp;<code>module</code></dt>
<dd>Reference to the pwntools library.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>Remote URL for connection.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>Remote port for connection.</dd>
<dt><strong><code>conn_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of connection ("local" or "remote").</dd>
<dt><strong><code>conn</code></strong></dt>
<dd>Active connection object.</dd>
<dt><strong><code>menu_num</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of menu options.</dd>
<dt><strong><code>menu_text</code></strong> :&ensp;<code>str</code></dt>
<dd>Text prompt for menu selection.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>Debug mode flag.</dd>
<dt><strong><code>ValueError</code></strong></dt>
<dd>If required menu parameters are not provided.</dd>
<dt><strong><code>DeprecationWarning</code></strong></dt>
<dd>If deprecated methods are used.</dd>
<dt><strong><code>EOFError</code></strong></dt>
<dd>If the connection closes unexpectedly during data reception.</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctfsolver.managers.manager_connections.ManagerConnections"><code class="flex name class">
<span>class <span class="ident">ManagerConnections</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ManagerConnections:
    &#34;&#34;&#34;
    Manages connections to CTF challenges, supporting both local and remote modes.
    This class provides methods to initiate and manage connections to CTF challenges,
    either by spawning a local process or connecting to a remote host. It also offers
    utilities for interacting with typical menu-driven CTF binaries, including sending
    choices, receiving lines, and handling menu prompts.
    Attributes:
        pwn: The pwntools module or object used for process and remote connections.
        url (str): The remote host URL or IP address.
        port (int): The remote host port.
        conn_type (str): Type of connection, either &#39;local&#39; or &#39;remote&#39;.
        conn: The active connection object (process or remote).
        menu_num (int): Number of menu options expected.
        menu_text (str): Text prompt expected before sending a menu choice.
        debug (bool): Flag to enable debug mode.
    Methods:
        __init__(*args, **kwargs):
            Initializes the ManagerConnections instance with connection parameters.
        initiate_connection(*args, **kwargs):
            Initiates the connection based on the specified connection type.
        connect(*args, **kwargs):
            Connects to the challenge locally or remotely, depending on conn_type.
        recv_menu(number=1, display=False, save=False):
            Deprecated. Use recv_lines instead.
        recv_lines(number=1, display=False, save=False):
            Receives a specified number of lines from the connection.
        send_menu(choice, menu_num=None, menu_text=None, display=False, save=False):
            Sends a choice to a menu-driven binary, handling menu prompts and output.
        recv_send(text, lines=None, text_until=None, display=False, save=False):
            Receives lines and/or text until a prompt, then sends a response.
        send(text, encode=True):
            Sends text to the connection, optionally encoding it.
        recv_until(text, **kwargs):
            Receives data until a specified delimiter is encountered.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Initializes the connection manager with the provided arguments.
        Args:
            *args: Variable length argument list.
            **kwargs: Arbitrary keyword arguments.
                url (str, optional): The URL for the connection.
                port (int, optional): The port number for the connection.
                conn (str, optional): The type of connection.
                debug (bool, optional): Enables debug mode. Defaults to False.
        Attributes:
            pwn: Placeholder for future use.
            url (str): The URL for the connection.
            port (int): The port number for the connection.
            conn_type (str): The type of connection.
            conn: The connection object (initialized as None).
            menu_num: The menu number (initialized as None).
            menu_text: The menu text (initialized as None).
            debug (bool): Debug mode status.
        &#34;&#34;&#34;

        # This will change in the future
        self.pwn = pwn

        self.url = kwargs.get(&#34;url&#34;)
        self.port = kwargs.get(&#34;port&#34;)
        self.conn_type = kwargs.get(&#34;conn&#34;)
        self.conn = None
        self.menu_num = None
        self.menu_text = None
        self.debug = kwargs.get(&#34;debug&#34;, False)

    def initiate_connection(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Initiates a connection using the specified connection type and parameters.
        Args:
            *args: Variable length argument list to be passed to the connection method.
            **kwargs: Arbitrary keyword arguments to be passed to the connection method.
        Returns:
            None
        &#34;&#34;&#34;

        self.connect(self.conn_type, *args, **kwargs)

    def connect(self, *args, **kwargs) -&gt; None:
        &#34;&#34;&#34;
        Description:
            Connects to the challenge based on the connection type.
            If the connection type is remote, it connects to the url and port provided.
            If the connection type is local, it starts a process with the file provided.


            local:
                kwargs :
                    argv: Any | None = None,
                    shell: bool = False,
                    executable: Any | None = None,
                    cwd: Any | None = None,
                    env: Any | None = None,
                    ignore_environ: Any | None = None,
                    stdin: int = PIPE,
                    stdout: PTY | int = PTY if not IS_WINDOWS else PIPE,
                    stderr: int = STDOUT,
                    close_fds: bool = True,
                    preexec_fn: Any = lambda : None,
                    raw: bool = True,
                    aslr: Any | None = None,
                    setuid: Any | None = None,
                    where: str = &#39;local&#39;,
                    display: Any | None = None,
                    alarm: Any | None = None,
                    creationflags: int = 0

        &#34;&#34;&#34;
        if self.conn_type == &#34;remote&#34; and self.url and self.port:
            self.conn = self.pwn.remote(self.url, self.port)
        elif self.conn_type == &#34;local&#34; and self.file:
            self.conn = self.pwn.process(str(self.challenge_file), **kwargs)

    def recv_menu(self, number=1, display=False, save=False):
        raise DeprecationWarning(&#34;Depracated function. Use recv_lines instead.&#34;)

    def recv_lines(self, number=1, display=False, save=False):
        &#34;&#34;&#34;
        Description:
            Receives the output of the menu based on the number of lines provided.
            If display is True, it prints the output of everything received.
            If save is True, it saves the output in a list and returns it.

        Args:
            number (int, optional): Number of lines to receive . Defaults to 1.
            display (bool, optional): Displayes the lines received. Defaults to False.
            save (bool, optional): Saves the lines received to a list. Defaults to False.

        Returns:
            list: list of the lines received if save is True
        &#34;&#34;&#34;
        if save:
            result = []
        for _ in range(number):
            out = self.conn.recvline()
            if display:
                print(out)
            if save:
                result.append(out)
        if save:
            return result

    def send_menu(
        self, choice, menu_num=None, menu_text=None, display=False, save=False
    ):
        &#34;&#34;&#34;
        Description:
            Gets the menu num either from the class or from the function call and saves it to the class.
            Gets the menu text that the menu is providing, receives until the menu asks for choice and then send out the choice.
            If save is True, it saves the output of the menu in a list and returns it.
            If display is True, it prints the output of everything received.

        Args:
            choice (int or str): Choice to send to the menu
            menu_num (int, optional): Number of options printed in the menu. Defaults to None.
            menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
            display (bool, optional): Variable to print every received line. Defaults to False.
            save (bool, optional): . Defaults to False.
        Returns:
            list: List of output of the menu if save is True
        &#34;&#34;&#34;

        # Sets up the menu options of the class instance
        if menu_num is None and self.menu_num is None:
            raise ValueError(&#34;Menu number not provided&#34;)

        if menu_num:
            self.menu_num = menu_num

        if menu_text is None and self.menu_text is None:
            raise ValueError(&#34;Menu text not provided&#34;)

        if menu_text:
            self.menu_text = menu_text

        return self.recv_send(
            choice,
            lines=self.menu_num,
            text_until=self.menu_text,
            display=display,
            save=save,
        )

    def recv_send(self, text, lines=None, text_until=None, display=False, save=False):
        &#34;&#34;&#34;
        Description:
            Receives lines and sends a response.
            It can receive a number or lines, and/or specific text.
            If save is True, it saves the output of the menu in a list and returns it.
            If display is True, it prints the output of everything received.

        Args:
            choice (int or str): Choice to send to the menu
            menu_num (int, optional): Number of options printed in the menu. Defaults to None.
            menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
            display (bool, optional): Variable to print every received line. Defaults to False.
            save (bool, optional): . Defaults to False.
        Returns:
            list: List of output of the menu if save is True
        &#34;&#34;&#34;
        if save:
            result = []

        if lines is None:
            lines = 0

        out_lines = self.recv_lines(number=lines, display=display, save=save)

        if save:
            result.extend(out_lines)

        if text_until:
            out_text_until = self.recv_until(text=text_until)

        if save:
            result.append(out_text_until)

        if display:
            print(out_text_until)

        self.send(text)

        if save:
            return result

    def send(self, text, encode=True) -&gt; None:
        &#34;&#34;&#34;
        Description:
            Sends the text to the connection after it encodes it.
            Wrapper for self.conn.sendline(str(text).encode())

        Args:
            text (str): Text to send
        &#34;&#34;&#34;
        # Check if the text is str or bytes and encode it
        if encode:
            self.conn.sendline(str(text).encode())
        else:
            self.conn.sendline(text)

    def recv_until(self, text, **kwargs) -&gt; bytes:
        &#34;&#34;&#34;
        Description:
            Receive data until one of `delims`(text) provided is encountered. It encodes the text before sending it.
            Wrapper for self.conn.recvuntil(text.encode())
            Can also drop the ending if drop is True. If the request is not satisfied before ``timeout`` seconds pass, all data is buffered and an empty string (``&#39;&#39;``) is returned.
        Args:
            text (str): Text to receive until
            **kwargs: Additional keyword arguments to pass to the recv
                - drop (bool, optional): Drop the ending.  If :const:`True` it is removed from the end of the return value. Defaults to False.
                - timeout (int, optional): Timeout in seconds. Defaults to default.

        Raises:
            exceptions.EOFError: The connection closed before the request could be satisfied

        Returns:
            A string containing bytes received from the socket,
            or ``&#39;&#39;`` if a timeout occurred while waiting.

        &#34;&#34;&#34;

        # Handles the connection closed before the request could be satisfied
        try:
            return self.conn.recvuntil(text.encode(), **kwargs)
        except EOFError:
            print(&#34;Connection closed before the request could be satisfied&#34;)
            return b&#34;&#34;</code></pre>
</details>
<div class="desc"><p>Manages connections to CTF challenges, supporting both local and remote modes.
This class provides methods to initiate and manage connections to CTF challenges,
either by spawning a local process or connecting to a remote host. It also offers
utilities for interacting with typical menu-driven CTF binaries, including sending
choices, receiving lines, and handling menu prompts.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>pwn</code></strong></dt>
<dd>The pwntools module or object used for process and remote connections.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The remote host URL or IP address.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The remote host port.</dd>
<dt><strong><code>conn_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of connection, either 'local' or 'remote'.</dd>
<dt><strong><code>conn</code></strong></dt>
<dd>The active connection object (process or remote).</dd>
<dt><strong><code>menu_num</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of menu options expected.</dd>
<dt><strong><code>menu_text</code></strong> :&ensp;<code>str</code></dt>
<dd>Text prompt expected before sending a menu choice.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to enable debug mode.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p><strong>init</strong>(<em>args, </em><em>kwargs):
Initializes the ManagerConnections instance with connection parameters.
initiate_connection(</em>args, <strong>kwargs):
Initiates the connection based on the specified connection type.
connect(*args, </strong>kwargs):
Connects to the challenge locally or remotely, depending on conn_type.
recv_menu(number=1, display=False, save=False):
Deprecated. Use recv_lines instead.
recv_lines(number=1, display=False, save=False):
Receives a specified number of lines from the connection.
send_menu(choice, menu_num=None, menu_text=None, display=False, save=False):
Sends a choice to a menu-driven binary, handling menu prompts and output.
recv_send(text, lines=None, text_until=None, display=False, save=False):
Receives lines and/or text until a prompt, then sends a response.
send(text, encode=True):
Sends text to the connection, optionally encoding it.
recv_until(text, **kwargs):
Receives data until a specified delimiter is encountered.</p>
<p>Initializes the connection manager with the provided arguments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Variable length argument list.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Arbitrary keyword arguments.
url (str, optional): The URL for the connection.
port (int, optional): The port number for the connection.
conn (str, optional): The type of connection.
debug (bool, optional): Enables debug mode. Defaults to False.</dd>
</dl>
<h2 id="attributes_1">Attributes</h2>
<dl>
<dt><strong><code>pwn</code></strong></dt>
<dd>Placeholder for future use.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The URL for the connection.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code></dt>
<dd>The port number for the connection.</dd>
<dt><strong><code>conn_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The type of connection.</dd>
<dt><strong><code>conn</code></strong></dt>
<dd>The connection object (initialized as None).</dd>
<dt><strong><code>menu_num</code></strong></dt>
<dd>The menu number (initialized as None).</dd>
<dt><strong><code>menu_text</code></strong></dt>
<dd>The menu text (initialized as None).</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>Debug mode status.</dd>
</dl></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ctfsolver.src.ctfsolver.CTFSolver" href="../src/ctfsolver.html#ctfsolver.src.ctfsolver.CTFSolver">CTFSolver</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctfsolver.managers.manager_connections.ManagerConnections.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self, *args, **kwargs) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self, *args, **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Description:
        Connects to the challenge based on the connection type.
        If the connection type is remote, it connects to the url and port provided.
        If the connection type is local, it starts a process with the file provided.


        local:
            kwargs :
                argv: Any | None = None,
                shell: bool = False,
                executable: Any | None = None,
                cwd: Any | None = None,
                env: Any | None = None,
                ignore_environ: Any | None = None,
                stdin: int = PIPE,
                stdout: PTY | int = PTY if not IS_WINDOWS else PIPE,
                stderr: int = STDOUT,
                close_fds: bool = True,
                preexec_fn: Any = lambda : None,
                raw: bool = True,
                aslr: Any | None = None,
                setuid: Any | None = None,
                where: str = &#39;local&#39;,
                display: Any | None = None,
                alarm: Any | None = None,
                creationflags: int = 0

    &#34;&#34;&#34;
    if self.conn_type == &#34;remote&#34; and self.url and self.port:
        self.conn = self.pwn.remote(self.url, self.port)
    elif self.conn_type == &#34;local&#34; and self.file:
        self.conn = self.pwn.process(str(self.challenge_file), **kwargs)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Connects to the challenge based on the connection type.
If the connection type is remote, it connects to the url and port provided.
If the connection type is local, it starts a process with the file provided.</p>
<p>local:
kwargs :
argv: Any | None = None,
shell: bool = False,
executable: Any | None = None,
cwd: Any | None = None,
env: Any | None = None,
ignore_environ: Any | None = None,
stdin: int = PIPE,
stdout: PTY | int = PTY if not IS_WINDOWS else PIPE,
stderr: int = STDOUT,
close_fds: bool = True,
preexec_fn: Any = lambda : None,
raw: bool = True,
aslr: Any | None = None,
setuid: Any | None = None,
where: str = 'local',
display: Any | None = None,
alarm: Any | None = None,
creationflags: int = 0</p></div>
</dd>
<dt id="ctfsolver.managers.manager_connections.ManagerConnections.initiate_connection"><code class="name flex">
<span>def <span class="ident">initiate_connection</span></span>(<span>self, *args, **kwargs) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initiate_connection(self, *args, **kwargs) -&gt; None:
    &#34;&#34;&#34;
    Initiates a connection using the specified connection type and parameters.
    Args:
        *args: Variable length argument list to be passed to the connection method.
        **kwargs: Arbitrary keyword arguments to be passed to the connection method.
    Returns:
        None
    &#34;&#34;&#34;

    self.connect(self.conn_type, *args, **kwargs)</code></pre>
</details>
<div class="desc"><p>Initiates a connection using the specified connection type and parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Variable length argument list to be passed to the connection method.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Arbitrary keyword arguments to be passed to the connection method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
</dd>
<dt id="ctfsolver.managers.manager_connections.ManagerConnections.recv_lines"><code class="name flex">
<span>def <span class="ident">recv_lines</span></span>(<span>self, number=1, display=False, save=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_lines(self, number=1, display=False, save=False):
    &#34;&#34;&#34;
    Description:
        Receives the output of the menu based on the number of lines provided.
        If display is True, it prints the output of everything received.
        If save is True, it saves the output in a list and returns it.

    Args:
        number (int, optional): Number of lines to receive . Defaults to 1.
        display (bool, optional): Displayes the lines received. Defaults to False.
        save (bool, optional): Saves the lines received to a list. Defaults to False.

    Returns:
        list: list of the lines received if save is True
    &#34;&#34;&#34;
    if save:
        result = []
    for _ in range(number):
        out = self.conn.recvline()
        if display:
            print(out)
        if save:
            result.append(out)
    if save:
        return result</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Receives the output of the menu based on the number of lines provided.
If display is True, it prints the output of everything received.
If save is True, it saves the output in a list and returns it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of lines to receive . Defaults to 1.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Displayes the lines received. Defaults to False.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Saves the lines received to a list. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of the lines received if save is True</dd>
</dl></div>
</dd>
<dt id="ctfsolver.managers.manager_connections.ManagerConnections.recv_menu"><code class="name flex">
<span>def <span class="ident">recv_menu</span></span>(<span>self, number=1, display=False, save=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_menu(self, number=1, display=False, save=False):
    raise DeprecationWarning(&#34;Depracated function. Use recv_lines instead.&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="ctfsolver.managers.manager_connections.ManagerConnections.recv_send"><code class="name flex">
<span>def <span class="ident">recv_send</span></span>(<span>self, text, lines=None, text_until=None, display=False, save=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_send(self, text, lines=None, text_until=None, display=False, save=False):
    &#34;&#34;&#34;
    Description:
        Receives lines and sends a response.
        It can receive a number or lines, and/or specific text.
        If save is True, it saves the output of the menu in a list and returns it.
        If display is True, it prints the output of everything received.

    Args:
        choice (int or str): Choice to send to the menu
        menu_num (int, optional): Number of options printed in the menu. Defaults to None.
        menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
        display (bool, optional): Variable to print every received line. Defaults to False.
        save (bool, optional): . Defaults to False.
    Returns:
        list: List of output of the menu if save is True
    &#34;&#34;&#34;
    if save:
        result = []

    if lines is None:
        lines = 0

    out_lines = self.recv_lines(number=lines, display=display, save=save)

    if save:
        result.extend(out_lines)

    if text_until:
        out_text_until = self.recv_until(text=text_until)

    if save:
        result.append(out_text_until)

    if display:
        print(out_text_until)

    self.send(text)

    if save:
        return result</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Receives lines and sends a response.
It can receive a number or lines, and/or specific text.
If save is True, it saves the output of the menu in a list and returns it.
If display is True, it prints the output of everything received.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>choice</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>Choice to send to the menu</dd>
<dt><strong><code>menu_num</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of options printed in the menu. Defaults to None.</dd>
<dt><strong><code>menu_text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text that the menu asks before sending your choice. Defaults to None.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Variable to print every received line. Defaults to False.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of output of the menu if save is True</dd>
</dl></div>
</dd>
<dt id="ctfsolver.managers.manager_connections.ManagerConnections.recv_until"><code class="name flex">
<span>def <span class="ident">recv_until</span></span>(<span>self, text, **kwargs) â€‘>Â bytes</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_until(self, text, **kwargs) -&gt; bytes:
    &#34;&#34;&#34;
    Description:
        Receive data until one of `delims`(text) provided is encountered. It encodes the text before sending it.
        Wrapper for self.conn.recvuntil(text.encode())
        Can also drop the ending if drop is True. If the request is not satisfied before ``timeout`` seconds pass, all data is buffered and an empty string (``&#39;&#39;``) is returned.
    Args:
        text (str): Text to receive until
        **kwargs: Additional keyword arguments to pass to the recv
            - drop (bool, optional): Drop the ending.  If :const:`True` it is removed from the end of the return value. Defaults to False.
            - timeout (int, optional): Timeout in seconds. Defaults to default.

    Raises:
        exceptions.EOFError: The connection closed before the request could be satisfied

    Returns:
        A string containing bytes received from the socket,
        or ``&#39;&#39;`` if a timeout occurred while waiting.

    &#34;&#34;&#34;

    # Handles the connection closed before the request could be satisfied
    try:
        return self.conn.recvuntil(text.encode(), **kwargs)
    except EOFError:
        print(&#34;Connection closed before the request could be satisfied&#34;)
        return b&#34;&#34;</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Receive data until one of <code>delims</code>(text) provided is encountered. It encodes the text before sending it.
Wrapper for self.conn.recvuntil(text.encode())
Can also drop the ending if drop is True. If the request is not satisfied before <code>timeout</code> seconds pass, all data is buffered and an empty string (<code>''</code>) is returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Text to receive until</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments to pass to the recv
- drop (bool, optional): Drop the ending.
If :const:<code>True</code> it is removed from the end of the return value. Defaults to False.
- timeout (int, optional): Timeout in seconds. Defaults to default.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>exceptions.EOFError</code></dt>
<dd>The connection closed before the request could be satisfied</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string containing bytes received from the socket,
or <code>''</code> if a timeout occurred while waiting.</p></div>
</dd>
<dt id="ctfsolver.managers.manager_connections.ManagerConnections.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, text, encode=True) â€‘>Â None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, text, encode=True) -&gt; None:
    &#34;&#34;&#34;
    Description:
        Sends the text to the connection after it encodes it.
        Wrapper for self.conn.sendline(str(text).encode())

    Args:
        text (str): Text to send
    &#34;&#34;&#34;
    # Check if the text is str or bytes and encode it
    if encode:
        self.conn.sendline(str(text).encode())
    else:
        self.conn.sendline(text)</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Sends the text to the connection after it encodes it.
Wrapper for self.conn.sendline(str(text).encode())</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Text to send</dd>
</dl></div>
</dd>
<dt id="ctfsolver.managers.manager_connections.ManagerConnections.send_menu"><code class="name flex">
<span>def <span class="ident">send_menu</span></span>(<span>self, choice, menu_num=None, menu_text=None, display=False, save=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_menu(
    self, choice, menu_num=None, menu_text=None, display=False, save=False
):
    &#34;&#34;&#34;
    Description:
        Gets the menu num either from the class or from the function call and saves it to the class.
        Gets the menu text that the menu is providing, receives until the menu asks for choice and then send out the choice.
        If save is True, it saves the output of the menu in a list and returns it.
        If display is True, it prints the output of everything received.

    Args:
        choice (int or str): Choice to send to the menu
        menu_num (int, optional): Number of options printed in the menu. Defaults to None.
        menu_text (str, optional): Text that the menu asks before sending your choice. Defaults to None.
        display (bool, optional): Variable to print every received line. Defaults to False.
        save (bool, optional): . Defaults to False.
    Returns:
        list: List of output of the menu if save is True
    &#34;&#34;&#34;

    # Sets up the menu options of the class instance
    if menu_num is None and self.menu_num is None:
        raise ValueError(&#34;Menu number not provided&#34;)

    if menu_num:
        self.menu_num = menu_num

    if menu_text is None and self.menu_text is None:
        raise ValueError(&#34;Menu text not provided&#34;)

    if menu_text:
        self.menu_text = menu_text

    return self.recv_send(
        choice,
        lines=self.menu_num,
        text_until=self.menu_text,
        display=display,
        save=save,
    )</code></pre>
</details>
<div class="desc"><h2 id="description">Description</h2>
<p>Gets the menu num either from the class or from the function call and saves it to the class.
Gets the menu text that the menu is providing, receives until the menu asks for choice and then send out the choice.
If save is True, it saves the output of the menu in a list and returns it.
If display is True, it prints the output of everything received.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>choice</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>Choice to send to the menu</dd>
<dt><strong><code>menu_num</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of options printed in the menu. Defaults to None.</dd>
<dt><strong><code>menu_text</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Text that the menu asks before sending your choice. Defaults to None.</dd>
<dt><strong><code>display</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Variable to print every received line. Defaults to False.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of output of the menu if save is True</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctfsolver.managers" href="index.html">ctfsolver.managers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctfsolver.managers.manager_connections.ManagerConnections" href="#ctfsolver.managers.manager_connections.ManagerConnections">ManagerConnections</a></code></h4>
<ul class="two-column">
<li><code><a title="ctfsolver.managers.manager_connections.ManagerConnections.connect" href="#ctfsolver.managers.manager_connections.ManagerConnections.connect">connect</a></code></li>
<li><code><a title="ctfsolver.managers.manager_connections.ManagerConnections.initiate_connection" href="#ctfsolver.managers.manager_connections.ManagerConnections.initiate_connection">initiate_connection</a></code></li>
<li><code><a title="ctfsolver.managers.manager_connections.ManagerConnections.recv_lines" href="#ctfsolver.managers.manager_connections.ManagerConnections.recv_lines">recv_lines</a></code></li>
<li><code><a title="ctfsolver.managers.manager_connections.ManagerConnections.recv_menu" href="#ctfsolver.managers.manager_connections.ManagerConnections.recv_menu">recv_menu</a></code></li>
<li><code><a title="ctfsolver.managers.manager_connections.ManagerConnections.recv_send" href="#ctfsolver.managers.manager_connections.ManagerConnections.recv_send">recv_send</a></code></li>
<li><code><a title="ctfsolver.managers.manager_connections.ManagerConnections.recv_until" href="#ctfsolver.managers.manager_connections.ManagerConnections.recv_until">recv_until</a></code></li>
<li><code><a title="ctfsolver.managers.manager_connections.ManagerConnections.send" href="#ctfsolver.managers.manager_connections.ManagerConnections.send">send</a></code></li>
<li><code><a title="ctfsolver.managers.manager_connections.ManagerConnections.send_menu" href="#ctfsolver.managers.manager_connections.ManagerConnections.send_menu">send_menu</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
