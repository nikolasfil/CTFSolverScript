<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>ctfsolver.inline.parser API documentation</title>
<meta name="description" content="parser.py â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ctfsolver.inline.parser</code></h1>
</header>
<section id="section-intro">
<p>parser.py</p>
<p>This module provides the Parser class for handling command-line arguments and dynamic command discovery
for the Inline tool. It leverages argparse and argcomplete to support flexible command-line interfaces,
automatically gathering available command methods and exposing them as selectable commands.</p>
<h2 id="classes">Classes</h2>
<p>Parser: Handles argument parsing, dynamic command discovery, and provides an interface for
extending command functionality.</p>
<h2 id="usage">Usage</h2>
<p>Instantiate the Parser class to parse command-line arguments and access dynamically discovered
commands. Extend the class with methods prefixed by 'function_' to add new commands.</p>
<h2 id="example">Example</h2>
<p>parser = Parser()
args = parser.args</p>
<h1 id="access-parsed-arguments-and-available-commands-via-parsercommand_list">Access parsed arguments and available commands via parser.command_list</h1>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ctfsolver.inline.parser.Parser"><code class="flex name class">
<span>class <span class="ident">Parser</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parser:
    def __init__(self, *args, **kwargs):
        self.parser = argparse.ArgumentParser(
            description=&#34;Inline tool for various operations&#34;
        )
        self.automatic_functions_gathering()
        self.add_arguments()

    def automatic_functions_gathering(self, self_save=True):
        &#34;&#34;&#34;
        Automatically gather all functions that start with &#34;function_&#34;
        and store them in the command_list attribute.
        This allows for dynamic command handling based on the available functions.
        The functions are expected to be methods of the InlineTool class.
        The gathered functions can be used as commands for the tool.
        The self_save parameter determines whether to save the gathered functions
        in the instance&#39;s command_list attribute.
        This is useful for dynamically updating the available commands without hardcoding them.

        Args:
            self_save (bool, optional):  Defaults to True.

        Returns:
            list: A list of function names that start with &#34;function_&#34;.
        &#34;&#34;&#34;
        self.functions = {
            func[9:]: getattr(self, func)
            for func in dir(self)
            if callable(getattr(self, func))
            and not func.startswith(&#34;__&#34;)
            and func.startswith(&#34;function_&#34;)
        }

        if self_save:
            self.command_list = list(sorted(self.functions.keys()))
        return self.functions

    def main(self):
        # This is an abstract method
        pass

    def add_arguments(self):
        &#34;&#34;&#34;
        Add command line arguments to the parser.

        &#34;&#34;&#34;

        # The initial command
        self.parser.add_argument(
            &#34;command&#34;,
            choices=self.command_list,
            help=&#34;Specify the operation to perform&#34;,
            nargs=&#34;?&#34;,
            default=None,
            # type=str,
            # metavar=&#34;COMMAND&#34;,
        )

        self.parser.add_argument(
            &#34;--dry-run&#34;,
            &#34;-d&#34;,
            action=&#34;store_true&#34;,
            help=&#34;Run the command without making any changes&#34;,
            required=False,
        )

        self.parser.add_argument(
            &#34;--category&#34;,
            &#34;-c&#34;,
            # choices=self.categories,
            type=str,
            help=&#34;Specify the category for the operation&#34;,
            required=False,
        )

        self.parser.add_argument(
            &#34;--site&#34;,
            &#34;-s&#34;,
            # choices=self.all_sites,
            type=str,
            help=&#34;Specify the site for the operation&#34;,
            required=False,
        )

        # Gather all the arguments parsed
        self.args = self.parser.parse_args()</code></pre>
</details>
<div class="desc"></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ctfsolver.inline.inline_tool.InlineTool" href="inline_tool.html#ctfsolver.inline.inline_tool.InlineTool">InlineTool</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ctfsolver.inline.parser.Parser.add_arguments"><code class="name flex">
<span>def <span class="ident">add_arguments</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_arguments(self):
    &#34;&#34;&#34;
    Add command line arguments to the parser.

    &#34;&#34;&#34;

    # The initial command
    self.parser.add_argument(
        &#34;command&#34;,
        choices=self.command_list,
        help=&#34;Specify the operation to perform&#34;,
        nargs=&#34;?&#34;,
        default=None,
        # type=str,
        # metavar=&#34;COMMAND&#34;,
    )

    self.parser.add_argument(
        &#34;--dry-run&#34;,
        &#34;-d&#34;,
        action=&#34;store_true&#34;,
        help=&#34;Run the command without making any changes&#34;,
        required=False,
    )

    self.parser.add_argument(
        &#34;--category&#34;,
        &#34;-c&#34;,
        # choices=self.categories,
        type=str,
        help=&#34;Specify the category for the operation&#34;,
        required=False,
    )

    self.parser.add_argument(
        &#34;--site&#34;,
        &#34;-s&#34;,
        # choices=self.all_sites,
        type=str,
        help=&#34;Specify the site for the operation&#34;,
        required=False,
    )

    # Gather all the arguments parsed
    self.args = self.parser.parse_args()</code></pre>
</details>
<div class="desc"><p>Add command line arguments to the parser.</p></div>
</dd>
<dt id="ctfsolver.inline.parser.Parser.automatic_functions_gathering"><code class="name flex">
<span>def <span class="ident">automatic_functions_gathering</span></span>(<span>self, self_save=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def automatic_functions_gathering(self, self_save=True):
    &#34;&#34;&#34;
    Automatically gather all functions that start with &#34;function_&#34;
    and store them in the command_list attribute.
    This allows for dynamic command handling based on the available functions.
    The functions are expected to be methods of the InlineTool class.
    The gathered functions can be used as commands for the tool.
    The self_save parameter determines whether to save the gathered functions
    in the instance&#39;s command_list attribute.
    This is useful for dynamically updating the available commands without hardcoding them.

    Args:
        self_save (bool, optional):  Defaults to True.

    Returns:
        list: A list of function names that start with &#34;function_&#34;.
    &#34;&#34;&#34;
    self.functions = {
        func[9:]: getattr(self, func)
        for func in dir(self)
        if callable(getattr(self, func))
        and not func.startswith(&#34;__&#34;)
        and func.startswith(&#34;function_&#34;)
    }

    if self_save:
        self.command_list = list(sorted(self.functions.keys()))
    return self.functions</code></pre>
</details>
<div class="desc"><p>Automatically gather all functions that start with "function_"
and store them in the command_list attribute.
This allows for dynamic command handling based on the available functions.
The functions are expected to be methods of the InlineTool class.
The gathered functions can be used as commands for the tool.
The self_save parameter determines whether to save the gathered functions
in the instance's command_list attribute.
This is useful for dynamically updating the available commands without hardcoding them.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>self_save</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of function names that start with "function_".</dd>
</dl></div>
</dd>
<dt id="ctfsolver.inline.parser.Parser.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self):
    # This is an abstract method
    pass</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ctfsolver.inline" href="index.html">ctfsolver.inline</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ctfsolver.inline.parser.Parser" href="#ctfsolver.inline.parser.Parser">Parser</a></code></h4>
<ul class="">
<li><code><a title="ctfsolver.inline.parser.Parser.add_arguments" href="#ctfsolver.inline.parser.Parser.add_arguments">add_arguments</a></code></li>
<li><code><a title="ctfsolver.inline.parser.Parser.automatic_functions_gathering" href="#ctfsolver.inline.parser.Parser.automatic_functions_gathering">automatic_functions_gathering</a></code></li>
<li><code><a title="ctfsolver.inline.parser.Parser.main" href="#ctfsolver.inline.parser.Parser.main">main</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
